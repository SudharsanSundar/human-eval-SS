from models import GPT, TogModel
from human_eval.data import read_problems, write_jsonl, stream_jsonl
import tqdm

import pprint as pp
from pprint import PrettyPrinter

ppr = pp.PrettyPrinter()


def list_generator(lst: list):
    for elem in lst:
        yield elem


'''
MBPP processing: wraps prompt in comment so it can compile as code. saves cleaned file.
'''
def create_proper_format_MBPP_file(old_file_path: str, out_fp: str) -> None:
    file = stream_jsonl(old_file_path)
    new_file = []

    for line in file:
        new_line = line
        new_line['prompt'] = "\"\"\"\n" + line['prompt'] + "\"\"\"\n"
        new_file.append(new_line)

    write_jsonl(out_fp, tqdm.tqdm(list_generator(new_file)))


'''
Makes sure entry point name exactly matches name of function written by the model (if lambda, automatically induces error, makes sure all potentially necessary imports are added, and  
'''
def fix_dumb_errors(problem_file_path: str, out_fp: str, answers_file_path: str):
    problems = stream_jsonl(problem_file_path)
    new_problems = []
    answers = stream_jsonl(answers_file_path)
    count_updated = [0, 0, 0]

    for problem, answer in zip(problems, answers):
        new_problem = problem

        # Match entry point name to name of function generated by the model
        def_pos = answer['completion'].find('def ')
        completion_def_only = answer['completion'][def_pos:]
        try:
            new_cand_name = completion_def_only.split('def ')[1].split('(')[0]
            old_name = problem['entry_point']
            new_problem['entry_point'] = new_cand_name
            count_updated[0] += int(new_cand_name != old_name)
        except IndexError:
            # This basically only happens when the model uses a lambda function to solve the problem, instead of a def
            print('IND ERR', answer['completion'])
            if 'lambda' in answer['completion']:
                new_problem['entry_point'] = 'LAMBDA'
                count_updated[1] += 1
            else:
                new_problem['entry_point'] = 'WEIRD_COMPLETION'
                count_updated[2] += 1

        # Add all potentially necessary imports. Below is from gpt3.5 answers to MBPP
        new_problem['prompt'] += '\nfrom itertools import product\nfrom math import radians, sin, cos, sqrt, atan2\nfrom math import gcd\nfrom collections import Counter\nimport heapq\nimport re\nimport itertools\nimport math\nfrom itertools import permutations\nimport cmath\n\n'

        new_problems.append(new_problem)

    print('updated this many entry point function names:', count_updated[0], 'this many lambdas:', count_updated[1], 'this many other weird ones:', count_updated[2])
    write_jsonl(out_fp, tqdm.tqdm(list_generator(new_problems)))

    return new_problems


def main():
    gpt3p5 = GPT()
    gpt4 = GPT(model='gpt-4-0125-preview')

    mbpp_raw_problems_fp = '../data/mbpp_problems_raw.jsonl'
    mbpp_partially_cleaned_fp = '../data/mbpp_problems_clean.jsonl'
    mbpp_answers_raw_fp = '../data/gpt3.5_defaultPrompt_MBPP_All_Results.jsonl'
    mbpp_answers = '../data/gpt3.5_defaultPrompt_MBPP_All_Results_CLEAN2.jsonl'
    mbpp_results_fp = '../data/gpt3.5_defaultPrompt_MBPP_All_Results_CLEAN2.jsonl_results.jsonl'

    # Add what you want
    # WARNING: most/all of the data processing functions will write to files. Make sure you get the names write and don't overwrite things you want to save.


if __name__ == "__main__":
    main()
