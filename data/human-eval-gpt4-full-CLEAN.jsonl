{"task_id": "HumanEval/0", "completion": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # Sort the list to make comparison easier and more efficient\n    numbers.sort()\n    \n    # Iterate through the list, comparing each element with the next one\n    for i in range(len(numbers) - 1):\n        # Calculate the difference between the current element and the next one\n        difference = abs(numbers[i] - numbers[i + 1])\n        \n        # If the difference is less than the threshold, return True\n        if difference < threshold:\n            return True\n    \n    # If no elements are closer to each other than the threshold, return False\n    return False"}
{"task_id": "HumanEval/1", "completion": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # List to store the separate groups of parentheses\n    groups = []\n    \n    # Counter to keep track of the balance of parentheses\n    balance = 0\n    \n    # Temporary string to build the current group of parentheses\n    current_group = \"\"\n    \n    for char in paren_string:\n        # Add the character to the current group\n        current_group += char\n        \n        # Update the balance counter\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        \n        # If the balance is zero, a group has ended\n        if balance == 0:\n            # Add the current group to the list of groups\n            groups.append(current_group)\n            # Reset the current group string for the next group\n            current_group = \"\"\n    \n    return groups"}
{"task_id": "HumanEval/2", "completion": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    an integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    \"\"\"\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part"}
{"task_id": "HumanEval/3", "completion": "def below_zero(operations: List[int]) -> bool:\n    balance = 0  # Start with a balance of 0\n    for operation in operations:\n        balance += operation  # Update the balance with each operation\n        if balance < 0:\n            return True  # Return True if balance goes below zero\n    return False  # Return False if balance never goes below zero"}
{"task_id": "HumanEval/4", "completion": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences from the mean\n    absolute_differences = [abs(x - mean) for x in numbers]\n    \n    # Calculate the mean of these absolute differences\n    mad = sum(absolute_differences) / len(absolute_differences)\n    \n    return mad"}
{"task_id": "HumanEval/5", "completion": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    if not numbers:  # If the list is empty, return an empty list\n        return []\n    \n    # Initialize the result list with the first element of the input list\n    result = [numbers[0]]\n    \n    # Iterate over the input list starting from the second element\n    for number in numbers[1:]:\n        # Append the delimiter and the current number to the result list\n        result.extend([delimiter, number])\n    \n    return result"}
{"task_id": "HumanEval/6", "completion": "def parse_nested_parens(paren_string: str) -> List[int]:\n    # Split the input string into groups based on spaces\n    groups = paren_string.split()\n    # Initialize an empty list to store the maximum nesting level for each group\n    max_nesting_levels = []\n\n    # Iterate through each group\n    for group in groups:\n        # Initialize the current level of nesting and the maximum level of nesting\n        current_level = 0\n        max_level = 0\n        # Iterate through each character in the group\n        for char in group:\n            if char == '(':\n                # If the character is an opening parenthesis, increase the current level of nesting\n                current_level += 1\n                # Update the maximum level of nesting if the current level is greater\n                max_level = max(max_level, current_level)\n            elif char == ')':\n                # If the character is a closing parenthesis, decrease the current level of nesting\n                current_level -= 1\n        # After processing the group, add the maximum level of nesting to the list\n        max_nesting_levels.append(max_level)\n\n    return max_nesting_levels"}
{"task_id": "HumanEval/7", "completion": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    # Filter the list by checking if the substring is in each string\n    return [string for string in strings if substring in string]"}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    # Initialize sum and product\n    total_sum = 0\n    total_product = 1\n    \n    # Check if the list is empty\n    if not numbers:\n        return (0, 1)\n    \n    # Iterate through the list to calculate sum and product\n    for number in numbers:\n        total_sum += number\n        total_product *= number\n    \n    return (total_sum, total_product)"}
{"task_id": "HumanEval/9", "completion": "def rolling_max(numbers: List[int]) -> List[int]:\n    # Initialize an empty list to store the rolling max values\n    rolling_max_values = []\n    # Initialize the current max to negative infinity to ensure any number will be larger\n    current_max = float('-inf')\n    # Iterate through each number in the input list\n    for number in numbers:\n        # Update the current max if the current number is greater\n        if number > current_max:\n            current_max = number\n        # Append the current max to the rolling max values list\n        rolling_max_values.append(current_max)\n    return rolling_max_values"}
{"task_id": "HumanEval/10", "completion": "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    if is_palindrome(string):\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string"}
{"task_id": "HumanEval/11", "completion": "def string_xor(a: str, b: str) -> str:\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate through each character in the strings\n    for char_a, char_b in zip(a, b):\n        # Perform XOR operation on each pair of characters and add to the result string\n        # int() is used to convert the characters to integers (0 or 1)\n        # The result of XOR is converted back to a string ('0' or '1') and concatenated\n        result += str(int(char_a) ^ int(char_b))\n    \n    return result"}
{"task_id": "HumanEval/12", "completion": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    \"\"\"\n    if not strings:  # Check if the list is empty\n        return None\n    \n    longest_str = strings[0]  # Start with the first string as the longest\n    for string in strings:\n        if len(string) > len(longest_str):  # Found a longer string\n            longest_str = string\n    \n    return longest_str"}
{"task_id": "HumanEval/13", "completion": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return the greatest common divisor of two integers a and b \"\"\"\n    while b:\n        a, b = b, a % b\n    return a"}
{"task_id": "HumanEval/14", "completion": "def all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    return [string[:i] for i in range(1, len(string) + 1)]"}
{"task_id": "HumanEval/15", "completion": "def string_sequence(n: int) -> str:\n    return ' '.join(str(i) for i in range(n + 1))"}
{"task_id": "HumanEval/16", "completion": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case to ignore case differences\n    lower_case_string = string.lower()\n    # Use a set to find distinct characters\n    distinct_characters = set(lower_case_string)\n    # Return the number of distinct characters\n    return len(distinct_characters)"}
{"task_id": "HumanEval/17", "completion": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    # Split the music string into individual notes\n    notes = music_string.split()\n    \n    # Initialize an empty list to store the beats for each note\n    beats = []\n    \n    # Iterate through each note and determine its type\n    for note in notes:\n        if note == 'o':\n            # Whole note, lasts four beats\n            beats.append(4)\n        elif note == 'o|':\n            # Half note, lasts two beats\n            beats.append(2)\n        elif note == '.|':\n            # Quarter note, lasts one beat\n            beats.append(1)\n    \n    # Return the list of beats\n    return beats"}
{"task_id": "HumanEval/18", "completion": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\"Find how many times a given substring can be found in the original string, including overlapping cases.\"\"\"\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count"}
{"task_id": "HumanEval/19", "completion": "def sort_numbers(numbers: str) -> str:\n    # Mapping of number words to their numeric values\n    number_word_to_value = {\n        'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,\n        'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9\n    }\n    \n    # Inverse mapping to convert numeric values back to words\n    value_to_number_word = {v: k for k, v in number_word_to_value.items()}\n    \n    # Split the input string into a list of number words\n    number_words = numbers.split()\n    \n    # Convert each number word to its numeric value\n    number_values = [number_word_to_value[word] for word in number_words]\n    \n    # Sort the list of numeric values\n    number_values.sort()\n    \n    # Convert the sorted numeric values back to number words\n    sorted_number_words = [value_to_number_word[value] for value in number_values]\n    \n    # Join the sorted list of number words into a single string\n    return ' '.join(sorted_number_words)"}
{"task_id": "HumanEval/20", "completion": "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    # Step 1: Sort the list\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and the smallest difference found so far\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Step 2: Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i+1] - sorted_numbers[i])\n        if current_diff < smallest_diff:\n            smallest_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n    \n    # Step 3: Return the closest pair\n    return closest_pair"}
{"task_id": "HumanEval/21", "completion": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    # Avoid division by zero in case all elements are the same\n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    \n    # Apply linear transformation\n    scaled_numbers = [(x - min_val) / (max_val - min_val) for x in numbers]\n    \n    return scaled_numbers"}
{"task_id": "HumanEval/22", "completion": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers \"\"\"\n    return [value for value in values if isinstance(value, int)]"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    return len(string)"}
{"task_id": "HumanEval/24", "completion": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # This line is technically not needed for positive n > 1, as the loop guarantees a return before reaching it."}
{"task_id": "HumanEval/25", "completion": "def factorize(n: int) -> List[int]:\n    factors = []  # List to store the prime factors\n    divisor = 2  # Start with the smallest prime number\n    \n    while n > 1:\n        while n % divisor == 0:  # Check if the number is divisible by the current divisor\n            factors.append(divisor)  # If so, add the divisor to the list of factors\n            n //= divisor  # Divide the number by the current divisor\n        divisor += 1  # Move to the next divisor\n        \n        # Optimization: If the divisor squared is greater than n, then n is a prime number\n        if divisor * divisor > n:\n            if n > 1:  # If there's anything left of n, it's a prime factor\n                factors.append(n)\n                break\n    \n    return factors"}
{"task_id": "HumanEval/26", "completion": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    # Count the occurrences of each number\n    counts = {}\n    for number in numbers:\n        counts[number] = counts.get(number, 0) + 1\n    \n    # Filter the list to include only numbers that occur once\n    return [number for number in numbers if counts[number] == 1]"}
{"task_id": "HumanEval/27", "completion": "def flip_case(string: str) -> str:\n    # Initialize an empty string to store the result\n    result = \"\"\n    # Iterate through each character in the input string\n    for char in string:\n        # If the character is uppercase, convert it to lowercase and add to the result\n        if char.isupper():\n            result += char.lower()\n        # If the character is lowercase, convert it to uppercase and add to the result\n        elif char.islower():\n            result += char.upper()\n        # If the character is neither (e.g., a digit or symbol), just add it as is\n        else:\n            result += char\n    return result"}
{"task_id": "HumanEval/28", "completion": "def concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n    # Use the join method to concatenate all strings in the list\n    return ''.join(strings)"}
{"task_id": "HumanEval/29", "completion": "def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    \"\"\"\n    return [s for s in strings if s.startswith(prefix)]"}
{"task_id": "HumanEval/30", "completion": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\"\"\"\n    return [num for num in l if num > 0]"}
{"task_id": "HumanEval/31", "completion": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    # 1 is not considered a prime number\n    if n <= 1:\n        return False\n    # 2 and 3 are prime numbers\n    if n <= 3:\n        return True\n    # Check if n is divisible by 2 or 3\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    # Check for divisors from 5 to the square root of n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True"}
{"task_id": "HumanEval/32", "completion": "def find_zero(xs: list):\n    \"\"\"\n    Finds a zero of the polynomial with coefficients xs using the Newton-Raphson method.\n    \"\"\"\n    # Initial guess for the root\n    x0 = 0.0\n    # Tolerance for the root's accuracy\n    tolerance = 1e-7\n    # Maximum number of iterations\n    max_iterations = 1000\n    \n    for _ in range(max_iterations):\n        # Evaluate the polynomial and its derivative at the current guess\n        fx = poly(xs, x0)\n        dfx = poly(poly_derivative(xs), x0)\n        # Check if the derivative is too small (to avoid division by zero)\n        if abs(dfx) < tolerance:\n            raise ValueError(\"Derivative too small; Newton-Raphson method might not converge.\")\n        # Update the guess using the Newton-Raphson formula\n        x0 = x0 - fx / dfx\n        # Check if the current guess is accurate enough\n        if abs(fx) < tolerance:\n            return x0\n    raise ValueError(\"Maximum iterations reached; solution might not have been found.\")"}
{"task_id": "HumanEval/33", "completion": "def sort_third(l: list):\n    # Extract elements at indices divisible by 3 (Python indices start at 0, so we adjust accordingly)\n    divisible_by_three_elements = [l[i] for i in range(len(l)) if (i + 1) % 3 == 0]\n    \n    # Sort these extracted elements\n    divisible_by_three_elements_sorted = sorted(divisible_by_three_elements)\n    \n    # Replace the original elements at these indices with the sorted ones\n    sorted_index = 0  # To keep track of the sorted elements' indices\n    for i in range(len(l)):\n        if (i + 1) % 3 == 0:\n            l[i] = divisible_by_three_elements_sorted[sorted_index]\n            sorted_index += 1\n    \n    return l"}
{"task_id": "HumanEval/34", "completion": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to a list and sort it\n    return sorted(list(set(l)))"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if not l:  # Check if the list is empty\n        return None  # Return None if the list is empty\n    max_val = l[0]  # Initialize max_val with the first element of the list\n    for num in l:  # Iterate through each element in the list\n        if num > max_val:  # Compare current element with max_val\n            max_val = num  # Update max_val if current element is greater\n    return max_val  # Return the maximum value found in the list"}
{"task_id": "HumanEval/36", "completion": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"task_id": "HumanEval/37", "completion": "def sort_even(l: list):\n    # Extract elements at even indices\n    even_indices_elements = [l[i] for i in range(len(l)) if i % 2 == 0]\n    # Sort the extracted elements\n    even_indices_elements_sorted = sorted(even_indices_elements)\n    \n    # Create a new list to hold the result\n    result = l[:]\n    \n    # Replace the elements at even indices in the result list with the sorted elements\n    j = 0  # Index for the sorted even elements list\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result[i] = even_indices_elements_sorted[j]\n            j += 1\n    \n    return result"}
{"task_id": "HumanEval/38", "completion": "def decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    # Split the encoded string into groups of three characters\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # Cycle elements in each group to the left by one position, unless the group has fewer than 3 elements\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    # Join the groups back into a single string\n    return \"\".join(groups)"}
{"task_id": "HumanEval/39", "completion": "def prime_fib(n):\n    \"\"\"\n    Returns the n-th number that is a Fibonacci number and it's also prime.\n    \"\"\"\n    count = 0\n    fib_num = 0\n    while True:\n        fib_num += 1\n        fib_n = fib(fib_num)\n        if is_prime(fib_n):\n            count += 1\n            if count == n:\n                return fib_n"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list):\n    n = len(l)  # Get the length of the list\n    # Iterate through each element. We use n-2 for the first loop because\n    # we need at least two more elements for the triple.\n    for i in range(n-2):\n        # Second loop starts from i+1 to ensure distinct elements\n        for j in range(i+1, n-1):\n            # Third loop starts from j+1 to ensure distinct elements\n            for k in range(j+1, n):\n                # Check if the sum of the current triple is zero\n                if l[i] + l[j] + l[k] == 0:\n                    return True  # Return True if a triple with sum zero is found\n    return False  # Return False if no such triple is found"}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    Calculate the total number of collisions between two sets of n cars moving towards each other.\n    \n    :param n: Number of cars in each set moving towards each other.\n    :return: Total number of collisions.\n    \"\"\"\n    return n ** 2"}
{"task_id": "HumanEval/42", "completion": "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    return [x + 1 for x in l]"}
{"task_id": "HumanEval/43", "completion": "def pairs_sum_to_zero(l):\n    seen = set()  # To store elements we've seen so far\n    for num in l:\n        if -num in seen:  # Check if the negation of the current number has been seen\n            return True\n        seen.add(num)  # Add the current number to the set of seen numbers\n    return False"}
{"task_id": "HumanEval/44", "completion": "def change_base(x: int, base: int) -> str:\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    \"\"\"\n    if x < base:\n        return str(x)\n    else:\n        return change_base(x // base, base) + str(x % base)"}
{"task_id": "HumanEval/45", "completion": "def triangle_area(a, h):\n    return 0.5 * a * h"}
{"task_id": "HumanEval/46", "completion": "def fib4(n: int) -> int:\n    # Base cases directly defined as per the sequence definition\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n\n    # Initialize the first four values of the sequence\n    a, b, c, d = 0, 0, 2, 0\n\n    # Loop from 4 up to n (inclusive) to calculate the n-th term\n    for _ in range(4, n + 1):\n        # Calculate the next term in the sequence\n        next_term = a + b + c + d\n        # Update the previous four terms for the next iteration\n        a, b, c, d = b, c, d, next_term\n\n    # The loop ends with 'd' holding the value of fib4(n)\n    return d"}
{"task_id": "HumanEval/47", "completion": "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    sorted_list = sorted(l)  # Sort the list\n    n = len(sorted_list)\n    \n    if n % 2 == 1:  # If the list has an odd number of elements\n        return sorted_list[n // 2]\n    else:  # If the list has an even number of elements\n        return (sorted_list[n // 2 - 1] + sorted_list[n // 2]) / 2"}
{"task_id": "HumanEval/48", "completion": "def is_palindrome(text: str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n    # A string is a palindrome if it reads the same forwards and backwards.\n    # To check this, we compare the string with its reverse.\n    return text == text[::-1]"}
{"task_id": "HumanEval/49", "completion": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    result = 1  # Initialize result\n    base = 2  # Base number 2, since we are computing 2^n\n    \n    # Update n and base under modulo p\n    while n > 0:\n        # If n is odd, multiply the base with result\n        if n % 2 == 1:\n            result = (result * base) % p\n        \n        # Now n must be even, divide it by 2\n        n = n // 2\n        base = (base * base) % p\n    \n    return result"}
{"task_id": "HumanEval/50", "completion": "def decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"task_id": "HumanEval/51", "completion": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])"}
{"task_id": "HumanEval/52", "completion": "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"Return True if all numbers in the list l are below threshold t.\"\"\"\n    for number in l:\n        if number >= t:\n            return False\n    return True"}
{"task_id": "HumanEval/53", "completion": "def add(x, y):\n    return x + y"}
{"task_id": "HumanEval/54", "completion": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert both strings into sets of characters\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Compare the sets to determine if the strings have the same characters\n    return set_s0 == set_s1"}
{"task_id": "HumanEval/55", "completion": "def fib(n: int, memo={0: 0, 1: 1}) -> int:\n    \"\"\"Return n-th Fibonacci number using memoization to improve efficiency.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n not in memo:\n        memo[n] = fib(n-1, memo) + fib(n-2, memo)\n    return memo[n]"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    balance = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            balance += 1\n        elif bracket == \">\":\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list) -> bool:\n    # Check if the list is empty or has one element, in which case it's trivially monotonic\n    if len(l) <= 1:\n        return True\n    \n    # Determine if the list is increasing or decreasing based on the first two elements\n    # This handles lists with constant values as well\n    increasing = None\n    for i in range(len(l) - 1):\n        if l[i] < l[i + 1]:\n            if increasing == False:\n                return False\n            increasing = True\n        elif l[i] > l[i + 1]:\n            if increasing == True:\n                return False\n            increasing = False\n    \n    # If the loop completes without returning False, the list is monotonic\n    return True"}
{"task_id": "HumanEval/58", "completion": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    # Convert both lists to sets to find the unique elements, then find the intersection\n    common_elements = set(l1).intersection(set(l2))\n    # Return the sorted list of the common elements\n    return sorted(list(common_elements))"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    # Factor out all 2s\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n    \n    # Check for odd factors\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            max_prime = i\n            n //= i\n        i += 2\n    \n    # If n becomes a prime number > 2\n    if n > 2:\n        max_prime = n\n    \n    return max_prime"}
{"task_id": "HumanEval/60", "completion": "def sum_to_n(n: int) -> int:\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return n * (n + 1) // 2"}
{"task_id": "HumanEval/61", "completion": "def correct_bracketing(brackets: str) -> bool:\n    balance = 0\n    for bracket in brackets:\n        if bracket == '(':\n            balance += 1\n        elif bracket == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list):\n    return [xs[i] * i for i in range(1, len(xs))]"}
{"task_id": "HumanEval/63", "completion": "def fibfib(n: int) -> int:\n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    # Initialize a list to store computed values\n    fibfib_values = [0] * (n+1)\n    fibfib_values[0] = 0\n    fibfib_values[1] = 0\n    fibfib_values[2] = 1\n    \n    # Compute the n-th element using dynamic programming\n    for i in range(3, n+1):\n        fibfib_values[i] = fibfib_values[i-1] + fibfib_values[i-2] + fibfib_values[i-3]\n    \n    return fibfib_values[n]"}
{"task_id": "HumanEval/64", "completion": "def vowels_count(s):\n    \"\"\"\n    This function counts the number of vowels in a given string. Vowels are 'a', 'e', 'i', 'o', 'u',\n    and 'y' is considered a vowel only if it is at the end of the word.\n    \"\"\"\n    # Convert the string to lowercase to make the function case-insensitive\n    s = s.lower()\n    \n    # Initialize the count of vowels to 0\n    count = 0\n    \n    # Define the vowels\n    vowels = \"aeiou\"\n    \n    # Check each character in the string\n    for char in s:\n        # If the character is a vowel, increment the count\n        if char in vowels:\n            count += 1\n    \n    # Check if the last character is 'y', and if so, increment the count\n    if s.endswith('y'):\n        count += 1\n    \n    return count"}
{"task_id": "HumanEval/65", "completion": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    \"\"\"\n    # Convert the integer to a string to manipulate its digits\n    x_str = str(x)\n    n = len(x_str)  # Number of digits in x\n    \n    # If shift is greater than the number of digits, reverse the digits\n    if shift > n:\n        return x_str[::-1]\n    \n    # Calculate the effective shift needed (taking mod with n handles cases where shift >= n)\n    shift = shift % n\n    \n    # Perform the circular shift\n    shifted_str = x_str[-shift:] + x_str[:-shift]\n    \n    return shifted_str"}
{"task_id": "HumanEval/66", "completion": "def digitSum(s):\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is an uppercase letter\n        if char.isupper():\n            # Add the ASCII value of the character to the total sum\n            total_sum += ord(char)\n    \n    # Return the total sum\n    return total_sum"}
{"task_id": "HumanEval/67", "completion": "def fruit_distribution(s, n):\n    # Split the input string to extract the numbers\n    parts = s.split()\n    # The number of apples is the first number in the string\n    apples = int(parts[0])\n    # The number of oranges is the third number in the string (after \"apples and\")\n    oranges = int(parts[3])\n    # Calculate the number of mangoes by subtracting apples and oranges from the total\n    mangoes = n - apples - oranges\n    return mangoes"}
{"task_id": "HumanEval/68", "completion": "def pluck(arr):\n    # Initialize variables to store the smallest even value and its index\n    smallest_even = None\n    smallest_index = -1\n    \n    # Iterate through the array\n    for i, value in enumerate(arr):\n        # Check if the current value is even\n        if value % 2 == 0:\n            # If no smallest even value has been found yet or the current value is smaller\n            if smallest_even is None or value < smallest_even:\n                smallest_even = value\n                smallest_index = i\n    \n    # Check if a smallest even value was found\n    if smallest_even is not None:\n        return [smallest_even, smallest_index]\n    else:\n        return []"}
{"task_id": "HumanEval/69", "completion": "def search(lst):\n    # Step 1: Count the frequency of each integer\n    frequency = {}\n    for num in lst:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Step 2 and 3: Find the maximum number whose frequency is >= the number itself\n    max_num = -1\n    for num, freq in frequency.items():\n        if num <= freq:\n            max_num = max(max_num, num)\n    \n    # Step 4: Return the result\n    return max_num"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    result = []\n    while lst:\n        # Append the minimum value and remove it from the list\n        min_val = min(lst)\n        result.append(min_val)\n        lst.remove(min_val)\n        \n        # If the list is not empty, append the maximum value and remove it\n        if lst:\n            max_val = max(lst)\n            result.append(max_val)\n            lst.remove(max_val)\n    return result"}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a, b, c):\n    # Check if the sides form a valid triangle\n    if (a + b > c) and (a + c > b) and (b + c > a):\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        # Return the area rounded to 2 decimal points\n        return round(area, 2)\n    else:\n        # If the sides do not form a valid triangle, return -1\n        return -1"}
{"task_id": "HumanEval/72", "completion": "def will_it_fly(q, w):\n    # Check if the list is a palindrome\n    is_balanced = q == q[::-1]\n    \n    # Calculate the sum of the elements in the list\n    total_weight = sum(q)\n    \n    # Check if it's balanced and the total weight is less than or equal to the maximum possible weight\n    return is_balanced and total_weight <= w"}
{"task_id": "HumanEval/73", "completion": "def smallest_change(arr):\n    # Initialize two pointers\n    left = 0\n    right = len(arr) - 1\n    \n    # Initialize the counter for changes\n    changes = 0\n    \n    # Loop until the two pointers meet or cross\n    while left < right:\n        # If the elements at the two pointers are not the same,\n        # increment the change counter\n        if arr[left] != arr[right]:\n            changes += 1\n        \n        # Move the pointers towards the center\n        left += 1\n        right -= 1\n    \n    return changes"}
{"task_id": "HumanEval/74", "completion": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1"}
{"task_id": "HumanEval/75", "completion": "def is_multiply_prime(a):\n    \"\"\"Returns true if the given number is the multiplication of 3 prime numbers, false otherwise.\"\"\"\n    # Generate a list of prime numbers less than 'a'\n    primes = [i for i in range(2, a) if is_prime(i)]\n    \n    # Iterate through combinations of three primes to see if their product equals 'a'\n    for i in range(len(primes)):\n        for j in range(i + 1, len(primes)):\n            for k in range(j + 1, len(primes)):\n                if primes[i] * primes[j] * primes[k] == a:\n                    return True\n    return False"}
{"task_id": "HumanEval/76", "completion": "def is_simple_power(x, n):\n    # Handle edge cases\n    if x == 1:\n        return True  # Because n**0 is always 1 for any n\n    if n in [0, 1]:\n        return False  # 0 or 1 raised to any power won't match x > 1\n    \n    # Check if x is a power of n\n    current_power = n\n    while current_power <= x:\n        if current_power == x:\n            return True\n        current_power *= n\n    \n    return False"}
{"task_id": "HumanEval/77", "completion": "def iscube(a):\n    # Calculate the cube root of the absolute value of a\n    # We use abs(a) to handle negative numbers correctly\n    cube_root = abs(a) ** (1/3)\n    \n    # Round the cube root to the nearest integer\n    rounded_cube_root = round(cube_root)\n    \n    # Check if the cube of the rounded cube root equals the original number\n    # This works for both positive and negative numbers since\n    # the cube of a negative number is negative\n    return rounded_cube_root ** 3 == a"}
{"task_id": "HumanEval/78", "completion": "def hex_key(num):\n    # Define a set of prime hexadecimal digits\n    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Initialize a counter for prime digits\n    prime_count = 0\n    \n    # Iterate through each character in the input string\n    for digit in num:\n        # Check if the digit is a prime hexadecimal digit\n        if digit in prime_hex_digits:\n            # Increment the counter\n            prime_count += 1\n            \n    # Return the count of prime hexadecimal digits\n    return prime_count"}
{"task_id": "HumanEval/79", "completion": "def decimal_to_binary(decimal):\n    # Step 1: Convert the decimal number to binary using bin() and remove the '0b' prefix.\n    binary_str = bin(decimal)[2:]\n    \n    # Step 2 & 3: Add 'db' at the beginning and the end of the binary string.\n    formatted_binary_str = \"db\" + binary_str + \"db\"\n    \n    # Step 4: Return the formatted binary string.\n    return formatted_binary_str"}
{"task_id": "HumanEval/80", "completion": "def is_happy(s):\n    # Check if the string's length is less than 3\n    if len(s) < 3:\n        return False\n    \n    # Iterate through the string, stopping at the third-to-last character\n    for i in range(len(s) - 2):\n        # Check if the current character, the next one, and the one after that are distinct\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    \n    # If we've made it here, the string is happy\n    return True"}
{"task_id": "HumanEval/81", "completion": "def numerical_letter_grade(grades):\n    # Initialize an empty list to store the letter grades\n    letter_grades = []\n    \n    # Iterate through each GPA in the grades list\n    for gpa in grades:\n        # Compare the GPA against the grading scale and assign the letter grade\n        if gpa == 4.0:\n            grade = 'A+'\n        elif gpa > 3.7:\n            grade = 'A'\n        elif gpa > 3.3:\n            grade = 'A-'\n        elif gpa > 3.0:\n            grade = 'B+'\n        elif gpa > 2.7:\n            grade = 'B'\n        elif gpa > 2.3:\n            grade = 'B-'\n        elif gpa > 2.0:\n            grade = 'C+'\n        elif gpa > 1.7:\n            grade = 'C'\n        elif gpa > 1.3:\n            grade = 'C-'\n        elif gpa > 1.0:\n            grade = 'D+'\n        elif gpa > 0.7:\n            grade = 'D'\n        elif gpa > 0.0:\n            grade = 'D-'\n        else:\n            grade = 'E'\n        \n        # Append the letter grade to the list\n        letter_grades.append(grade)\n    \n    # Return the list of letter grades\n    return letter_grades"}
{"task_id": "HumanEval/82", "completion": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/83", "completion": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    if n == 1:\n        # If n is 1, then there's only 1 such number, which is 1 itself.\n        return 1\n    else:\n        # For n > 1, calculate using the formula derived above.\n        return (10**(n-1) + 10**(n-1) - 10**(n-2))"}
{"task_id": "HumanEval/84", "completion": "def solve(N):\n    # Step 1: Convert N to a string to iterate through its digits\n    N_str = str(N)\n    \n    # Step 2: Sum up the digits\n    sum_of_digits = sum(int(digit) for digit in N_str)\n    \n    # Step 3: Convert the sum into a binary string\n    binary_sum = bin(sum_of_digits)[2:]  # [2:] to remove the '0b' prefix\n    \n    # Step 4: Return the binary string\n    return binary_sum"}
{"task_id": "HumanEval/85", "completion": "def add(lst):\n    # Initialize sum of even elements at odd indices\n    sum_even_odd_idx = 0\n    \n    # Iterate through the list with index\n    for idx, element in enumerate(lst):\n        # Check if index is odd and element is even\n        if idx % 2 != 0 and element % 2 == 0:\n            sum_even_odd_idx += element\n            \n    return sum_even_odd_idx"}
{"task_id": "HumanEval/86", "completion": "def anti_shuffle(s):\n    # Split the input string into words and non-word parts\n    # This regex pattern will match words and non-words (like spaces and punctuation) separately\n    import re\n    parts = re.findall(r'\\b\\w+\\b|[^\\w\\s]', s)\n    \n    # Process each part: if it's a word, sort its characters; otherwise, leave it as is\n    processed_parts = [''.join(sorted(part)) if part.isalpha() else part for part in parts]\n    \n    # Join the processed parts back together\n    result = ''.join(processed_parts)\n    \n    return result"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate through each row with its index\n    for row_idx, row in enumerate(lst):\n        # Iterate through each element in the row with its index\n        for col_idx, element in enumerate(row):\n            # Check if the element matches x\n            if element == x:\n                # Append the tuple (row index, column index) to the coordinates list\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort the coordinates list\n    # First by row index in ascending order, then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates"}
{"task_id": "HumanEval/88", "completion": "def sort_array(array):\n    # Check if the array is empty or has only one element\n    if len(array) <= 1:\n        return array\n    \n    # Make a copy of the array to avoid modifying the original array\n    array_copy = array[:]\n    \n    # Calculate the sum of the first and last elements\n    sum_first_last = array_copy[0] + array_copy[-1]\n    \n    # Sort the array based on the sum being odd or even\n    if sum_first_last % 2 == 0:\n        # If the sum is even, sort in descending order\n        array_copy.sort(reverse=True)\n    else:\n        # If the sum is odd, sort in ascending order\n        array_copy.sort()\n    \n    return array_copy"}
{"task_id": "HumanEval/89", "completion": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():  # Check if the character is an alphabet letter\n            # Calculate the new character, considering both uppercase and lowercase letters\n            if char.islower():\n                new_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            else:\n                new_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            result += new_char\n        else:\n            # If the character is not an alphabet letter, just add it as it is\n            result += char\n    return result"}
{"task_id": "HumanEval/90", "completion": "def next_smallest(lst):\n    # Remove duplicates by converting the list to a set, then back to a list\n    unique_lst = list(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_lst) < 2:\n        return None\n    \n    # Sort the list\n    unique_lst.sort()\n    \n    # Return the 2nd element\n    return unique_lst[1]"}
{"task_id": "HumanEval/91", "completion": "def is_bored(S):\n    # Split the string into sentences based on '.', '?', and '!'\n    sentences = []\n    temp_sentence = ''\n    for char in S:\n        if char in '.?!':\n            sentences.append(temp_sentence.strip())\n            temp_sentence = ''\n        else:\n            temp_sentence += char\n    if temp_sentence:  # Add the last sentence if there's any\n        sentences.append(temp_sentence.strip())\n\n    # Count the sentences that start with \"I\" or \"I \"\n    boredom_count = 0\n    for sentence in sentences:\n        if sentence.startswith(\"I \") or sentence == \"I\":\n            boredom_count += 1\n\n    return boredom_count"}
{"task_id": "HumanEval/92", "completion": "def any_int(x, y, z):\n    # First, check if all numbers are integers\n    if all(isinstance(i, int) for i in [x, y, z]):\n        # Check if any number is equal to the sum of the other two\n        return x == y + z or y == x + z or z == x + y\n    else:\n        # If not all numbers are integers, return False\n        return False"}
{"task_id": "HumanEval/93", "completion": "def encode(message):\n    # Mapping of vowels to their replacements\n    vowel_replacements = {\n        'a': 'c', 'A': 'C',\n        'e': 'g', 'E': 'G',\n        'i': 'k', 'I': 'K',\n        'o': 'q', 'O': 'Q',\n        'u': 'w', 'U': 'W'\n    }\n    \n    # Function to swap case\n    def swap_case(char):\n        if char.islower():\n            return char.upper()\n        else:\n            return char.lower()\n    \n    # Encoded message\n    encoded_message = ''\n    \n    for char in message:\n        # Swap case\n        swapped_char = swap_case(char)\n        \n        # Replace vowel if it's a vowel, else keep the swapped character\n        encoded_char = vowel_replacements.get(swapped_char, swapped_char)\n        \n        # Append to the encoded message\n        encoded_message += encoded_char\n    \n    return encoded_message"}
{"task_id": "HumanEval/94", "completion": "def skjkasdkd(lst):\n    \"\"\"Find the largest prime value in the list and return the sum of its digits.\"\"\"\n    largest_prime = 0\n    for num in lst:\n        if is_prime(num) and num > largest_prime:\n            largest_prime = num\n    return sum(int(digit) for digit in str(largest_prime))"}
{"task_id": "HumanEval/95", "completion": "def check_dict_case(dict):\n    # Step 1: Check if the dictionary is empty\n    if not dict:\n        return False\n    \n    # Step 2: Check if all keys are strings\n    if not all(isinstance(key, str) for key in dict.keys()):\n        return False\n    \n    # Step 3: Check if all keys are either in lower case or upper case\n    all_lower = all(key.islower() for key in dict.keys() if isinstance(key, str))\n    all_upper = all(key.isupper() for key in dict.keys() if isinstance(key, str))\n    \n    # Step 4: Return True if either all keys are lower case or all keys are upper case\n    return all_lower or all_upper"}
{"task_id": "HumanEval/96", "completion": "def count_up_to(n):\n    \"\"\"Function that returns an array of the first n integers that are prime numbers and less than n.\"\"\"\n    primes = []\n    for num in range(2, n):\n        if is_prime(num):\n            primes.append(num)\n    return primes"}
{"task_id": "HumanEval/97", "completion": "def multiply(a, b):\n    # Extract the unit digit of each number by getting the remainder when divided by 10\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    \n    # Multiply the unit digits together\n    product = unit_digit_a * unit_digit_b\n    \n    return product"}
{"task_id": "HumanEval/98", "completion": "def count_upper(s):\n    # Initialize the counter\n    count = 0\n    \n    # Define a string of uppercase vowels for comparison\n    uppercase_vowels = 'AEIOU'\n    \n    # Iterate through the string, checking only even indices\n    for i in range(0, len(s), 2):\n        # Check if the character at the even index is an uppercase vowel\n        if s[i] in uppercase_vowels:\n            # Increment the counter\n            count += 1\n            \n    # Return the final count\n    return count"}
{"task_id": "HumanEval/99", "completion": "def closest_integer(value):\n    # Convert the string to a floating-point number\n    num = float(value)\n    \n    # Get the floor value (the largest integer less than or equal to num)\n    floor_value = int(num)\n    \n    # Calculate the difference between the num and its floor value\n    diff = num - floor_value\n    \n    # If the difference is less than 0.5, return the floor value\n    if diff < 0.5:\n        return floor_value\n    # If the difference is exactly 0.5, round away from zero\n    elif diff == 0.5:\n        if num > 0:\n            return floor_value + 1\n        else:\n            return floor_value - 1\n    # If the difference is greater than 0.5, round up (away from zero)\n    else:\n        if num > 0:\n            return floor_value + 1\n        else:\n            return floor_value"}
{"task_id": "HumanEval/100", "completion": "def make_a_pile(n):\n    # Initialize the list with the first level\n    pile = [n]\n    \n    # Determine the starting point for the next level\n    next_stone_count = n\n    \n    # Loop to fill up the pile up to n levels\n    for _ in range(1, n):\n        # Determine the next number of stones based on the parity of n\n        if n % 2 == 0:  # n is even\n            next_stone_count += 2  # Add the next even number\n        else:  # n is odd\n            next_stone_count += 2  # Add the next odd number\n        \n        # Append the number of stones for the next level to the pile\n        pile.append(next_stone_count)\n    \n    return pile"}
{"task_id": "HumanEval/101", "completion": "def words_string(s):\n    # Split the string by commas or spaces and filter out any empty strings\n    words = [word for word in re.split(r'[,\\s]+', s) if word]\n    return words"}
{"task_id": "HumanEval/102", "completion": "def choose_num(x, y):\n    # Ensure x is less than or equal to y\n    if x > y:\n        x, y = y, x  # Swap values if x is greater than y\n    \n    # Iterate from y down to x to find the largest even number\n    for num in range(y, x-1, -1):  # Start from y, go down to x\n        if num % 2 == 0:  # Check if the number is even\n            return num  # Return the first even number found\n    \n    # If no even number is found, return -1\n    return -1"}
{"task_id": "HumanEval/103", "completion": "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    # Calculate the number of terms\n    num_terms = m - n + 1\n    # Calculate the sum of the series\n    total_sum = (num_terms * (n + m)) // 2\n    # Calculate the average and round it\n    avg = round(total_sum / num_terms)\n    # Convert the rounded average to binary\n    return bin(avg)"}
{"task_id": "HumanEval/104", "completion": "def unique_digits(x):\n    # Initialize an empty list to store numbers with no even digits\n    no_even_digits = []\n    \n    # Iterate through each number in the given list\n    for num in x:\n        # Convert the number to a string to easily iterate through its digits\n        num_str = str(num)\n        # Use a flag to keep track of whether the number has an even digit\n        has_even_digit = False\n        \n        # Check each digit of the number\n        for digit in num_str:\n            # If the digit is even, set the flag to True and break the loop\n            if int(digit) % 2 == 0:\n                has_even_digit = True\n                break\n        \n        # If the number does not have any even digit, add it to the list\n        if not has_even_digit:\n            no_even_digits.append(num)\n    \n    # Sort the list of numbers with no even digits in increasing order\n    no_even_digits.sort()\n    \n    # Return the sorted list\n    return no_even_digits"}
{"task_id": "HumanEval/105", "completion": "def by_length(arr):\n    # Step 1: Filter the array for numbers between 1 and 9\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Step 2: Sort the filtered array\n    sorted_arr = sorted(filtered_arr)\n    \n    # Step 3: Reverse the sorted array\n    reversed_arr = sorted_arr[::-1]\n    \n    # Step 4: Replace each integer with its corresponding name\n    num_to_name = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    result = [num_to_name[num] for num in reversed_arr]\n    \n    return result"}
{"task_id": "HumanEval/106", "completion": "def f(n):\n    def factorial(x):\n        \"\"\"Helper function to calculate factorial of x.\"\"\"\n        if x == 0:\n            return 1\n        else:\n            return x * factorial(x-1)\n    \n    def sum_to_x(x):\n        \"\"\"Helper function to calculate sum of numbers from 1 to x.\"\"\"\n        return sum(range(1, x+1))\n    \n    result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:  # If i is even\n            result.append(factorial(i))\n        else:  # If i is odd\n            result.append(sum_to_x(i))\n    \n    return result"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    even_count = 0\n    odd_count = 0\n    \n    for num in range(1, n + 1):\n        if is_palindrome(num):\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n                \n    return (even_count, odd_count)"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    def sum_of_digits(n):\n        # If the number is negative, make it positive and remember it's negative\n        is_negative = n < 0\n        n = abs(n)\n        sum_digits = 0\n        while n > 0:\n            sum_digits += n % 10\n            n //= 10\n        # If the original number was negative, subtract twice the value of the first digit\n        # to account for its negative sign\n        if is_negative:\n            sum_digits -= 2 * (sum_digits % 10)\n        return sum_digits\n\n    count = 0\n    for num in arr:\n        if sum_of_digits(num) > 0:\n            count += 1\n    return count"}
{"task_id": "HumanEval/109", "completion": "def move_one_ball(arr):\n    # If the array is empty or has one element, it's already sorted\n    if len(arr) <= 1:\n        return True\n    \n    # Check if the array is already sorted\n    if arr == sorted(arr):\n        return True\n    \n    # Count the number of descending orders\n    desc_count = 0\n    for i in range(1, len(arr)):\n        if arr[i-1] > arr[i]:\n            desc_count += 1\n            # Save the index where the descending order occurs\n            desc_index = i\n    \n    # If there are more than one descending orders, it's not possible to sort by right shift\n    if desc_count > 1:\n        return False\n    \n    # For the case where there's exactly one descending order,\n    # Check if performing right shift operations can sort the array\n    # This is true if the last element is greater than the first element\n    # Because we can rotate the array such that the smallest element (at desc_index) moves to the beginning\n    if arr[-1] > arr[0]:\n        return True\n    else:\n        return False"}
{"task_id": "HumanEval/110", "completion": "def exchange(lst1, lst2):\n    # Count the number of odd numbers in lst1\n    odd_count_lst1 = sum(1 for x in lst1 if x % 2 != 0)\n    \n    # Count the number of even numbers in lst2\n    even_count_lst2 = sum(1 for x in lst2 if x % 2 == 0)\n    \n    # If there are enough even numbers in lst2 to exchange with all odd numbers in lst1, return \"YES\"\n    if odd_count_lst1 <= even_count_lst2:\n        return \"YES\"\n    else:\n        return \"NO\""}
{"task_id": "HumanEval/111", "completion": "def histogram(test):\n    # Split the input string into a list of letters\n    letters = test.split()\n    \n    # Use a dictionary to count the occurrences of each letter\n    letter_counts = {}\n    for letter in letters:\n        if letter in letter_counts:\n            letter_counts[letter] += 1\n        else:\n            letter_counts[letter] = 1\n    \n    # Find the maximum count of occurrences\n    max_count = max(letter_counts.values(), default=0)\n    \n    # Create a new dictionary that includes only the letters with the maximum count\n    max_letters = {letter: count for letter, count in letter_counts.items() if count == max_count}\n    \n    return max_letters"}
{"task_id": "HumanEval/112", "completion": "def reverse_delete(s, c):\n    # Step 1: Remove characters in s that are in c\n    result_string = ''.join([char for char in s if char not in c])\n    \n    # Step 2: Check if the result string is a palindrome\n    is_palindrome = result_string == result_string[::-1]\n    \n    # Step 3: Return the tuple\n    return (result_string, is_palindrome)"}
{"task_id": "HumanEval/113", "completion": "def odd_count(lst):\n    output = []\n    for s in lst:\n        # Count the number of odd digits in the current string\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        # Construct the output string, replacing 'i' with the odd_count\n        output_string = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        output.append(output_string)\n    return output"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    # Initialize current_min to the first element\n    # and global_min to also the first element\n    current_min = global_min = nums[0]\n    \n    # Iterate through the array starting from the second element\n    for num in nums[1:]:\n        # Update current_min either by adding the current number to the current_min\n        # or just the current number itself, whichever is smaller\n        current_min = min(num, current_min + num)\n        \n        # Update global_min if the current_min is smaller than the global_min\n        global_min = min(global_min, current_min)\n    \n    return global_min"}
{"task_id": "HumanEval/115", "completion": "def max_fill(grid, capacity):\n    # Calculate the total amount of water in all wells\n    total_water = sum(row.count(1) for row in grid)\n    \n    # Calculate the number of times buckets need to be lowered\n    # Use ceil to round up in case there's any remainder\n    bucket_lowers = -(-total_water // capacity)  # Equivalent to math.ceil(total_water / capacity)\n    \n    return bucket_lowers"}
{"task_id": "HumanEval/116", "completion": "def sort_array(arr):\n    # Sort the array using a custom key\n    # The key is a tuple where the first element is the number of ones in the binary representation\n    # and the second element is the number itself.\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))"}
{"task_id": "HumanEval/117", "completion": "def select_words(s, n):\n    # Define a list to hold the words that match the criteria\n    matching_words = []\n    \n    # Split the input string into words\n    words = s.split()\n    \n    # Define a set of consonants for easy checking\n    consonants = set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Count the consonants in the current word\n        consonant_count = sum(1 for char in word if char in consonants)\n        \n        # If the count matches n, add the word to the list\n        if consonant_count == n:\n            matching_words.append(word)\n    \n    # Return the list of matching words\n    return matching_words"}
{"task_id": "HumanEval/118", "completion": "def get_closest_vowel(word):\n    vowels = \"aeiouAEIOU\"\n    # Start iterating from the second last character to the second character\n    for i in range(len(word) - 2, 0, -1):\n        # Check if the current character is a vowel and it's surrounded by consonants\n        if word[i] in vowels and word[i-1] not in vowels and word[i+1] not in vowels:\n            return word[i]\n    # Return an empty string if no such vowel is found\n    return \"\""}
{"task_id": "HumanEval/119", "completion": "def match_parens(lst):\n    # Count the number of opening and closing parentheses in each string\n    counts = [(s.count('('), s.count(')')) for s in lst]\n    \n    # Check if the total number of opening and closing parentheses matches\n    total_open = counts[0][0] + counts[1][0]\n    total_close = counts[0][1] + counts[1][1]\n    if total_open != total_close:\n        return 'No'\n    \n    # If one string has excess opening and the other has excess closing parentheses,\n    # check if the string with excess closing parentheses does not start with more\n    # closing parentheses than opening ones from its pair\n    for i in range(2):\n        open1, close1 = counts[i]\n        open2, close2 = counts[1 - i]\n        if open1 < close1 and open2 > close2:\n            # Check if the excess of closing parentheses in the first string\n            # does not exceed the excess of opening parentheses in the second string\n            # at any point when concatenated in the order where the second string comes first\n            if close1 - open1 > open2 - close2:\n                return 'No'\n    \n    # If none of the conditions for 'No' are met, return 'Yes'\n    return 'Yes'"}
{"task_id": "HumanEval/120", "completion": "def maximum(arr, k):\n    # Step 1: Sort the array\n    arr.sort()\n    \n    # Step 2: Slice the last k elements\n    result = arr[-k:]\n    \n    # Step 3: Return the result\n    return result"}
{"task_id": "HumanEval/121", "completion": "def solution(lst):\n    # Initialize sum of odd elements in even positions\n    sum_odd_even_pos = 0\n    \n    # Iterate through the list with index\n    for index, value in enumerate(lst):\n        # Check if the position is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            sum_odd_even_pos += value\n            \n    return sum_odd_even_pos"}
{"task_id": "HumanEval/122", "completion": "def add_elements(arr, k):\n    # Initialize the sum to 0\n    sum_of_elements = 0\n    \n    # Iterate through the first k elements of the array\n    for i in range(k):\n        # Check if the current element has at most two digits\n        if arr[i] >= -99 and arr[i] <= 99:\n            # Add the element to the sum\n            sum_of_elements += arr[i]\n    \n    # Return the final sum\n    return sum_of_elements"}
{"task_id": "HumanEval/123", "completion": "def get_odd_collatz(n):\n    odd_numbers = []  # Step 1: Initialize the list to store odd numbers.\n    \n    while n != 1:  # Step 2: Loop until n becomes 1.\n        if n % 2 == 1:  # Step 3: Check if n is odd.\n            odd_numbers.append(n)  # Add the odd number to the list.\n        # Step 4: Apply the Collatz rules.\n        n = n // 2 if n % 2 == 0 else 3 * n + 1\n    \n    odd_numbers.append(1)  # Don't forget to add 1, as it's also part of the sequence.\n    return sorted(odd_numbers)  # Step 6 and 7: Sort and return the list."}
{"task_id": "HumanEval/124", "completion": "def valid_date(date):\n    # Rule 1: Check if the date string is not empty\n    if not date:\n        return False\n    \n    # Split the date string by \"-\" and ensure it has exactly three parts\n    parts = date.split(\"-\")\n    if len(parts) != 3:\n        return False\n    \n    month, day, year = parts\n    \n    # Check if month, day, and year are digits\n    if not (month.isdigit() and day.isdigit() and year.isdigit()):\n        return False\n    \n    # Convert month, day, and year to integers\n    month = int(month)\n    day = int(day)\n    year = int(year)  # Year is not used for validation in this case, but conversion is done for completeness\n    \n    # Rule 3: Validate the month\n    if month < 1 or month > 12:\n        return False\n    \n    # Rule 2: Validate the number of days according to the month\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:  # February\n        if day < 1 or day > 29:\n            return False\n    \n    # If all checks pass, the date is valid\n    return True"}
{"task_id": "HumanEval/125", "completion": "def split_words(txt):\n    # Check for whitespace and split if present\n    if ' ' in txt:\n        return txt.split()\n    \n    # Check for commas and split if present\n    elif ',' in txt:\n        return txt.split(',')\n    \n    # If no whitespaces or commas, count lowercase letters with odd order\n    else:\n        count = 0\n        for char in txt:\n            if char.islower():  # Check if the character is a lowercase letter\n                # Calculate the order and check if it's odd\n                # Subtracting ord('a') from ord(char) gives a 0-based index for the alphabet\n                if (ord(char) - ord('a')) % 2 == 1:\n                    count += 1\n        return count"}
{"task_id": "HumanEval/126", "completion": "def is_sorted(lst):\n    # Check if the list is sorted in ascending order\n    if lst != sorted(lst):\n        return False\n    \n    # Check for more than 1 duplicate of the same number\n    for num in set(lst):\n        if lst.count(num) > 1:\n            return False\n    \n    return True"}
{"task_id": "HumanEval/127", "completion": "def intersection(interval1, interval2):\n    # Find the maximum of the start points and the minimum of the end points\n    # to determine the intersection.\n    start_max = max(interval1[0], interval2[0])\n    end_min = min(interval1[1], interval2[1])\n    \n    # If the intersection exists, calculate its length.\n    if start_max <= end_min:\n        length = end_min - start_max + 1  # +1 because the intervals are closed.\n        # Check if the length is a prime number.\n        if is_prime(length):\n            return \"YES\"\n    return \"NO\""}
{"task_id": "HumanEval/128", "completion": "def prod_signs(arr):\n    if not arr:  # Check if the array is empty\n        return None\n    \n    sign_product = 1  # Initialize the product of signs\n    magnitude_sum = 0  # Initialize the sum of magnitudes\n    \n    for num in arr:\n        if num > 0:\n            magnitude_sum += abs(num)  # Add the magnitude of the number\n        elif num < 0:\n            sign_product *= -1  # Flip the sign of the product\n            magnitude_sum += abs(num)  # Add the magnitude of the number\n        else:  # If the number is 0\n            sign_product = 0  # Set the product of signs to 0\n            break  # No need to continue as the result is determined\n    \n    return magnitude_sum * sign_product"}
{"task_id": "HumanEval/129", "completion": "def minPath(grid, k):\n    N = len(grid)  # Assuming the grid is square\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up\n    best_path = [float('inf')] * k  # Initialize with infinity\n\n    def dfs(x, y, path, steps):\n        if steps == k:\n            nonlocal best_path\n            if path < best_path:\n                best_path = path.copy()\n            return\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:  # Check boundaries\n                path.append(grid[nx][ny])\n                dfs(nx, ny, path, steps + 1)\n                path.pop()  # Backtrack\n\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]], 1)\n\n    return best_path"}
{"task_id": "HumanEval/130", "completion": "def tri(n):\n    # Initialize the list with the first value as per the given definition\n    tribonacci = [3]\n    \n    # Handle the case when n is 0\n    if n == 0:\n        return tribonacci\n    \n    # Calculate the next values based on the given conditions\n    for i in range(1, n + 1):\n        if i % 2 == 0:  # If i is even\n            tribonacci.append(1 + i / 2)\n        else:  # If i is odd\n            # Ensure we have enough previous values to calculate the next one\n            if i + 1 > len(tribonacci):\n                # Calculate the next value in advance for odd i\n                next_val = 1 + (i + 1) / 2\n                tribonacci.append(tribonacci[i - 1] + tribonacci[i - 2] + next_val)\n            else:\n                tribonacci.append(tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i + 1])\n    \n    return tribonacci"}
{"task_id": "HumanEval/131", "completion": "def digits(n):\n    product = 1\n    has_odd = False  # This flag will help us determine if there's at least one odd digit\n    \n    for digit in str(n):\n        if int(digit) % 2 != 0:  # Check if the digit is odd\n            product *= int(digit)\n            has_odd = True\n    \n    if not has_odd:  # If there are no odd digits, return 0\n        return 0\n    else:\n        return product"}
{"task_id": "HumanEval/132", "completion": "def is_nested(string):\n    # Initialize an empty stack\n    stack = []\n    \n    # Iterate through each character in the string\n    for char in string:\n        # If it's an opening bracket, push it onto the stack\n        if char == '[':\n            stack.append(char)\n        # If it's a closing bracket\n        elif char == ']':\n            # Check if the stack is not empty and the top is an opening bracket\n            if stack:\n                # Pop the opening bracket from the stack\n                stack.pop()\n                # If the stack is not empty after popping, it means there is a nested bracket\n                if stack:\n                    return True\n            else:\n                # If the stack is empty, it means there's no matching opening bracket\n                # This is an invalid sequence, but per the problem statement, we don't need to handle this\n                pass\n    \n    # If we finish iterating through the string without finding a nested bracket, return False\n    return False"}
{"task_id": "HumanEval/133", "completion": "def sum_squares(lst):\n    # Sum the squares of the ceiling values of the elements in the list\n    return sum(math.ceil(x)**2 for x in lst)"}
{"task_id": "HumanEval/134", "completion": "def check_if_last_char_is_a_letter(txt):\n    # First, we trim any trailing spaces to ensure we're checking the actual last character of the text\n    txt = txt.rstrip()\n    \n    # Check if the string is empty after removing trailing spaces\n    if not txt:\n        return False\n    \n    # Check if the last character is an alphabetical character\n    if txt[-1].isalpha():\n        # If there's only one character in the string and it's alphabetical, it's not part of a word\n        if len(txt) == 1:\n            return True\n        # If the character before the last is not alphabetical, then the last character is not part of a word\n        elif not txt[-2].isalpha():\n            return True\n        else:\n            return False\n    else:\n        return False"}
{"task_id": "HumanEval/135", "completion": "def can_arrange(arr):\n    # Initialize the largest index to -1, assuming no such element is found initially\n    largest_index = -1\n    \n    # Start iterating from the second element (index 1) to the end of the array\n    for i in range(1, len(arr)):\n        # Check if the current element is not greater than or equal to the one before it\n        if arr[i] < arr[i - 1]:\n            # Update the largest index found so far\n            largest_index = i\n    \n    # Return the largest index found, or -1 if no such element exists\n    return largest_index"}
{"task_id": "HumanEval/136", "completion": "def largest_smallest_integers(lst):\n    # Initialize variables to store the largest negative and smallest positive integers\n    largest_negative = None\n    smallest_positive = None\n\n    for num in lst:\n        # Check if the current number is negative\n        if num < 0:\n            # If it's the first negative number found or larger than the current largest, update largest_negative\n            if largest_negative is None or num > largest_negative:\n                largest_negative = num\n        # Check if the current number is positive\n        elif num > 0:\n            # If it's the first positive number found or smaller than the current smallest, update smallest_positive\n            if smallest_positive is None or num < smallest_positive:\n                smallest_positive = num\n\n    return (largest_negative, smallest_positive)"}
{"task_id": "HumanEval/137", "completion": "def compare_one(a, b):\n    # Function to convert input to float, handling both dot and comma as decimal separators\n    def to_float(value):\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n        return float(value)\n    \n    # Convert both inputs to floats for comparison\n    float_a = to_float(a)\n    float_b = to_float(b)\n    \n    # Compare the float representations\n    if float_a > float_b:\n        return a\n    elif float_b > float_a:\n        return b\n    else:\n        # If they are equal, return None\n        return None"}
{"task_id": "HumanEval/138", "completion": "def is_equal_to_sum_even(n):\n    # Check if n is even and greater than or equal to 8\n    if n >= 8 and n % 2 == 0:\n        return True\n    else:\n        return False"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    \"\"\"Calculate the Brazilian factorial of n.\"\"\"\n    result = 1\n    for i in range(1, n + 1):\n        result *= factorial(i)\n    return result"}
{"task_id": "HumanEval/140", "completion": "def fix_spaces(text):\n    # Replace more than two consecutive spaces with a hyphen\n    text = re.sub(r' {3,}', '-', text)\n    # Replace remaining spaces (now, none are consecutive) with underscores\n    text = text.replace(' ', '_')\n    return text"}
{"task_id": "HumanEval/141", "completion": "def file_name_check(file_name):\n    # Check if the file name contains exactly one dot\n    if file_name.count('.') != 1:\n        return 'No'\n    \n    # Split the file name by the dot\n    name_part, extension_part = file_name.split('.')\n    \n    # Check if the substring before the dot is not empty and starts with a letter\n    if not name_part or not name_part[0].isalpha():\n        return 'No'\n    \n    # Check if there are more than three digits in the name part\n    digit_count = sum(c.isdigit() for c in name_part)\n    if digit_count > 3:\n        return 'No'\n    \n    # Check if the extension is one of the allowed ones\n    if extension_part not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    # If all checks passed, return 'Yes'\n    return 'Yes'"}
{"task_id": "HumanEval/142", "completion": "def sum_squares(lst):\n    total = 0\n    for i, num in enumerate(lst):\n        # Check if the index is a multiple of 3\n        if (i % 3) == 0:\n            total += num ** 2\n        # Check if the index is a multiple of 4 but not a multiple of 3\n        elif (i % 4) == 0:\n            total += num ** 3\n        # If the index is not a multiple of 3 or 4, add the number as it is\n        else:\n            total += num\n    return total"}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words whose lengths are prime numbers\n    prime_length_words = [word for word in words if is_prime(len(word))]\n    \n    # Join the filtered words back into a string\n    return ' '.join(prime_length_words)"}
{"task_id": "HumanEval/144", "completion": "def simplify(x, n):\n    # Parse the fractions\n    x_numerator, x_denominator = map(int, x.split('/'))\n    n_numerator, n_denominator = map(int, n.split('/'))\n    \n    # Multiply the fractions\n    result_numerator = x_numerator * n_numerator\n    result_denominator = x_denominator * n_denominator\n    \n    # Check if the result is a whole number\n    return result_numerator % result_denominator == 0"}
{"task_id": "HumanEval/145", "completion": "def order_by_points(nums):\n    # Define a helper function to calculate the sum of digits of a number\n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(abs(n)))\n    \n    # Sort the list based on the sum of digits. Use the index as a secondary sort key to maintain original order in case of ties.\n    sorted_nums = sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))\n    \n    return sorted_nums"}
{"task_id": "HumanEval/146", "completion": "def specialFilter(nums):\n    # Function to check if both the first and last digits of a number are odd\n    def is_first_last_odd(n):\n        # Convert number to positive to simplify checking digits\n        n = abs(n)\n        # Convert number to string to easily access first and last digits\n        str_n = str(n)\n        # Check if first and last digits are odd\n        return int(str_n[0]) % 2 != 0 and int(str_n[-1]) % 2 != 0\n    \n    # Initialize a counter for numbers that meet the criteria\n    count = 0\n    \n    # Iterate through each number in the list\n    for num in nums:\n        # Check if the number is greater than 10 and both first and last digits are odd\n        if num > 10 and is_first_last_odd(num):\n            # Increment the counter if the number meets the criteria\n            count += 1\n    \n    # Return the count of numbers that meet the criteria\n    return count"}
{"task_id": "HumanEval/147", "completion": "def get_max_triples(n):\n    # Step 1: Generate the array a\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    \n    # Step 2: Count the elements congruent to 0, 1, and 2 modulo 3\n    count_mod = [0, 0, 0]\n    for num in a:\n        count_mod[num % 3] += 1\n    \n    # Step 3: Calculate the number of valid triples\n    # Case 1: All three numbers are congruent to 0 modulo 3\n    triples_0 = count_mod[0] * (count_mod[0] - 1) * (count_mod[0] - 2) / 6\n    # Case 2: One number from each congruence class modulo 3 (0, 1, and 2)\n    triples_1_2_0 = count_mod[0] * count_mod[1] * count_mod[2]\n    \n    # Total valid triples\n    total_triples = triples_0 + triples_1_2_0\n    \n    return total_triples"}
{"task_id": "HumanEval/148", "completion": "def bf(planet1, planet2):\n    # List of planets ordered by their proximity to the Sun\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    # Check if both planet names are valid\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    \n    # Get the indexes of the planets\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    \n    # Ensure index1 is less than index2 for correct slicing\n    if index1 > index2:\n        index1, index2 = index2, index1\n    \n    # Return the tuple of planets between the two given planets, excluding the given planets themselves\n    return tuple(planets[index1 + 1:index2])"}
{"task_id": "HumanEval/149", "completion": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first alphabetically, then by length\n    even_length_strings.sort()  # This ensures that if two words have the same length, they are sorted alphabetically.\n    even_length_strings.sort(key=len)  # This sorts the words by their length.\n    \n    return even_length_strings"}
{"task_id": "HumanEval/150", "completion": "def x_or_y(n, x, y):\n    \"\"\"Return x if n is prime, otherwise return y.\"\"\"\n    return x if is_prime(n) else y"}
{"task_id": "HumanEval/151", "completion": "def sum_of_squares_of_odds(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    Examples:\n    sum_of_squares_of_odds([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    sum_of_squares_of_odds([-1, -2, 0]) == 0\n    sum_of_squares_of_odds([9, -2]) == 81\n    sum_of_squares_of_odds([0]) == 0  \n    \n    If the input list is empty, return 0.\n    '''\n    return sum(x**2 for x in lst if isinstance(x, int) and x > 0 and x % 2 == 1)"}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate through both lists simultaneously\n    for game_score, guess_score in zip(game, guess):\n        # Calculate the absolute difference if the scores are not the same\n        # If they are the same, the difference is 0\n        difference = abs(game_score - guess_score)\n        \n        # Append the difference to the result list\n        result.append(difference)\n    \n    # Return the result list\n    return result"}
{"task_id": "HumanEval/153", "completion": "def Strongest_Extension(class_name, extensions):\n    # Initialize variables to keep track of the strongest extension and its strength\n    strongest_extension = None\n    highest_strength = float('-inf')  # Start with the lowest possible value\n\n    # Iterate through each extension\n    for extension in extensions:\n        # Calculate the strength of the extension\n        CAP = sum(1 for char in extension if char.isupper())\n        SM = sum(1 for char in extension if char.islower())\n        strength = CAP - SM\n\n        # Update the strongest extension if this one is stronger\n        if strength > highest_strength:\n            strongest_extension = extension\n            highest_strength = strength\n\n    # Return the class name concatenated with the strongest extension\n    return f'{class_name}.{strongest_extension}'"}
{"task_id": "HumanEval/154", "completion": "def cycpattern_check(a, b):\n    # Concatenate the first word with itself\n    a_doubled = a + a\n    \n    # Check if the second word is a substring of the concatenated first word\n    return b in a_doubled"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    # Step 1: Convert to absolute value to handle negative numbers\n    num = abs(num)\n    \n    # Step 2: Convert the number to a string\n    num_str = str(num)\n    \n    # Step 3: Initialize counters\n    even_count = 0\n    odd_count = 0\n    \n    # Step 4: Iterate through each digit\n    for digit in num_str:\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Step 5: Return the counts as a tuple\n    return (even_count, odd_count)"}
{"task_id": "HumanEval/156", "completion": "def int_to_mini_roman(number):\n    # Define the Roman numeral symbols and their corresponding values\n    value_symbols = [\n        (1000, 'm'), (900, 'cm'), (500, 'd'), (400, 'cd'),\n        (100, 'c'), (90, 'xc'), (50, 'l'), (40, 'xl'),\n        (10, 'x'), (9, 'ix'), (5, 'v'), (4, 'iv'), (1, 'i')\n    ]\n    \n    roman_numeral = ''\n    \n    # Iterate through each symbol, subtracting it from the number\n    # and adding the symbol to the result string\n    for value, symbol in value_symbols:\n        while number >= value:\n            number -= value\n            roman_numeral += symbol\n    \n    return roman_numeral"}
{"task_id": "HumanEval/157", "completion": "def right_angle_triangle(a, b, c):\n    # Sort the sides to ensure c is the longest side (hypotenuse)\n    a, b, c = sorted([a, b, c])\n    \n    # Check if the triangle is right-angled using the Pythagorean theorem\n    return c**2 == a**2 + b**2"}
{"task_id": "HumanEval/158", "completion": "def find_max(words):\n    \"\"\"Write a function that accepts a list of strings.\n    The list contains different words. Return the word with maximum number\n    of unique characters. If multiple strings have maximum number of unique\n    characters, return the one which comes first in lexicographical order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"aaaaaaa\"\n    \"\"\"\n    # Initialize a variable to keep track of the word with the maximum number of unique characters\n    max_word = \"\"\n    # Initialize a variable to keep track of the maximum number of unique characters found so far\n    max_unique_chars = 0\n\n    for word in words:\n        # Use set to find the unique characters in the word\n        unique_chars = len(set(word))\n        # Check if this word has more unique characters than the current maximum\n        if unique_chars > max_unique_chars:\n            max_word = word\n            max_unique_chars = unique_chars\n        # If the number of unique characters is the same, check lexicographical order\n        elif unique_chars == max_unique_chars and word < max_word:\n            max_word = word\n\n    return max_word"}
{"task_id": "HumanEval/159", "completion": "def eat(number, need, remaining):\n    # Calculate how many more carrots the rabbit needs to eat to be satisfied\n    more_needed = need - remaining\n    \n    # If the rabbit needs more carrots than are remaining, it eats all the remaining carrots\n    if more_needed > 0:\n        total_eaten = number + remaining\n        remaining_carrots = 0\n    else:\n        # If the remaining carrots are enough or more than needed, the rabbit eats only what it needs\n        total_eaten = number + need\n        remaining_carrots = remaining - need\n    \n    return [total_eaten, remaining_carrots]"}
{"task_id": "HumanEval/160", "completion": "def do_algebra(operators, operands):\n    # Start the expression with the first operand\n    expression = str(operands[0])\n    \n    # Iterate through the operators and operands (starting from the second operand)\n    for op, val in zip(operators, operands[1:]):\n        # Append the operator and operand to the expression\n        expression += f\" {op} {val}\"\n    \n    # Evaluate the expression and return the result\n    return eval(expression)"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    # Check if the string contains any letters\n    if not any(c.isalpha() for c in s):\n        # If no letters are found, return the reversed string\n        return s[::-1]\n    \n    # If the string contains letters, create a new string with reversed cases for letters\n    result = ''\n    for char in s:\n        if char.isalpha():\n            # Reverse the case for letters\n            if char.islower():\n                result += char.upper()\n            else:\n                result += char.lower()\n        else:\n            # Keep non-letter characters as they are\n            result += char\n    \n    return result"}
{"task_id": "HumanEval/162", "completion": "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n    if text == \"\":\n        return None\n    else:\n        # Encode the text to bytes, compute its md5 hash, and return the hexadecimal representation\n        return hashlib.md5(text.encode()).hexdigest()"}
{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    # Ensure a is less than b for the loop to work correctly\n    if a > b:\n        a, b = b, a\n    \n    # Initialize an empty list to store the even numbers\n    even_numbers = []\n    \n    # Adjust a to be the next even number if it's odd\n    if a % 2 != 0:\n        a += 1\n    \n    # Loop from a to b (inclusive) and add even numbers to the list\n    for number in range(a, b + 1, 2):\n        even_numbers.append(number)\n    \n    return even_numbers"}
