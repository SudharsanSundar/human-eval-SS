{"task_id": 11, "completion": "def remove_Occ(s, ch):\n    # Find the first occurrence of the character\n    first_occurrence = s.find(ch)\n    if first_occurrence != -1:\n        # Remove the first occurrence\n        s = s[:first_occurrence] + s[first_occurrence+1:]\n    else:\n        # If the character is not found, return the original string\n        return s\n    \n    # Find the last occurrence of the character\n    last_occurrence = s.rfind(ch)\n    if last_occurrence != -1:\n        # Remove the last occurrence\n        s = s[:last_occurrence] + s[last_occurrence+1:]\n    \n    return s"}
{"task_id": 12, "completion": "def sort_matrix(M):\n    # Calculate the sum of each row and pair it with the row\n    row_sums_with_rows = [(sum(row), row) for row in M]\n    \n    # Sort the pairs based on the sum\n    sorted_pairs = sorted(row_sums_with_rows, key=lambda x: x[0])\n    \n    # Extract the sorted rows\n    sorted_rows = [row for _, row in sorted_pairs]\n    \n    return sorted_rows"}
{"task_id": 13, "completion": "def count_common(words):\n    # Count the occurrences of each word\n    word_counts = Counter(words)\n    \n    # Find the highest frequency\n    max_count = max(word_counts.values())\n    \n    # Find all words that have the highest frequency\n    most_common_words = [word for word, count in word_counts.items() if count == max_count]\n    \n    # Return the most common words and their counts\n    return most_common_words, max_count"}
{"task_id": 14, "completion": "def find_Volume(b, h, l):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    b (float): The base of the triangular base.\n    h (float): The height of the triangular base.\n    l (float): The length (height) of the prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    # Calculate the area of the triangular base\n    area_of_triangle = 0.5 * b * h\n    \n    # Calculate the volume of the prism\n    volume = area_of_triangle * l\n    \n    return volume"}
{"task_id": 15, "completion": "def split_lowerstring(text):\n    parts = filter(None, re.split('([a-z]+)', text))\n    return list(parts)"}
{"task_id": 16, "completion": "import re\n\ndef text_lowercase_underscore(text):\n    # Define the regex pattern for sequences of lowercase letters joined with an underscore\n    pattern = r'([a-z]+_)+[a-z]+'\n    \n    # Find all matches in the text\n    matches = re.findall(pattern, text)\n    \n    return matches"}
{"task_id": 17, "completion": "def square_perimeter(a):\n    \"\"\"\n    Calculate the perimeter of a square.\n\n    Parameters:\n    a (float): The length of one side of the square.\n\n    Returns:\n    float: The perimeter of the square.\n    \"\"\"\n    return 4 * a"}
{"task_id": 18, "completion": "def str_to_list(string1, string2):\n    # Create a set of characters present in the second string for faster lookup\n    chars_to_remove = set(string2)\n    \n    # Use a list comprehension to filter out characters present in chars_to_remove\n    filtered_string = [char for char in string1 if char not in chars_to_remove]\n    \n    # Join the list back into a string\n    result_string = ''.join(filtered_string)\n    \n    return result_string"}
{"task_id": 19, "completion": "def test_duplicate(arraynums):\n    # Using a set to track seen numbers\n    seen = set()\n    for num in arraynums:\n        # If the number is already in the set, we found a duplicate\n        if num in seen:\n            return True\n        seen.add(num)\n    # If we reach here, no duplicates were found\n    return False"}
{"task_id": 20, "completion": "def is_woodall(x):\n    n = 1\n    while True:\n        woodall_n = n * 2**n - 1\n        if woodall_n == x:\n            return True\n        elif woodall_n > x:\n            return False\n        n += 1"}
{"task_id": 21, "completion": "def multiples_of_num(m, n):\n    # Initialize an empty list to store the multiples\n    multiples = []\n    \n    # Loop to find and append the first m multiples of n\n    for i in range(1, m+1):\n        multiples.append(n * i)\n    \n    return multiples"}
{"task_id": 22, "completion": "def find_first_duplicate(nums):\n    # Create an empty set to keep track of visited elements\n    seen = set()\n    \n    # Iterate through each element in the list\n    for num in nums:\n        # If the element is already in the set, it's a duplicate\n        if num in seen:\n            return num\n        # Otherwise, add the element to the set\n        seen.add(num)\n    \n    # If no duplicates were found, return -1\n    return -1"}
{"task_id": 23, "completion": "def maximum_Sum(list_of_lists):\n    max_sum = float('-inf') if not list_of_lists else sum(list_of_lists[0])\n    \n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum"}
{"task_id": 24, "completion": "def binary_to_decimal(binary):\n    # Initialize the decimal number to 0\n    decimal = 0\n    \n    # Iterate over each digit in the binary string\n    for digit in binary:\n        # Multiply the current decimal by 2 and add the binary digit\n        decimal = decimal * 2 + int(digit)\n    \n    return decimal"}
{"task_id": 25, "completion": "def find_Product(arr, n):\n    # Step 1: Count the occurrence of each element\n    element_count = {}\n    for element in arr:\n        if element in element_count:\n            element_count[element] += 1\n        else:\n            element_count[element] = 1\n    \n    # Step 2: Find the product of non-repeated elements\n    product = 1\n    for element, count in element_count.items():\n        if count == 1:  # If the element is non-repeated\n            product *= element\n    \n    # If product is still 1, it means there were no non-repeated elements\n    if product == 1 and 1 not in element_count.values():\n        return \"No non-repeated elements found\"\n    else:\n        return product"}
{"task_id": 26, "completion": "def check_k_elements(test_list, K):\n    # Iterate through each tuple in the list\n    for tup in test_list:\n        # Check if the length of the current tuple is not equal to K\n        if len(tup) != K:\n            # If any tuple doesn't have K elements, return False\n            return False\n    # If all tuples have K elements, return True\n    return True"}
{"task_id": 27, "completion": "def remove_digits_from_strings(string_list):\n    return [''.join(char for char in s if not char.isdigit()) for s in string_list]"}
{"task_id": 28, "completion": "def binomial_coeff(n, k):\n    \"\"\"Function to calculate binomial coefficient\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return factorial(n) // (factorial(k) * factorial(n - k))"}
{"task_id": 29, "completion": "def get_Odd_Occurrence(arr, arr_size):\n    result = 0\n    for element in arr:\n        result = result ^ element\n    return result"}
{"task_id": 30, "completion": "def check_Equality(s):\n    # Dictionary to store the count of each character\n    char_count = {}\n    \n    # Count occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Count substrings starting and ending with the same character\n    substr_count = 0\n    for count in char_count.values():\n        # For each character, add the number of substrings that can be formed\n        # The formula is n * (n + 1) / 2, where n is the count of the character\n        # This includes the character itself as a substring and combinations of longer substrings\n        substr_count += count * (count + 1) // 2\n    \n    return substr_count\n`"}
{"task_id": 31, "completion": "def func(nums, k):\n    # Step 1: Merge the lists and count the frequency of each integer\n    # Since the lists are sorted and distinct, we can use chain from itertools to merge them efficiently\n    # Counter will count the frequency of each integer\n    frequency = Counter(chain(*nums))\n    \n    # Step 2: Use a min heap to find the top k frequent integers\n    # The heap will contain pairs of (-frequency, integer) because heapq in Python is a min heap,\n    # but we want to prioritize larger frequencies, hence the negative sign\n    min_heap = []\n    for num, freq in frequency.items():\n        heapq.heappush(min_heap, (-freq, num))\n        # If the heap size exceeds k, remove the smallest element (which is the least frequent so far)\n        if len(min_heap) > k:\n            heapq.heappop(min_heap)\n    \n    # Step 3: Extract the top k elements from the heap\n    # Since we used -frequency, the most frequent elements are at the top of the heap\n    # We extract them and return their values (ignoring the negative frequencies)\n    top_k_frequent = [heapq.heappop(min_heap)[1] for _ in range(len(min_heap))]\n    \n    # The elements are popped in reverse order, so reverse the result to get the correct order\n    return top_k_frequent[::-1]\n`"}
{"task_id": 32, "completion": "def max_Prime_Factors(n):\n    # Initialize the maximum prime factor variable\n    maxPrime = -1\n    \n    # Remove all the 2s from n, if present\n    while n % 2 == 0:\n        maxPrime = 2\n        n //= 2\n    \n    # n must be odd at this point, so we can skip one element (Note i = i + 2)\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, remove i and update maxPrime\n        while n % i == 0:\n            maxPrime = i\n            n //= i\n    \n    # This condition is to handle the case when n is a prime number greater than 2\n    if n > 2:\n        maxPrime = n\n    \n    return maxPrime"}
{"task_id": 33, "completion": "def decimal_to_binary(N):\n    # If the number is 0, its binary representation is also 0.\n    if N == 0:\n        return \"0\"\n    \n    binary_number = \"\"\n    while N > 0:\n        remainder = N % 2\n        binary_number = str(remainder) + binary_number\n        N = N // 2\n    \n    return binary_number"}
{"task_id": 34, "completion": "def find_missing(ar, N):\n    # Start and end pointers\n    start, end = 0, N - 1\n    \n    # Binary search\n    while start <= end:\n        mid = (start + end) // 2\n        \n        # Check if the missing element is in the left half\n        if ar[mid] != mid + 1 and (mid == 0 or ar[mid-1] == mid):\n            return mid + 1\n        \n        # If the element at mid is equal to its index + 1, the missing element is in the right half\n        if ar[mid] == mid + 1:\n            start = mid + 1\n        else:\n            end = mid - 1\n    \n    # If no element is missing in the given range\n    return None"}
{"task_id": 35, "completion": "def find_rect_num(n):\n    # Calculate the n-th rectangular number\n    return n * (n + 1)"}
{"task_id": 36, "completion": "def find_Nth_Digit(p, q, N):\n    # Ensure p < q for a proper fraction; if not, adjust p accordingly\n    if p >= q:\n        p = p % q\n    \n    # Initialize the remainder\n    remainder = p\n    \n    for _ in range(N):\n        # Multiply the remainder by 10\n        remainder *= 10\n        # Find the digit\n        digit = remainder // q\n        # Update the remainder\n        remainder = remainder % q\n    \n    return digit"}
{"task_id": 37, "completion": "def sort_mixed_list(mixed_list):\n    # Convert all items to strings and sort based on their string value\n    sorted_list = sorted(mixed_list, key=lambda x: str(x))\n    return sorted_list"}
{"task_id": 38, "completion": "def div_even_odd(list1):\n    # Initialize variables to store the first even and odd numbers\n    first_even = None\n    first_odd = None\n    \n    # Iterate through the list to find the first even and odd numbers\n    for num in list1:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        \n        # If both first even and odd numbers are found, break the loop\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # Check if both even and odd numbers were found\n    if first_even is not None and first_odd is not None:\n        # Perform the division and return the result\n        return first_even / first_odd\n    else:\n        # Return a message if the division cannot be performed\n        return \"Cannot perform division. List must contain at least one even and one odd number.\"\n`"}
{"task_id": 39, "completion": "def can_rearrange_string(s):\n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n    \n    # Create a max heap of characters based on their frequency\n    max_heap = [(-count, char) for char, count in char_count.items()]\n    heapq.heapify(max_heap)\n    \n    # String to store the result\n    result = \"\"\n    \n    # Variables to store the previous character and its count\n    prev_char = None\n    prev_count = 0\n    \n    while max_heap:\n        # Pop the most frequent character\n        count, char = heapq.heappop(max_heap)\n        # Append the character to the result\n        result += char\n        # Since we're using a max heap, the counts were negative to sort correctly. Reverse it back.\n        count += 1\n        \n        # If there's a previous character, push it back into the heap\n        if prev_char and prev_count < 0:\n            heapq.heappush(max_heap, (prev_count, prev_char))\n        \n        # Update the previous character and its count\n        prev_char = char\n        prev_count = count\n    \n    # Check if the rearranged string is valid\n    for i in range(1, len(result)):\n        if result[i] == result[i-1]:\n            return False\n    return True"}
{"task_id": 40, "completion": "from collections import Counter\n\ndef freq_element(nums):\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in nums for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    freq = Counter(flat_list)\n    \n    return freq"}
{"task_id": 41, "completion": "def filter_evennumbers(nums):\n    # Using filter function with a lambda to filter even numbers\n    return list(filter(lambda x: x % 2 == 0, nums))"}
{"task_id": 42, "completion": "def find_Sum(arr, n):\n    # Dictionary to store the count of each element\n    element_count = {}\n    \n    # Iterate through the array and count the occurrences\n    for element in arr:\n        if element in element_count:\n            element_count[element] += 1\n        else:\n            element_count[element] = 1\n    \n    # Sum up the values of elements that have occurred more than once\n    sum_repeated = 0\n    for element, count in element_count.items():\n        if count > 1:\n            sum_repeated += element * count\n    \n    return sum_repeated"}
{"task_id": 43, "completion": "def text_match(text):\n    pattern = r'[a-z]+(_[a-z]+)+'\n    matches = re.findall(pattern, text)\n    return matches"}
{"task_id": 44, "completion": "import re\n\ndef text_match_string(text, word):\n    \"\"\"\n    Matches a word at the beginning of a string.\n\n    Parameters:\n    text (str): The string to search in.\n    word (str): The word to match at the beginning of the string.\n\n    Returns:\n    bool: True if the word matches at the beginning of the string, False otherwise.\n    \"\"\"\n    # The pattern to match the word at the beginning of the string\n    # ^ asserts position at start of the string\n    # \\b asserts a word boundary\n    pattern = r'^\\b' + re.escape(word) + r'\\b'\n    \n    # Using re.match() to check if the pattern matches at the beginning of the string\n    if re.match(pattern, text):\n        return True\n    else:\n        return False\n`"}
{"task_id": 45, "completion": "def find_gcd(arr):\n    \"\"\"\n    Find the GCD of an array of numbers.\n    \"\"\"\n    if not arr:\n        return None  # Return None for empty array\n    array_gcd = arr[0]\n    for num in arr[1:]:\n        array_gcd = gcd(array_gcd, num)\n        if array_gcd == 1:  # Early termination if GCD becomes 1\n            break\n    return array_gcd"}
{"task_id": 46, "completion": "def test_distinct(data):\n    # Convert the list to a set, which automatically removes duplicates\n    data_set = set(data)\n    # Compare the length of the original list to the set\n    # If lengths are equal, all elements were distinct\n    return len(data) == len(data_set)"}
{"task_id": 47, "completion": "def compute_Last_Digit(A, B):\n    # Ensure B >= A\n    if B < A:\n        return \"Invalid input: B should be greater than or equal to A\"\n    \n    # If A and B are the same, the division is 1, so the last digit is 1\n    if A == B:\n        return 1\n    \n    # Initialize the last digit to 1 (since we're multiplying)\n    last_digit = 1\n    \n    # Loop through each number from A+1 to B\n    for i in range(A+1, B+1):\n        # Multiply the current last digit by the last digit of the current number\n        last_digit = (last_digit * (i % 10)) % 10\n        \n        # If the last digit becomes 0, the final result will also end in 0\n        if last_digit == 0:\n            break\n    \n    return last_digit"}
{"task_id": 48, "completion": "def odd_bit_set_number(n):\n    # Mask for a 32-bit number: 0xAAAAAAAA\n    # For a 64-bit number, use 0xAAAAAAAAAAAAAAAA\n    mask = 0xAAAAAAAA\n    # Set all odd bits of n\n    result = n | mask\n    return result"}
{"task_id": 49, "completion": "def specified_element(nums, N):\n    # Initialize an empty list to store the extracted elements\n    extracted_elements = []\n    \n    # Iterate through each sub-list in the two-dimensional list\n    for sublist in nums:\n        # Check if the sub-list is long enough to have an Nth element\n        if len(sublist) >= N:\n            # Append the Nth element of the sub-list to the extracted_elements list\n            # Note: Subtract 1 from N because list indices start at 0\n            extracted_elements.append(sublist[N-1])\n    \n    return extracted_elements"}
{"task_id": 50, "completion": "def min_length_list(input_list):\n    # Use the min function with a lambda function as the key to find the list with the minimum length\n    return min(input_list, key=lambda x: len(x))"}
{"task_id": 51, "completion": "def check_equilateral(x, y, z):\n    # Check if all sides are equal\n    if x == y == z:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")"}
{"task_id": 52, "completion": "def parallelogram_area(b, h):\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    b (float): The base of the parallelogram.\n    h (float): The height of the parallelogram.\n\n    Returns:\n    float: The area of the parallelogram.\n    \"\"\"\n    return b * h"}
{"task_id": 53, "completion": "def check_Equality(str):\n    # Check if the string is empty or has only one character\n    if not str or len(str) == 1:\n        return True  # An empty string or a single character means equality by default\n    else:\n        # Compare the first and last character\n        return str[0] == str[-1]"}
{"task_id": 54, "completion": "def counting_sort(my_list):\n    # Find the maximum element in the list\n    max_val = max(my_list)\n    # Initialize the count array with zeros\n    count_array = [0] * (max_val + 1)\n    \n    # Store the count of each element in count_array\n    for num in my_list:\n        count_array[num] += 1\n    \n    # Update the count_array to contain actual positions of elements in the output array\n    for i in range(1, len(count_array)):\n        count_array[i] += count_array[i - 1]\n    \n    # Initialize the output array\n    output_array = [0] * len(my_list)\n    \n    # Build the output array using the count_array\n    i = len(my_list) - 1\n    while i >= 0:\n        current_element = my_list[i]\n        count_array[current_element] -= 1\n        new_position = count_array[current_element]\n        output_array[new_position] = current_element\n        i -= 1\n    \n    # Copy the sorted elements into the original list\n    for i in range(len(my_list)):\n        my_list[i] = output_array[i]"}
{"task_id": 55, "completion": "def tn_gp(a, n, r):\n    \"\"\"\n    Calculate the n-th term of a geometric progression.\n\n    Parameters:\n    a (int or float): The first term of the geometric progression.\n    n (int): The term number to find.\n    r (int or float): The common ratio of the geometric progression.\n\n    Returns:\n    int or float: The n-th term of the geometric progression.\n    \"\"\"\n    return a * (r ** (n - 1))"}
{"task_id": 56, "completion": "def rev(num):\n    # Convert the number to a string to reverse it\n    num_str = str(num)\n    # Reverse the string and convert it back to an integer\n    reversed_num = int(num_str[::-1])\n    # Check if the original number is one less than twice the reversed number\n    return num == 2 * reversed_num - 1"}
{"task_id": 57, "completion": "def find_Max_Num(arr, n):\n    # Convert all numbers to string\n    for i in range(n):\n        arr[i] = str(arr[i])\n    \n    # Custom sort: compare numbers based on their potential concatenation\n    arr.sort(key=lambda x: x*10, reverse=True)\n    \n    # Concatenate sorted strings\n    largest_num = \"\".join(arr)\n    \n    # Handle case with leading zeros (e.g., when all elements are zero)\n    if largest_num[0] == '0':\n        return '0'\n    else:\n        return largest_num"}
{"task_id": 58, "completion": "def opposite_Signs(x, y):\n    # XOR of x and y will have the sign bit set if x and y have opposite signs\n    return (x ^ y) < 0"}
{"task_id": 59, "completion": "def is_octagonal(n):\n    # Calculate the nth octagonal number\n    octagonal_number = n * (3 * n - 2)\n    return octagonal_number"}
{"task_id": 60, "completion": "def max_len_sub(arr):\n    # Dictionary to store the frequency of each element in the array\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    \n    max_len = 0\n    for num in freq:\n        # Check the length of subsequence by considering the current element and the next element\n        max_len = max(max_len, freq[num] + freq.get(num + 1, 0))\n        # Also check the length of subsequence by considering the current element and the previous element\n        max_len = max(max_len, freq[num] + freq.get(num - 1, 0))\n    \n    return max_len\n`"}
{"task_id": 61, "completion": "def count_Substrings(s, n):\n    # Initialize a counter to keep track of substrings that meet the criteria\n    count = 0\n    \n    # Iterate through the string to get all possible substrings\n    for i in range(n):\n        for j in range(i, n):\n            # Extract the substring\n            substring = s[i:j+1]\n            # Calculate the sum of digits in the substring\n            sum_of_digits = sum(int(char) for char in substring if char.isdigit())\n            # Check if the sum of digits equals the length of the substring\n            if sum_of_digits == len(substring):\n                count += 1\n                \n    return count"}
{"task_id": 62, "completion": "def smallest_num(xs):\n    # Initialize the smallest number to the first element of the list\n    smallest = xs[0]\n    \n    # Iterate through the list starting from the second element\n    for num in xs[1:]:\n        # If the current number is smaller than the smallest found so far, update smallest\n        if num < smallest:\n            smallest = num\n            \n    return smallest"}
{"task_id": 63, "completion": "def max_difference(test_list):\n    # Initialize max_diff to a very small number\n    max_diff = float('-inf')\n    \n    # Iterate through each tuple in the list\n    for tup in test_list:\n        # Calculate the difference between the elements of the tuple\n        # Using abs to ensure the difference is positive\n        diff = abs(tup[0] - tup[1])\n        \n        # Update max_diff if the current difference is greater than max_diff\n        if diff > max_diff:\n            max_diff = diff\n            \n    return max_diff"}
{"task_id": 64, "completion": "def sort_subject_marks(subject_marks):\n    # Sorting the list of tuples based on marks\n    sorted_list = sorted(subject_marks, key=lambda x: x[1])\n    return sorted_list"}
{"task_id": 65, "completion": "def recursive_list_sum(data_list):\n    total = 0\n    for element in data_list:\n        if type(element) == list:\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total"}
{"task_id": 66, "completion": "def pos_count(numbers):\n    # Initialize a counter for positive numbers\n    positive_count = 0\n    \n    # Loop through each number in the list\n    for num in numbers:\n        # Check if the current number is positive\n        if num > 0:\n            # Increment the counter if the number is positive\n            positive_count += 1\n            \n    # Return the count of positive numbers\n    return positive_count"}
{"task_id": 67, "completion": "def bell_number(n):\n    \"\"\"\n    Calculate the n-th Bell number.\n    \n    Parameters:\n    n (int): The order of the Bell number to compute.\n    \n    Returns:\n    int: The n-th Bell number.\n    \"\"\"\n    # Base case: Bell number for 0 is 1\n    if n == 0:\n        return 1\n    \n    # Initialize a list to store Bell numbers\n    bell = [0] * (n + 1)\n    bell[0] = 1  # Bell number for 0\n    \n    # Fill the bell table based on the recursive relation\n    for i in range(1, n + 1):\n        # Explicit formula for calculating Bell numbers\n        bell[i] = bell[i - 1] * i\n        for j in range(i - 1, 0, -1):\n            bell[j] += bell[j - 1]\n    \n    # The n-th Bell number is the last computed value\n    return bell[n]"}
{"task_id": 68, "completion": "def is_monotonic(A):\n    # Check if the array is non-decreasing\n    non_decreasing = all(A[i] <= A[i + 1] for i in range(len(A) - 1))\n    # Check if the array is non-increasing\n    non_increasing = all(A[i] >= A[i + 1] for i in range(len(A) - 1))\n    \n    # The array is monotonic if it is either non-decreasing or non-increasing\n    return non_decreasing or non_increasing"}
{"task_id": 69, "completion": "def is_sublist(l, s):\n    # If s is empty, it's a sublist of any list\n    if not s:\n        return True\n    # If s is longer than l, it can't be a sublist\n    if len(s) > len(l):\n        return False\n    \n    # Check if s is a sublist of l\n    for i in range(len(l) - len(s) + 1):\n        if l[i:i+len(s)] == s:\n            return True\n    return False"}
{"task_id": 70, "completion": "def find_equal_tuple(Input, k):\n    # Iterate through each tuple in the Input list\n    for tup in Input:\n        # Check if the current tuple does not have length k\n        if len(tup) != k:\n            # If any tuple does not have length k, return False\n            return False\n    # If all tuples have length k, return True\n    return True"}
{"task_id": 71, "completion": "def comb_sort(nums):\n    # Initialize the gap size to the length of the list\n    gap = len(nums)\n    # Initialize the swapped variable to True to enter the while loop\n    swapped = True\n    # Start comb sort\n    while gap != 1 or swapped:\n        # Find the next gap size\n        gap = max(1, int(gap / 1.3))  # The shrink factor is usually 1.3\n        swapped = False\n        # Compare elements and swap if necessary\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n    return nums"}
{"task_id": 72, "completion": "def can_be_represented_as_diff_of_squares(n):\n    # Check if n is odd\n    if n % 2 == 1:\n        return True\n    # Check if n is a multiple of 4\n    elif n % 4 == 0:\n        return True\n    # If n is even and not a multiple of 4, it cannot be represented as the difference of two squares\n    else:\n        return False"}
{"task_id": 73, "completion": "def multiple_split(text, delimiters):\n    \"\"\"\n    Splits the given string using multiple delimiters.\n\n    Parameters:\n    - text (str): The string to be split.\n    - delimiters (list of str): A list of delimiter characters or strings.\n\n    Returns:\n    - list of str: The list of substrings obtained after splitting the text.\n    \"\"\"\n    # Create a regex pattern to match any of the delimiters\n    # We use re.escape to escape any special characters in the delimiters\n    pattern = '|'.join(map(re.escape, delimiters))\n\n    # Split the text using the compiled pattern\n    return re.split(pattern, text)"}
{"task_id": 74, "completion": "def is_samepatterns(colors, patterns):\n    # Function to check if a pattern is found in the colors list\n    def check_pattern(colors, pattern):\n        pattern_length = len(pattern)\n        for i in range(len(colors) - pattern_length + 1):\n            # Check if the current slice of colors matches the pattern\n            if colors[i:i+pattern_length] == pattern:\n                return True\n        return False\n    \n    # Check each pattern in the patterns list\n    for pattern in patterns:\n        if not check_pattern(colors, pattern):\n            return False\n    return True"}
{"task_id": 75, "completion": "def find_tuples(test_list, K):\n    # Filter tuples based on the condition that all elements are divisible by K\n    result = [tup for tup in test_list if all(element % K == 0 for element in tup)]\n    return result"}
{"task_id": 76, "completion": "def count_squares(m, n):\n    # Initialize count of squares\n    count = 0\n    \n    # Loop through each possible square size\n    for side in range(1, min(m, n) + 1):\n        # Count how many squares of this size fit in the rectangle\n        count += (m - side + 1) * (n - side + 1)\n    \n    return count"}
{"task_id": 77, "completion": "def is_Diff(n):\n    # Convert the number to a string to easily iterate over each digit\n    n_str = str(n)\n    \n    # Initialize sums for even and odd digits\n    sum_even = 0\n    sum_odd = 0\n    \n    # Iterate over each character in the string (each digit of the number)\n    for digit in n_str:\n        # Convert the character back to an integer\n        digit = int(digit)\n        \n        # Check if the digit is even\n        if digit % 2 == 0:\n            sum_even += digit\n        else:\n            # If it's not even, it's odd\n            sum_odd += digit\n    \n    # Calculate the difference between the sum of even and odd digits\n    difference = sum_even - sum_odd\n    \n    return difference"}
{"task_id": 78, "completion": "def count_With_Odd_SetBits(n):\n    # Main function to count numbers with odd set bits up to n\n    odd_count = 0\n    for i in range(n + 1):\n        if countBits(i) % 2 != 0:\n            odd_count += 1\n    return odd_count"}
{"task_id": 79, "completion": "def word_len(s):\n    # Check if the length of the word is odd\n    if len(s) % 2 == 1:\n        return True\n    else:\n        return False"}
{"task_id": 80, "completion": "def tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6"}
{"task_id": 81, "completion": "def zip_tuples(test_tup1, test_tup2):\n    # Using the zip function to pair elements from both tuples\n    # and converting the result to a list of tuples\n    result = list(zip(test_tup1, test_tup2))\n    return result"}
{"task_id": 82, "completion": "def volume_sphere(r):\n    return (4/3) * math.pi * (r**3)"}
{"task_id": 83, "completion": "def get_Char(strr):\n    # Calculate the sum of ASCII values of all characters in the string\n    total = sum(ord(char) for char in strr)\n    \n    # Convert the total sum back to a character. \n    # Note: The result might not be a printable character and could exceed the standard ASCII range.\n    result_char = chr(total % 256)  # Using modulo 256 to ensure the result is within the ASCII range\n    \n    return result_char"}
{"task_id": 84, "completion": "def newman_conway(n):\n    # Base cases\n    if n == 1 or n == 2:\n        return 1\n    \n    # Initialize the sequence with base cases\n    sequence = [0, 1, 1]\n    \n    # Fill the sequence up to n\n    for i in range(3, n + 1):\n        sequence.append(sequence[sequence[i - 1]] + sequence[i - sequence[i - 1]])\n    \n    # Return the n-th element\n    return sequence[n]"}
{"task_id": 85, "completion": "def surfacearea_sphere(r):\n    # Calculate the surface area using the formula\n    surface_area = 4 * math.pi * (r ** 2)\n    return surface_area"}
{"task_id": 86, "completion": "def centered_hexagonal_number(n):\n    return 3 * n * (n - 1) + 1"}
{"task_id": 87, "completion": "def merge_dictionaries_three(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}"}
{"task_id": 88, "completion": "def freq_count(list1):\n    # Initialize an empty dictionary to store frequency of elements\n    frequency = {}\n    # Iterate over each element in the list\n    for item in list1:\n        # If the element is already in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # If the element is not in the dictionary, add it with count 1\n        else:\n            frequency[item] = 1\n    # Return the dictionary containing frequencies of elements\n    return frequency"}
{"task_id": 89, "completion": "def closest_num(n):\n    # The closest smaller number than n is simply n - 1\n    return n - 1"}
{"task_id": 90, "completion": "def len_log(word_list):\n    # Check if the list is not empty\n    if word_list:\n        # Use the max function with a key to find the longest word by length\n        longest_word = max(word_list, key=len)\n        # Return the length of the longest word\n        return len(longest_word)\n    else:\n        # Return 0 or an appropriate value if the list is empty\n        return 0"}
{"task_id": 91, "completion": "def find_substring(str_list, sub_str):\n    # Iterate through each string in the list\n    for string in str_list:\n        # Check if the substring is present in the current string\n        if sub_str in string:\n            # If found, return True\n            return True\n    # If the loop completes without finding the substring, return False\n    return False"}
{"task_id": 92, "completion": "def is_undulating(n):\n    # Convert the number to a string to easily access individual digits\n    n_str = str(n)\n    \n    # An undulating number must have at least 3 digits to form a pattern\n    if len(n_str) < 3:\n        return False\n    \n    # Check if the number is undulating by comparing alternating digits\n    for i in range(2, len(n_str)):\n        # If the current digit is not equal to the digit two places before it, it's not undulating\n        if n_str[i] != n_str[i-2]:\n            return False\n        # Additionally, the first and second digits must be different for an undulating pattern\n        if n_str[0] == n_str[1]:\n            return False\n    \n    # If all checks pass, the number is undulating\n    return True"}
{"task_id": 93, "completion": "def power(a, b):\n    return a ** b"}
{"task_id": 94, "completion": "def index_minimum(test_list):\n    # Check if the list is not empty to avoid errors\n    if not test_list:\n        return None  # Return None or an appropriate value if the list is empty\n    \n    # Initialize the index of the minimum value record\n    min_index = 0\n    \n    # Loop through the list to find the index of the minimum value record\n    for i in range(1, len(test_list)):\n        # Compare the current minimum with the new tuple\n        if test_list[i] < test_list[min_index]:\n            min_index = i\n    \n    # Return the index of the minimum value record\n    return min_index\n`"}
{"task_id": 95, "completion": "def find_min_length(lst):\n    # Initialize min_length to None, to handle the case where there might be no sublists\n    min_length = None\n    \n    # Iterate through each item in the list\n    for item in lst:\n        # Check if the current item is a list (sublist)\n        if isinstance(item, list):\n            # If min_length is None or the length of the current sublist is smaller than min_length\n            if min_length is None or len(item) < min_length:\n                # Update min_length to the length of the current sublist\n                min_length = len(item)\n    \n    # Return min_length, which could be None if there were no sublists\n    return min_length\n`"}
{"task_id": 96, "completion": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"}
{"task_id": 97, "completion": "def frequency_lists(list_of_lists):\n    # Initialize an empty dictionary to store frequency counts\n    frequency = {}\n    \n    # Iterate through each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Iterate through each element in the sublist\n        for item in sublist:\n            # If the item is already in the dictionary, increment its count\n            if item in frequency:\n                frequency[item] += 1\n            # If the item is not in the dictionary, add it with a count of 1\n            else:\n                frequency[item] = 1\n                \n    return frequency"}
{"task_id": 98, "completion": "def multiply_num(numbers):\n    # Check if the list is empty\n    if not numbers:\n        return \"The list is empty\"\n    \n    # Initialize the result with 1 (neutral element for multiplication)\n    result = 1\n    \n    # Loop through the numbers in the list and multiply them\n    for num in numbers:\n        result *= num\n    \n    # Divide the result by the length of the list\n    final_result = result / len(numbers)\n    \n    return final_result"}
{"task_id": 99, "completion": "def decimal_to_binary(n):\n    # Ensure n is a non-negative integer\n    if n < 0:\n        return \"Please enter a non-negative integer\"\n    \n    # Special case for 0\n    if n == 0:\n        return \"0\"\n    \n    binary = \"\"\n    while n > 0:\n        remainder = n % 2\n        binary = str(remainder) + binary\n        n = n // 2\n    return binary"}
{"task_id": 100, "completion": "def next_smallest_palindrome(num):\n    \"\"\"Find the next smallest palindrome greater than the given number.\"\"\"\n    # Increment the number to start checking from the next number\n    num += 1\n    # Keep incrementing num until we find a palindrome\n    while not is_palindrome(num):\n        num += 1\n    return num"}
{"task_id": 101, "completion": "def kth_element(arr, n, k):\n    # Sort the array\n    arr.sort()\n    \n    # Return the kth element\n    return arr[k-1]  # Assuming k is 1-based indexing"}
{"task_id": 102, "completion": "def snake_to_camel(word):\n    parts = word.split('_')\n    camel_case_word = parts[0] + ''.join(part.capitalize() for part in parts[1:])\n    return camel_case_word"}
{"task_id": 103, "completion": "def eulerian_num(n, m):\n    # Base cases\n    if n == 0 and m == 0:\n        return 1\n    if m < 0 or m >= n:\n        return 0\n    \n    # Recursive formula\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)"}
{"task_id": 104, "completion": "def sort_sublists(input_list):\n    # Use map to apply sorting to each sublist\n    sorted_sublists = map(lambda sublist: sorted(sublist), input_list)\n    # Convert the map object back to a list of lists\n    return list(sorted_sublists)"}
{"task_id": 105, "completion": "def count_true_booleans(lst):\n    # Initialize a counter to 0\n    count = 0\n    # Iterate through each element in the list\n    for element in lst:\n        # If the element is True, increment the counter\n        if element is True:\n            count += 1\n    # Return the final count\n    return count"}
{"task_id": 106, "completion": "def add_lists(test_list, test_tup):\n    # Convert the tuple to a list\n    temp_list = list(test_tup)\n    \n    # Add the elements of test_list to the temp_list\n    temp_list.extend(test_list)\n    \n    # Convert the list back to a tuple\n    result_tup = tuple(temp_list)\n    \n    return result_tup"}
{"task_id": 107, "completion": "def count_Hexadecimal(L, R):\n    # The count of hexadecimal numbers in the range [L, R] is simply (R - L + 1)\n    return R - L + 1"}
{"task_id": 108, "completion": "import heapq\n\ndef merge_sorted_list(*args):\n    \"\"\"\n    Merge multiple sorted inputs into a single sorted iterator.\n    \n    Parameters:\n    *args: An arbitrary number of sorted iterables.\n    \n    Returns:\n    An iterator over the sorted values.\n    \"\"\"\n    return heapq.merge(*args)"}
{"task_id": 109, "completion": "def count_odd_rotations(s):\n    \"\"\"\n    Counts the rotations of a binary string that result in an odd value.\n    \n    Parameters:\n    s (str): The binary string.\n    \n    Returns:\n    int: The count of rotations resulting in an odd value.\n    \"\"\"\n    # Count the occurrences of '1' in the string\n    count_of_ones = s.count('1')\n    \n    # Each '1' can be rotated to the end to form an odd number\n    return count_of_ones"}
{"task_id": 110, "completion": "def extract_missing(test_list, strt_val, stop_val):\n    # Sort the list to ensure it is in ascending order\n    sorted_list = sorted(test_list)\n    \n    # Initialize an empty list to store the missing ranges\n    missing_ranges = []\n    \n    # Initialize the current value to the start value\n    current_val = strt_val\n    \n    # Iterate through the sorted list\n    for num in sorted_list:\n        # Check if the current number is within the specified range\n        if strt_val <= num <= stop_val:\n            # If there's a gap between the current value and the number, add the range to missing_ranges\n            if num > current_val:\n                missing_ranges.append((current_val, num - 1))\n            # Update the current value to the next number in the sequence\n            current_val = num + 1\n    \n    # After iterating through the list, check if there's a remaining range to add\n    if current_val <= stop_val:\n        missing_ranges.append((current_val, stop_val))\n    \n    return missing_ranges"}
{"task_id": 111, "completion": "def common_in_nested_lists(nested_list):\n    # Check if the nested list is empty\n    if not nested_list:\n        return []\n    \n    # Initialize a dictionary to keep track of element counts\n    element_count = {}\n    \n    # Iterate through each list in the nested list\n    for lst in nested_list:\n        # Use a set to avoid counting duplicates within the same list\n        unique_elements = set(lst)\n        for element in unique_elements:\n            if element in element_count:\n                element_count[element] += 1\n            else:\n                element_count[element] = 1\n    \n    # Calculate the number of lists in the nested list\n    num_lists = len(nested_list)\n    \n    # Find elements that are common across all lists\n    common_elements = [element for element, count in element_count.items() if count == num_lists]\n    \n    return common_elements\n`"}
{"task_id": 112, "completion": "import math\n\ndef cylinder_perimeter(diameter, height):\n    # Calculate the circumference of the base\n    circumference = math.pi * diameter\n    \n    # The \"perimeter\" based on the question's context\n    # This includes the circumference of both bases (2 * circumference) and twice the height\n    perimeter = 2 * circumference + 2 * height\n    \n    return perimeter"}
{"task_id": 113, "completion": "def check_integer(text):\n    # Attempt to convert the string to an integer\n    try:\n        # If this succeeds, then text is an integer\n        int(text)\n        return True\n    except ValueError:\n        # If a ValueError is raised, then text is not an integer\n        return False"}
{"task_id": 114, "completion": "from collections import Counter\n\ndef assign_freq(test_list):\n    # Count the frequency of each tuple in the list\n    freq = Counter(test_list)\n    \n    # Create a new list of tuples, pairing each original tuple with its frequency\n    result = [(item, freq[item]) for item in test_list]\n    \n    return result"}
{"task_id": 115, "completion": "def empty_dit(list1):\n    # Iterate through each dictionary in the list\n    for dit in list1:\n        # Check if the dictionary is not empty\n        if dit:\n            # If a non-empty dictionary is found, return False\n            return False\n    # If the loop completes without finding a non-empty dictionary, return True\n    return True"}
{"task_id": 116, "completion": "def tuple_to_int(nums):\n    # Convert each number in the tuple to a string and concatenate them\n    num_str = ''.join(map(str, nums))\n    # Convert the concatenated string back to an integer\n    return int(num_str)"}
{"task_id": 117, "completion": "def list_to_float(test_list):\n    # Iterate through the list with enumeration to modify elements in place\n    for i, item in enumerate(test_list):\n        # Attempt to convert each item to float\n        try:\n            test_list[i] = float(item)\n        except ValueError:\n            # If conversion fails, pass (leave the item as is)\n            pass\n    return test_list"}
{"task_id": 118, "completion": "def string_to_list_of_chars(string):\n    return list(string)\n\ndef string_to_list(string, separator=\" \"):\n    return string.split(separator)"}
{"task_id": 119, "completion": "def findSingleElement(arr):\n    low = 0\n    high = len(arr) - 1\n    \n    # Boundary checks\n    if high == 0:\n        # Only one element in the array\n        return arr[0]\n    elif arr[0] != arr[1]:\n        # If the first element is the unique one\n        return arr[0]\n    elif arr[high] != arr[high - 1]:\n        # If the last element is the unique one\n        return arr[high]\n    \n    # Binary search\n    while low <= high:\n        mid = low + (high - low) // 2\n        \n        # Unique element found\n        if arr[mid] != arr[mid + 1] and arr[mid] != arr[mid - 1]:\n            return arr[mid]\n        \n        # If the index of mid is even and the next element is the same, move right\n        # Or if the index of mid is odd and the previous element is the same, also move right\n        if ((mid % 2 == 0) and (arr[mid] == arr[mid + 1])) or ((mid % 2 == 1) and (arr[mid] == arr[mid - 1])):\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    # In case no unique element is found (should not happen if input is valid)\n    return None"}
{"task_id": 120, "completion": "def max_product_tuple(list1):\n    # Initialize max_product to a very small number or to the product of the first tuple\n    # to handle cases where all products might be negative.\n    max_product = float('-inf') if not list1 else list1[0][0] * list1[0][1]\n    \n    # Iterate through each tuple in the list\n    for tup in list1:\n        # Calculate the product of the current tuple\n        product = tup[0] * tup[1]\n        # Update max_product if the current product is greater than the max_product\n        if product > max_product:\n            max_product = product\n            \n    return max_product\n`"}
{"task_id": 121, "completion": "def check_triplet(A, n, sum):\n    # Sort the array\n    A.sort()\n    count = 0  # Initialize count of triplets\n\n    # Iterate through the array\n    for i in range(0, n-2):\n        # Initialize two pointers\n        left = i + 1\n        right = n - 1\n\n        # Use two pointers to find a pair that sums up with A[i] to the given sum\n        while left < right:\n            current_sum = A[i] + A[left] + A[right]\n\n            # If the sum is found, increment count and adjust pointers\n            if current_sum == sum:\n                count += 1\n                left += 1\n                right -= 1\n\n                # Optional: Handle duplicates if the array contains duplicate elements\n                # while left < right and A[left] == A[left - 1]:\n                #     left += 1\n                # while left < right and A[right] == A[right + 1]:\n                #     right -= 1\n\n            # If current sum is less than the target, move the left pointer to the right\n            elif current_sum < sum:\n                left += 1\n            # If current sum is more than the target, move the right pointer to the left\n            else:\n                right -= 1\n\n    return count"}
{"task_id": 122, "completion": "def smart_number(n):\n    \"\"\"Find the n-th smart number.\"\"\"\n    smart_numbers = []\n    num = 2  # Starting from the first prime number\n    while len(smart_numbers) < n:\n        if is_prime(num):\n            smart_numbers.append(num)\n        else:\n            # Check if num can be expressed as the sum of two prime numbers\n            for i in range(2, num):\n                if is_prime(i) and is_prime(num - i):\n                    smart_numbers.append(num)\n                    break\n        num += 1\n    return smart_numbers[-1]"}
{"task_id": 123, "completion": "def amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(2, limit):\n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a:  # Check if a and b are amicable and not the same\n            amicable_sum += a\n    return amicable_sum"}
{"task_id": 124, "completion": "import cmath\n\ndef angle_complex(a, b):\n    # Create a complex number from a and b\n    complex_number = complex(a, b)\n    # Use cmath.phase() to get the angle (in radians)\n    angle = cmath.phase(complex_number)\n    return angle"}
{"task_id": 125, "completion": "def find_length(string, n):\n    # Convert the binary string into an array of 1s and -1s\n    # where 1 represents a '0' in the original string and -1 represents a '1'.\n    arr = [1 if char == '0' else -1 for char in string]\n    \n    # Initialize variables to keep track of the maximum difference\n    # and the current sum.\n    max_diff = 0\n    current_sum = 0\n    \n    # Iterate through the array to find the maximum subarray sum\n    # which represents the maximum difference between the number of 0s and 1s.\n    for num in arr:\n        current_sum += num\n        \n        # If the current sum is negative, reset it to 0 as it's not beneficial to include\n        # the previous part of the subarray.\n        if current_sum < 0:\n            current_sum = 0\n        \n        # Update the maximum difference if the current sum is greater than the maximum found so far.\n        max_diff = max(max_diff, current_sum)\n    \n    return max_diff"}
{"task_id": 126, "completion": "def sum_of_common_divisors(a, b):\n    \"\"\"\n    Function to find the sum of common divisors of two given numbers.\n    \"\"\"\n    # Find the GCD of a and b\n    gcd_value = gcd(a, b)\n    \n    # Initialize sum of divisors\n    sum_divisors = 0\n    \n    # Loop to find divisors of gcd_value\n    for i in range(1, gcd_value + 1):\n        if gcd_value % i == 0:\n            sum_divisors += i\n            \n    return sum_divisors"}
{"task_id": 127, "completion": "def multiply_int(x, y):\n    # Handle negative numbers\n    if x < 0 and y < 0:\n        x, y = -x, -y\n    elif x < 0 or y < 0:\n        x, y = abs(x), abs(y)\n        return -multiply_int(x, y)\n    \n    # Initialize result\n    result = 0\n    \n    # Add x to itself y times\n    for _ in range(y):\n        result += x\n    \n    return result"}
{"task_id": 128, "completion": "def long_words(n, str):\n    # Split the string into a list of words\n    words = str.split()\n    # Filter words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list"}
{"task_id": 129, "completion": "def magic_square_test(my_matrix):\n    # Calculate the size of the matrix\n    n = len(my_matrix)\n    \n    # Calculate the sum of the first row to use as a comparison\n    magic_sum = sum(my_matrix[0])\n    \n    # Check sums of rows\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of columns\n    for col in range(n):\n        if sum(my_matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check diagonal (top-left to bottom-right)\n    if sum(my_matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check anti-diagonal (top-right to bottom-left)\n    if sum(my_matrix[i][n-1-i] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks passed, it's a magic square\n    return True\n`"}
{"task_id": 130, "completion": "def max_occurrences(nums):\n    # Check if the list is empty\n    if not nums:\n        return None, 0\n    \n    # Create a dictionary to store the frequency of each item\n    freq_dict = {}\n    for num in nums:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    \n    # Find the item with the maximum frequency\n    max_freq = 0\n    max_item = None\n    for item, freq in freq_dict.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    \n    return max_item, max_freq"}
{"task_id": 131, "completion": "def reverse_vowels(str1):\n    vowels = 'aeiouAEIOU'\n    # Find all vowels in the string and reverse them\n    reversed_vowels = [char for char in str1 if char in vowels][::-1]\n    \n    # Create a list to hold the characters of the new string\n    result_list = list(str1)\n    \n    # Iterator for the reversed vowels\n    reversed_vowels_iter = iter(reversed_vowels)\n    \n    # Replace the vowels in the original string with the reversed vowels\n    for i, char in enumerate(result_list):\n        if char in vowels:\n            result_list[i] = next(reversed_vowels_iter)\n    \n    # Join the list back into a string\n    return ''.join(result_list)\n`"}
{"task_id": 132, "completion": "def tup_string(tup):\n    return ''.join(map(str, tup))"}
{"task_id": 133, "completion": "def sum_negative_nums(nums):\n    # Use filter() to keep only negative numbers, then sum them up\n    return sum(filter(lambda x: x < 0, nums))"}
{"task_id": 134, "completion": "def check_last(arr, n, p):\n    \"\"\"\n    Check if the last element of the array is even or odd after incrementing it p times.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array. (This parameter is actually redundant if we're using Python lists.)\n    p (int): The number of times the operation (incrementing the last element) is performed.\n\n    Returns:\n    str: \"Even\" if the last element is even after the operation, \"Odd\" otherwise.\n    \"\"\"\n    # Check if the array is empty\n    if not arr:\n        return \"Array is empty\"\n    \n    # Perform the operation p times\n    arr[-1] += p\n    \n    # Check if the last element is even or odd\n    if arr[-1] % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n`"}
{"task_id": 135, "completion": "def hexagonal_num(n):\n    return n * (2 * n - 1)"}
{"task_id": 136, "completion": "def cal_electbill(units):\n    \"\"\"\n    Calculate the electricity bill for a given number of units.\n    \n    Args:\n    units (int): The number of units of electricity consumed.\n    \n    Returns:\n    float: The total electricity bill.\n    \"\"\"\n    # Define the rate structure\n    if units <= 100:\n        rate = 0.5  # Assume 0.5 currency unit per unit for the first 100 units\n    elif units <= 200:\n        # For units between 101 and 200, the rate increases\n        rate = 0.75\n    elif units <= 500:\n        # For units between 201 and 500, the rate increases further\n        rate = 1.2\n    else:\n        # For units above 500, the highest rate applies\n        rate = 1.5\n    \n    # Calculate the bill\n    bill = units * rate\n    \n    # Apply a fixed meter charge for simplicity, say 50 currency units\n    meter_charge = 50\n    \n    # Total bill\n    total_bill = bill + meter_charge\n    \n    return total_bill\n`"}
{"task_id": 137, "completion": "def zero_count(nums):\n    # Step 1: Count the number of zeroes\n    zero_count = nums.count(0)\n    \n    # Step 2: Calculate the ratio\n    if len(nums) == 0:  # To avoid division by zero\n        return 0\n    ratio = zero_count / len(nums)\n    \n    # Step 3: Return the ratio\n    return ratio"}
{"task_id": 138, "completion": "def is_Sum_Of_Powers_Of_Two(n):\n    # Check if the number is less than or equal to 0\n    if n <= 0:\n        return False\n    \n    # Count the number of 1's in the binary representation of n\n    # If the count is greater than 0, it means n can be represented as a sum of non-zero powers of 2\n    return bin(n).count('1') > 0"}
{"task_id": 139, "completion": "def circle_circumference(r):\n    pi = 3.14159  # You can also use math.pi for more precision\n    circumference = 2 * pi * r\n    return circumference"}
{"task_id": 140, "completion": "def extract_singly(test_list):\n    # Create a dictionary to count occurrences of each element\n    element_count = {}\n    \n    # Iterate through each tuple in the list\n    for tup in test_list:\n        # Iterate through each element in the tuple\n        for elem in tup:\n            # If the element is already in the dictionary, increment its count\n            if elem in element_count:\n                element_count[elem] += 1\n            # Otherwise, add the element to the dictionary with a count of 1\n            else:\n                element_count[elem] = 1\n    \n    # Extract elements that occur singly based on the count\n    singly_elements = [elem for elem, count in element_count.items() if count == 1]\n    \n    return singly_elements\n`"}
{"task_id": 141, "completion": "def flip(arr, k):\n    \"\"\"Flip the first k elements of the array.\"\"\"\n    start = 0\n    while start < k:\n        arr[start], arr[k] = arr[k], arr[start]\n        start += 1\n        k -= 1\n\ndef pancake_sort(arr):\n    \"\"\"Sort arr using pancake sort.\"\"\"\n    n = len(arr)\n    # Start from the complete array and one by one reduce current size by one\n    for curr_size in range(n, 1, -1):\n        # Find index of the maximum element in arr[0..curr_size-1]\n        max_index = find_max_index(arr, curr_size)\n        \n        # Move the maximum element to end of current array if it's not already at the end\n        if max_index != curr_size - 1:\n            # First move maximum number to beginning\n            if max_index != 0:\n                flip(arr, max_index)\n            \n            # Now move the maximum number to end by reversing current array\n            flip(arr, curr_size - 1)\n    return arr"}
{"task_id": 142, "completion": "def count_samepair(list1, list2, list3):\n    # Convert lists into sets of tuples for faster lookup\n    set2 = {tuple(sorted([x, y])) for x in list2 for y in list2 if x != y}\n    set3 = {tuple(sorted([x, y])) for x in list3 for y in list3 if x != y}\n    \n    # Count pairs in list1 that also exist in both set2 and set3\n    count = 0\n    for x in list1:\n        for y in list1:\n            if x != y:  # Ensure we're looking at pairs of different elements\n                pair = tuple(sorted([x, y]))\n                if pair in set2 and pair in set3:\n                    count += 1\n    \n    # Since each pair is counted twice (once for each order), divide by 2\n    return count // 2\n`"}
{"task_id": 143, "completion": "def find_lists(input_tuple):\n    # Initialize a counter to keep track of lists\n    list_count = 0\n    \n    # Iterate through each element in the tuple\n    for element in input_tuple:\n        # Check if the current element is a list\n        if isinstance(element, list):\n            # Increment the counter if it's a list\n            list_count += 1\n            \n    # Return the total count of lists found\n    return list_count"}
{"task_id": 144, "completion": "def sum_pairs(arr):\n    # Sort the array\n    arr.sort()\n    \n    # Initialize the sum of absolute differences\n    sum_abs_diff = 0\n    \n    # Calculate the sum of absolute differences\n    for i in range(len(arr)):\n        sum_abs_diff += (arr[i] * i - arr[i] * (len(arr) - i - 1))\n    \n    return sum_abs_diff"}
{"task_id": 145, "completion": "def max_Abs_Diff(arr, n):\n    # Check if the array has less than 2 elements\n    if n < 2:\n        return \"Array must have at least two elements\"\n    \n    # Initialize min and max elements as the first element of the array\n    min_element = arr[0]\n    max_element = arr[0]\n    \n    # Iterate through the array to find the min and max elements\n    for i in range(1, n):\n        if arr[i] < min_element:\n            min_element = arr[i]\n        elif arr[i] > max_element:\n            max_element = arr[i]\n    \n    # The maximum absolute difference is the difference between max and min elements\n    return max_element - min_element\n`"}
{"task_id": 146, "completion": "def ascii_value_string(str1):\n    # Initialize a variable to hold the total ASCII value\n    total_ascii_value = 0\n    \n    # Iterate through each character in the string\n    for char in str1:\n        # Add the ASCII value of the character to the total\n        total_ascii_value += ord(char)\n    \n    # Return the total ASCII value\n    return total_ascii_value"}
{"task_id": 147, "completion": "def max_path_sum(tri, m, n):\n    \"\"\"\n    Calculate the maximum path sum in triangle tri with m rows and n columns.\n    \n    Args:\n    tri: 2D list of integers representing the triangle\n    m: Number of rows in the triangle\n    n: Not used in this function, as the number of columns in each row can be derived from the row itself\n    \n    Returns:\n    The maximum path sum from top to bottom of the triangle.\n    \"\"\"\n    \n    # Copy the triangle to avoid modifying the original\n    dp = [row[:] for row in tri]\n    \n    # Start from the second last row and move upwards\n    for i in range(m-2, -1, -1):\n        for j in range(len(tri[i])):\n            # For each element, replace it with itself plus the max of the two elements directly below it\n            dp[i][j] += max(dp[i+1][j], dp[i+1][j+1])\n    \n    # The top element now contains the maximum path sum\n    return dp[0][0]\n`"}
{"task_id": 148, "completion": "def sum_digits_single(x):\n    # Convert the number to a sorted list of digits (in descending order)\n    digits = sorted(str(x), reverse=True)\n    \n    # Initialize two parts as empty strings\n    part1, part2 = \"\", \"\"\n    \n    # Distribute digits between the two parts to maximize the sum of digits\n    for i, digit in enumerate(digits):\n        if i % 2 == 0:\n            part1 += digit\n        else:\n            part2 += digit\n    \n    # Convert parts back to integers and calculate the sum of their digits\n    sum_of_digits = sum(int(digit) for digit in part1) + sum(int(digit) for digit in part2)\n    \n    return sum_of_digits\n`"}
{"task_id": 149, "completion": "def longest_subseq_with_diff_one(arr, n):\n    # Initialize the dp array with 1s because the minimum length of the subsequence for any element is 1 (the element itself)\n    dp = [1 for _ in range(n)]\n    \n    # Fill dp[] using the above mentioned approach\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    # The length of the longest subsequence will be the maximum value in dp[]\n    return max(dp)\n`"}
{"task_id": 150, "completion": "def does_contain_b(a, b, c):\n    # Check if c is not zero to avoid division by zero error\n    if c == 0:\n        return False\n    \n    # Calculate n to see if b is in the sequence\n    n = (b - a) / c + 1\n    \n    # Check if n is a positive integer\n    if n > 0 and n.is_integer():\n        return True\n    else:\n        return False"}
{"task_id": 151, "completion": "def is_coprime(p, q):\n    \"\"\"\n    Function to check if two numbers are co-prime.\n    Returns True if p and q are co-prime, False otherwise.\n    \"\"\"\n    return gcd(p, q) == 1"}
{"task_id": 152, "completion": "def mergeSort(arr):\n    if len(arr) > 1:\n        # Finding the mid of the array\n        mid = len(arr)//2\n\n        # Dividing the array elements into 2 halves\n        L = arr[:mid]\n        R = arr[mid:]\n\n        # Sorting the first half\n        mergeSort(L)\n\n        # Sorting the second half\n        mergeSort(R)\n\n        i = j = k = 0\n\n        # Merging the sorted halves\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n\n        # Checking if any element was left\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n\n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1"}
{"task_id": 153, "completion": "def parabola_vertex(a, b, c):\n    # Calculate the x-coordinate of the vertex\n    x_vertex = -b / (2 * a)\n    \n    # Calculate the y-coordinate of the vertex by substituting x back into the equation\n    y_vertex = a * x_vertex**2 + b * x_vertex + c\n    \n    # Return the vertex as a tuple (x, y)\n    return (x_vertex, y_vertex)"}
{"task_id": 154, "completion": "def specified_element(nums, N):\n    # Initialize an empty list to store the extracted elements\n    extracted_elements = []\n    \n    # Iterate through each sub-list in the two-dimensional list\n    for sublist in nums:\n        # Check if the length of the sub-list is at least N\n        if len(sublist) >= N:\n            # Append the Nth element of the sub-list to the result list\n            # Note: Subtract 1 from N because list indices start at 0\n            extracted_elements.append(sublist[N-1])\n    \n    return extracted_elements"}
{"task_id": 155, "completion": "def even_bit_toggle_number(n):\n    # Initialize the mask with 0\n    mask = 0\n    # Calculate the number of bits in 'n'\n    num_bits = n.bit_length()\n    \n    # Set 1 in even positions of the mask\n    for i in range(1, num_bits + 1):\n        if i % 2 == 0:  # Check if the position is even\n            mask |= (1 << (i - 1))\n    \n    # Toggle the even bits of 'n' using XOR\n    result = n ^ mask\n    \n    return result"}
{"task_id": 156, "completion": "def tuple_int_str(tuple_str):\n    # Convert each string in the tuple to an integer and return the new tuple\n    return tuple(int(item) for item in tuple_str)"}
{"task_id": 157, "completion": "def encode_list(input_list):\n    # Check if the input list is empty\n    if not input_list:\n        return []\n\n    # Initialize the encoded list\n    encoded_list = []\n\n    # Initialize the current element and its count\n    current_element = input_list[0]\n    count = 1\n\n    # Iterate over the input list starting from the second element\n    for element in input_list[1:]:\n        if element == current_element:\n            # If the current element is the same as the previous, increment the count\n            count += 1\n        else:\n            # If the current element is different, append the previous element and its count to the encoded list\n            encoded_list.append((current_element, count))\n            # Reset the current element and count\n            current_element = element\n            count = 1\n\n    # Append the last element and its count\n    encoded_list.append((current_element, count))\n\n    return encoded_list"}
{"task_id": 158, "completion": "def min_Ops(arr, n):\n    \"\"\"\n    Calculate the minimum number of operations required to make all elements equal.\n    Each operation consists of incrementing or decrementing any element by 1.\n    \n    Parameters:\n    arr (list): The input array.\n    n (int): The number of elements in the array.\n    \n    Returns:\n    int: The minimum number of operations required.\n    \"\"\"\n    # First, sort the array to easily find the median\n    arr.sort()\n    \n    # Find the median\n    if n % 2 == 0:\n        median = (arr[n//2 - 1] + arr[n//2]) // 2\n    else:\n        median = arr[n//2]\n    \n    # Calculate the number of operations required\n    ops = 0\n    for num in arr:\n        ops += abs(num - median)\n    \n    return ops"}
{"task_id": 159, "completion": "def month_season(month, days):\n    if month in ['March', 'April', 'May']:\n        season = 'Spring'\n    elif month in ['June', 'July', 'August']:\n        season = 'Summer'\n    elif month in ['September', 'October', 'November']:\n        season = 'Autumn'\n    else:\n        season = 'Winter'\n    \n    # Adjusting for the edge cases at the start of seasons\n    if month == 'March' and days < 1:\n        season = 'Winter'\n    elif month == 'June' and days < 1:\n        season = 'Spring'\n    elif month == 'September' and days < 1:\n        season = 'Summer'\n    elif month == 'December' and days < 1:\n        season = 'Autumn'\n    \n    print(f\"The season on {month} {days} is {season}.\")"}
{"task_id": 160, "completion": "def find_solution(a, b, n):\n    \"\"\"\n    Finds a solution (x, y) to the equation ax + by = n, if it exists.\n    \"\"\"\n    g, x, y = extended_gcd(a, b)\n    if n % g != 0:\n        return \"No solution exists\"\n    \n    # Scale the base solution to the specific value of n\n    x0 = x * (n // g)\n    y0 = y * (n // g)\n    \n    return (x0, y0)"}
{"task_id": 161, "completion": "def remove_elements(list1, list2):\n    # Using list comprehension to filter out elements present in list2\n    return [element for element in list1 if element not in list2]"}
{"task_id": 162, "completion": "def sum_series(n):\n    # Check if n is positive. If not, return 0 as the sum for non-positive integers.\n    if n <= 0:\n        return 0\n    \n    # Initialize sum to 0\n    sum = 0\n    \n    # Loop until n becomes 0 or negative\n    while n > 0:\n        sum += n  # Add n to sum\n        n -= 2  # Decrease n by 2 for the next term in the series\n    \n    return sum"}
{"task_id": 163, "completion": "import math\n\ndef area_polygon(n, s):\n    \"\"\"\n    Calculate the area of a regular polygon.\n\n    Parameters:\n    n (int): Number of sides of the polygon.\n    s (float): Length of each side.\n\n    Returns:\n    float: Area of the polygon.\n    \"\"\"\n    # Calculate the area using the formula\n    area = (n * s**2) / (4 * math.tan(math.pi / n))\n    return area"}
{"task_id": 164, "completion": "def divSum(n):\n    # Initialize sum of divisors to 1 because 1 is a divisor of all numbers.\n    sum_of_divisors = 1\n    \n    # Check for divisors from 2 to the square root of n.\n    # This is because a divisor larger than the square root would have been found as a pair with a smaller one before.\n    i = 2\n    while i <= (n**0.5):\n        if n % i == 0:\n            # If divisors are equal, add it only once. Else, add both\n            if i == (n/i):\n                sum_of_divisors += i\n            else:\n                sum_of_divisors += i + (n//i)\n        i += 1\n    \n    # Check if the sum of divisors equals n\n    return sum_of_divisors == n"}
{"task_id": 165, "completion": "def count_char_position(str1):\n    # Initialize a counter to keep track of matching positions\n    count = 0\n    \n    # Iterate through the string, with 'i' being the index and 'char' the character\n    for i, char in enumerate(str1):\n        # Convert character to lowercase to make comparison case-insensitive\n        char_lower = char.lower()\n        \n        # Calculate the alphabetical index (1-based) of the character\n        # 'a' has an ASCII value of 97, so subtracting 96 makes 'a' = 1, 'b' = 2, etc.\n        char_index = ord(char_lower) - 96\n        \n        # Check if the character's position matches its alphabetical index\n        # Since 'enumerate' is 0-based and our calculation is 1-based, we add 1 to 'i'\n        if char_index == i + 1:\n            count += 1\n    \n    return count"}
{"task_id": 166, "completion": "def find_even_pair(A, N):\n    # Count of even and odd elements\n    even_count = 0\n    odd_count = 0\n    \n    # Iterate through the array to count even and odd numbers\n    for num in A:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # The number of pairs with even XOR can be calculated by choosing\n    # any two even numbers or any two odd numbers.\n    # This can be done using the combination formula: nC2 = n*(n-1)/2\n    even_pairs = even_count * (even_count - 1) // 2\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    # Total pairs with even XOR is the sum of even_pairs and odd_pairs\n    total_even_xor_pairs = even_pairs + odd_pairs\n    \n    return total_even_xor_pairs"}
{"task_id": 167, "completion": "def next_Power_Of_2(n):\n    # If n is less than or equal to 0, the next power of 2 cannot be found\n    if n <= 0:\n        return \"Invalid input. n should be greater than 0.\"\n    \n    # Start with power of 2 as 1\n    power_of_2 = 1\n    \n    # Keep doubling until power_of_2 is greater than or equal to n\n    while power_of_2 < n:\n        power_of_2 *= 2\n    \n    return power_of_2"}
{"task_id": 168, "completion": "def frequency(a, x):\n    # Initialize a counter to keep track of the frequency\n    count = 0\n    \n    # Loop through each element in the array\n    for element in a:\n        # If the element is equal to x, increment the counter\n        if element == x:\n            count += 1\n            \n    # Return the final count\n    return count"}
{"task_id": 169, "completion": "def get_pell(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        # Initialize the first two Pell numbers\n        pell_0 = 0\n        pell_1 = 1\n        for _ in range(2, n + 1):\n            # Calculate the next Pell number\n            pell_next = 2 * pell_1 + pell_0\n            # Update the previous two Pell numbers\n            pell_0, pell_1 = pell_1, pell_next\n        return pell_1"}
{"task_id": 170, "completion": "def sum_range_list(list1, m, n):\n    # Ensure the range is within the bounds of the list\n    if m < 0 or n >= len(list1) or m > n:\n        return \"Invalid range\"\n    \n    # Calculate the sum of elements in the specified range\n    sum_of_elements = sum(list1[m:n+1])\n    \n    return sum_of_elements"}
{"task_id": 171, "completion": "def perimeter_pentagon(a):\n    \"\"\"\n    Calculate the perimeter of a regular pentagon.\n\n    Parameters:\n    a (float): The length of one side of the pentagon.\n\n    Returns:\n    float: The perimeter of the pentagon.\n    \"\"\"\n    return 5 * a"}
{"task_id": 172, "completion": "def count_occurrence(s):\n    # Initialize a dictionary to store the count of 's', 't', and 'd'\n    count_dict = {'s': 0, 't': 0, 'd': 0}\n    \n    # Iterate through each character in the string\n    for char in s:\n        # If the character is one of 's', 't', or 'd', increment its count\n        if char in count_dict:\n            count_dict[char] += 1\n    \n    return count_dict"}
{"task_id": 173, "completion": "import re\n\ndef remove_splchar(text):\n    # This regular expression matches any character that is NOT a letter or number.\n    # The caret (^) inside the brackets negates the character class, matching anything not in the brackets.\n    # \\w matches any alphanumeric character and underscore. To exclude underscore, it's explicitly added in the negation.\n    result = re.sub(r'[^a-zA-Z0-9]', '', text)\n    return result"}
{"task_id": 174, "completion": "def group_keyvalue(pairs):\n    \"\"\"\n    Groups a sequence of key-value pairs into a dictionary of lists.\n    \n    Parameters:\n    pairs (list of tuple): A list of key-value pairs.\n    \n    Returns:\n    dict: A dictionary where each key maps to a list of values.\n    \"\"\"\n    result = {}\n    for key, value in pairs:\n        # If the key is not already in the dictionary, add it with a new list\n        if key not in result:\n            result[key] = []\n        # Append the current value to the list of values for this key\n        result[key].append(value)\n    return result"}
{"task_id": 175, "completion": "def is_valid_parentheses(s):\n    # Stack to keep track of opening parentheses\n    stack = []\n    \n    # Dictionary to keep track of mappings. This makes the code easier to read.\n    # Also helps with finding the pair for the current character.\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    \n    # For every bracket in the expression.\n    for char in s:\n        # If the character is an closing bracket\n        if char in mapping:\n            # Pop the topmost element from the stack, if it is non empty\n            # Otherwise assign a dummy value of '#' to the top_element variable\n            top_element = stack.pop() if stack else '#'\n            \n            # The mapping for the opening bracket in our hash and the top\n            # element of the stack don't match, return False\n            if mapping[char] != top_element:\n                return False\n        else:\n            # We have an opening bracket, simply push it onto the stack.\n            stack.append(char)\n    \n    # If the stack is empty, then we have a balanced expression. The stack\n    # won't be empty for cases like (((()\n    return not stack"}
{"task_id": 176, "completion": "def perimeter_triangle(a, b, c):\n    # Calculate the perimeter\n    perimeter = a + b + c\n    return perimeter"}
{"task_id": 177, "completion": "def find_lcm_pair(L, R):\n    \"\"\"\n    Finds two distinct numbers within the range [L, R] such that their LCM lies within the same range.\n    Returns a tuple of the two numbers if found, otherwise returns None.\n    \"\"\"\n    # Function to calculate LCM\n    def lcm(a, b):\n        return abs(a*b) // math.gcd(a, b)\n    \n    # Start from the lower bound and try to find a pair\n    for i in range(L, R):\n        for j in range(i+1, min(i+3, R+1)):  # Check the next 1 or 2 numbers\n            if L <= lcm(i, j) <= R:\n                return (i, j)\n    \n    # If no such pair is found\n    return None"}
{"task_id": 178, "completion": "def string_literals(patterns, text):\n    \"\"\"\n    Search for literal strings in a text and return their start indices.\n\n    :param patterns: List of string patterns to search for.\n    :param text: String where patterns will be searched.\n    :return: Dictionary with patterns as keys and lists of start indices as values.\n    \"\"\"\n    # Initialize a dictionary to hold the results\n    result = {}\n\n    # Iterate over each pattern\n    for pattern in patterns:\n        # Initialize the list of indices for the current pattern\n        start_indices = []\n\n        # Initialize the start index for search\n        start_index = text.find(pattern)\n\n        # While the pattern is found in the text\n        while start_index != -1:\n            # Append the current index\n            start_indices.append(start_index)\n\n            # Search for the pattern again in the text, starting from the next character\n            start_index = text.find(pattern, start_index + 1)\n\n        # Assign the list of indices to the pattern in the result dictionary\n        result[pattern] = start_indices\n\n    return result"}
{"task_id": 179, "completion": "def is_num_keith(x):\n    # Convert the number to a list of its digits\n    digits = [int(d) for d in str(x)]\n    \n    # Initialize the sequence with the digits of the number\n    sequence = digits[:]\n    \n    # Calculate the next term and check if it matches the number\n    while sum(sequence) < x:\n        sequence.append(sum(sequence))\n        # Remove the first element to keep the sequence length equal to the number of digits\n        sequence.pop(0)\n    \n    # If the last term added equals the number, it's a Keith number\n    return sum(sequence) == x\n`"}
{"task_id": 180, "completion": "import math\n\ndef distance_lat_long(slat, slon, elat, elon):\n    # Convert latitude and longitude from degrees to radians\n    slat, slon, elat, elon = map(math.radians, [slat, slon, elat, elon])\n\n    # Haversine formula\n    dlat = elat - slat\n    dlon = elon - slon\n    a = math.sin(dlat/2)**2 + math.cos(slat) * math.cos(elat) * math.sin(dlon/2)**2\n    c = 2 * math.asin(math.sqrt(a))\n\n    # Radius of Earth in kilometers. Use 3956 for miles\n    radius = 6371\n\n    # Calculate the result\n    distance = c * radius\n\n    return distance"}
{"task_id": 181, "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Finds the longest common prefix among a set of strings.\n\n    Parameters:\n    strs (List[str]): A list of strings.\n\n    Returns:\n    str: The longest common prefix among all strings in the list.\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the prefix being the entire first string\n    prefix = strs[0]\n    \n    # Iterate through the strings in the list starting from the second one\n    for i in range(1, len(strs)):\n        # Update the prefix to be the common prefix between\n        # the current prefix and the next string\n        prefix = common_prefix_util(prefix, strs[i])\n        \n        # If at any point the common prefix is an empty string,\n        # there is no common prefix among the strings\n        if not prefix:\n            break\n    \n    return prefix"}
{"task_id": 182, "completion": "import re\n\ndef find_character(string):\n    # Find all uppercase letters\n    uppercase_letters = re.findall(r'[A-Z]', string)\n    \n    # Find all lowercase letters\n    lowercase_letters = re.findall(r'[a-z]', string)\n    \n    # Find all numeric values\n    numeric_values = re.findall(r'\\d', string)\n    \n    # Find all special characters (excluding space)\n    # This regex matches any character that is not a letter, digit, or space\n    special_characters = re.findall(r'[^A-Za-z0-9\\s]', string)\n    \n    return {\n        'uppercase_letters': uppercase_letters,\n        'lowercase_letters': lowercase_letters,\n        'numeric_values': numeric_values,\n        'special_characters': special_characters\n    }\n`"}
{"task_id": 183, "completion": "def count_pairs(arr, n, k):\n    # Convert the array to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Initialize count of pairs\n    count = 0\n    \n    # Loop through the unique elements\n    for element in unique_elements:\n        # Check if the pair (element, element + k) exists\n        if element + k in unique_elements:\n            count += 1\n            \n    return count"}
{"task_id": 184, "completion": "def greater_specificnum(lst, num):\n    # Using list comprehension to find values greater than num\n    result = [x for x in lst if x > num]\n    return result"}
{"task_id": 185, "completion": "def parabola_focus(a, b, c):\n    # Calculate the vertex (h, k) of the parabola\n    h = -b / (2 * a)\n    k = c - (b**2) / (4 * a)\n    \n    # The focus lies at a distance 1/(4a) from the vertex along the axis of symmetry\n    # For a parabola opening upwards or downwards, this distance affects the y-coordinate of the vertex\n    focus_x = h\n    focus_y = k + 1 / (4 * a)\n    \n    return (focus_x, focus_y)\n`"}
{"task_id": 186, "completion": "import re\n\ndef check_literals(text, patterns):\n    # Dictionary to store the result\n    result = {}\n    \n    for pattern in patterns:\n        # Escape the pattern to treat it as a literal string\n        escaped_pattern = re.escape(pattern)\n        \n        # Find all occurrences of the literal string\n        matches = re.findall(escaped_pattern, text)\n        \n        # Add the matches to the result dictionary\n        result[pattern] = matches\n    \n    return result"}
{"task_id": 187, "completion": "def longest_common_subsequence(X, Y, m, n):\n    # Create a DP table to store lengths of longest common subsequences.\n    # Initialize all values to 0.\n    L = [[0] * (n+1) for i in range(m+1)]\n    \n    # Build the L[m+1][n+1] in bottom up fashion\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i-1] == Y[j-1]:\n                L[i][j] = L[i-1][j-1] + 1\n            else:\n                L[i][j] = max(L[i-1][j], L[i][j-1])\n    \n    # L[m][n] contains the length of LCS of X[0..n-1] & Y[0..m-1]\n    return L[m][n]"}
{"task_id": 188, "completion": "def prod_square(n):\n    \"\"\"Check if n can be represented as the product of two squares.\"\"\"\n    if n <= 0:\n        return False\n    factors = prime_factors(n)\n    factor_counts = {factor: factors.count(factor) for factor in set(factors)}\n    for count in factor_counts.values():\n        if count % 2 != 0:\n            return False\n    return True"}
{"task_id": 189, "completion": "def first_Missing_Positive(arr, n):\n    # Utility function to swap elements\n    def swap(arr, i, j):\n        arr[i], arr[j] = arr[j], arr[i]\n    \n    for i in range(n):\n        # While the current element is in the range of 1 to n (to be placed in the array)\n        # and it's not in its correct position (arr[i] != i + 1)\n        # and the target position is not already occupied by the correct element\n        # (to handle duplicate numbers causing infinite loop)\n        while 1 <= arr[i] <= n and arr[i] != arr[arr[i] - 1]:\n            swap(arr, i, arr[i] - 1)\n    \n    # After rearrangement, find the first place where arr[i] != i + 1\n    # which means i + 1 is missing\n    for i in range(n):\n        if arr[i] != i + 1:\n            return i + 1\n    \n    # If all positions are correctly occupied, the missing number is n + 1\n    return n + 1"}
{"task_id": 190, "completion": "def count_integral_points(x1, y1, x2, y2):\n    # Calculate the differences in x and y coordinates\n    # Use abs to ensure the difference is positive\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    \n    # The number of integral points inside the square will be\n    # (dx - 1) * (dy - 1) as we exclude the boundary points\n    # Ensure dx and dy are greater than 1, otherwise, there are no points inside\n    if dx > 1 and dy > 1:\n        return (dx - 1) * (dy - 1)\n    else:\n        # If either dx or dy is 1 or less, there are no integral points inside the square\n        return 0"}
{"task_id": 191, "completion": "def check_monthnumber(monthname):\n    # List of months with 30 days\n    months_with_30_days = ['April', 'June', 'September', 'November']\n    \n    # Check if the given month name is in the list of months with 30 days\n    if monthname in months_with_30_days:\n        return True\n    else:\n        return False"}
{"task_id": 192, "completion": "def check_String(str):\n    # Initialize flags for letter and number\n    has_letter = False\n    has_number = False\n    \n    # Iterate through each character in the string\n    for char in str:\n        # Check if the character is a letter\n        if char.isalpha():\n            has_letter = True\n        # Check if the character is a digit\n        elif char.isdigit():\n            has_number = True\n        \n        # If both conditions are met, no need to continue checking\n        if has_letter and has_number:\n            return True\n    \n    # If the loop completes without returning True, then one or both conditions are not met\n    return False"}
{"task_id": 193, "completion": "def remove_tuple_duplicates(test_tup):\n    # Using a list to maintain order and remove duplicates\n    seen = set()\n    result = []\n    for item in test_tup:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return tuple(result)"}
{"task_id": 194, "completion": "def octal_to_decimal(octal_number):\n    decimal_number = 0\n    # Convert the octal number to a string to easily access each digit\n    octal_str = str(octal_number)\n    # Reverse the string to start from the least significant digit\n    octal_str = octal_str[::-1]\n    \n    for i in range(len(octal_str)):\n        # Convert each character back to an integer, multiply by 8^i, and add to the total\n        decimal_number += int(octal_str[i]) * (8 ** i)\n    \n    return decimal_number"}
{"task_id": 195, "completion": "def first(arr, x, n):\n    \"\"\"\n    Find the first position of an element x in a sorted array arr of size n.\n    \n    Parameters:\n    arr (list): The sorted array.\n    x (int/float): The element to find.\n    n (int): The size of the array.\n    \n    Returns:\n    int: The index of the first occurrence of x in arr. If x is not found, returns -1.\n    \"\"\"\n    low = 0\n    high = n - 1\n    result = -1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        \n        if arr[mid] == x:\n            result = mid  # Record the position\n            high = mid - 1  # Move to the left part to find the first occurrence\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return result"}
{"task_id": 196, "completion": "def remove_tuples(test_list, K):\n    # Using list comprehension to filter out tuples of length K\n    result_list = [item for item in test_list if not (isinstance(item, tuple) and len(item) == K)]\n    return result_list"}
{"task_id": 197, "completion": "def find_exponentio(test_tup1, test_tup2):\n    # Using zip() to pair elements of both tuples and map() with pow() to calculate exponentiation\n    result = tuple(map(pow, test_tup1, test_tup2))\n    return result"}
{"task_id": 198, "completion": "import numpy as np\n\ndef largest_triangle(a, b):\n    def triangle_area(s):\n        return (np.sqrt(3) / 4) * s**2\n    \n    def side_length(t):\n        # Derive the side length of the equilateral triangle at angle t\n        # This is a simplification and needs a proper geometric or calculus-based approach\n        x1, y1 = a * np.cos(t), b * np.sin(t)\n        x2, y2 = a * np.cos(t + 2*np.pi/3), b * np.sin(t + 2*np.pi/3)\n        return np.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    \n    max_area = 0\n    for t in np.linspace(0, 2*np.pi, 10000):\n        s = side_length(t)\n        area = triangle_area(s)\n        if area > max_area:\n            max_area = area\n    \n    return max_area"}
{"task_id": 199, "completion": "def highest_Power_of_2(n):\n    # Initialize result to 1 (the smallest power of 2)\n    res = 1\n    # Loop until res*2 is less than or equal to n\n    while res * 2 <= n:\n        res *= 2\n    return res"}
{"task_id": 200, "completion": "def position_max(list1):\n    # Step 1: Find the maximum value in the list\n    max_value = max(list1)\n    \n    # Step 2: Find all indices where this maximum value occurs\n    max_indices = [index for index, value in enumerate(list1) if value == max_value]\n    \n    return max_indices"}
{"task_id": 201, "completion": "def chkList(lst):\n    # Check if the list is empty\n    if not lst:\n        return True  # An empty list can be considered as having all elements the same\n    \n    # Compare each element with the first element\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False  # Found an element that is different\n    \n    # If we reach here, all elements are the same\n    return True"}
{"task_id": 202, "completion": "def remove_even(str1):\n    # Create a new string by concatenating characters at odd indices\n    return ''.join([str1[i] for i in range(len(str1)) if i % 2 == 0])"}
{"task_id": 203, "completion": "def hamming_distance(n1, n2):\n    # XOR the two numbers to find the bits that are different\n    xor_result = n1 ^ n2\n    \n    # Count the number of bits set to 1\n    distance = 0\n    while xor_result:\n        # Increment the count if the least significant bit is 1\n        distance += xor_result & 1\n        # Right shift to check the next bit\n        xor_result >>= 1\n    \n    return distance"}
{"task_id": 204, "completion": "def count(s, c):\n    # Initialize a counter to 0\n    counter = 0\n    \n    # Loop through each character in the string\n    for char in s:\n        # If the character matches c, increment the counter\n        if char == c:\n            counter += 1\n            \n    # Return the final count\n    return counter"}
{"task_id": 205, "completion": "def count_inversions_in_tuple(a_tuple):\n    \"\"\"\n    Count inversions in a single tuple.\n    \"\"\"\n    inversions = 0\n    for i in range(len(a_tuple)):\n        for j in range(i + 1, len(a_tuple)):\n            if a_tuple[i] > a_tuple[j]:\n                inversions += 1\n    return inversions"}
{"task_id": 206, "completion": "def concatenate_elements(test_tup):\n    # Initialize an empty list to store the concatenated elements\n    concatenated_elements = []\n    \n    # Iterate through the tuple until the second last element\n    for i in range(len(test_tup) - 1):\n        # Concatenate current element with the next element\n        # Assuming the elements are strings. If not, you might need to convert them to strings\n        concatenated_element = str(test_tup[i]) + str(test_tup[i + 1])\n        \n        # Append the concatenated element to the list\n        concatenated_elements.append(concatenated_element)\n    \n    # Return the list of concatenated elements\n    return concatenated_elements"}
{"task_id": 207, "completion": "def find_longest_repeating_subseq(str):\n    n = len(str)\n    # Create and initialize DP table\n    dp = [[0 for i in range(n+1)] for j in range(n+1)]\n    \n    # Fill dp table (similar to LCS with an additional condition)\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            # If characters match and are not at the same index in the original string\n            if str[i-1] == str[j-1] and i != j:\n                dp[i][j] = 1 + dp[i-1][j-1]\n            else:\n                dp[i][j] = max(dp[i][j-1], dp[i-1][j])\n    \n    # The value in dp[n][n] is the length of the longest repeating subsequence\n    return dp[n][n]"}
{"task_id": 208, "completion": "def is_decimal(num):\n    # Define the regular expression pattern for a decimal with precision of 2\n    # This pattern matches:\n    # - Optionally a minus sign for negative numbers\n    # - At least one digit before the decimal point\n    # - A decimal point\n    # - Exactly two digits after the decimal point\n    pattern = r'^-?\\d+\\.\\d{2}$'\n    \n    # Use the fullmatch method to check if the entire string matches the pattern\n    if re.fullmatch(pattern, str(num)):\n        return True\n    else:\n        return False"}
{"task_id": 209, "completion": "def heap_replace(heap, item):\n    \"\"\"\n    Replaces the smallest element in the heap with a new item.\n\n    Parameters:\n    - heap: List[int], the heap from which the smallest element will be replaced.\n    - item: int, the new item to be inserted into the heap.\n\n    Returns:\n    - The smallest element that was removed from the heap.\n    \"\"\"\n    return heapq.heapreplace(heap, item)"}
{"task_id": 210, "completion": "import re\n\ndef is_allowed_specific_char(string):\n    # This regex pattern checks for the presence of only lowercase a-z, uppercase A-Z, and digits 0-9.\n    pattern = r'^[a-zA-Z0-9]+$'\n    \n    # The search function looks for the pattern anywhere in the string.\n    # If the pattern is found, search() returns a match object; otherwise, it returns None.\n    if re.search(pattern, string):\n        return True\n    else:\n        return False"}
{"task_id": 211, "completion": "def count_Num(n):\n    # Initialize count to 0\n    count = 0\n    \n    # The maximum number to check. Since we want the nth bit to be set,\n    # the smallest such number is 1 << n. But we start from 1 (the smallest odd number with the 0th bit set).\n    # We go up to (1 << (n + 1)) because the range in Python is exclusive at the end, and we want to include numbers where the nth bit is set.\n    max_number = 1 << (n + 1)\n    \n    # Iterate through all odd numbers up to max_number\n    for i in range(1, max_number, 2):\n        # Check if the nth bit is set\n        if i & (1 << n):\n            count += 1\n            \n    return count\n`"}
{"task_id": 212, "completion": "def fourth_power_sum_formula(n):\n    return (n * (n + 1) * (2*n + 1) * (3*n**2 + 3*n - 1)) // 30"}
{"task_id": 213, "completion": "def concatenate_strings(test_tup1, test_tup2):\n    # Concatenating the two tuples\n    result_tup = test_tup1 + test_tup2\n    return result_tup"}
{"task_id": 214, "completion": "def radian_to_degree(radian):\n    degrees = radian * (180 / math.pi)\n    return degrees"}
{"task_id": 215, "completion": "def decode_list(encoded_list):\n    \"\"\"\n    Decodes a run-length encoded list.\n    \n    Parameters:\n    encoded_list (list of tuples): A run-length encoded list where each tuple\n                                   contains (count, value).\n    \n    Returns:\n    list: The decoded list.\n    \"\"\"\n    decoded_list = []\n    for count, value in encoded_list:\n        # Extend the decoded list with `count` occurrences of `value`\n        decoded_list.extend([value] * count)\n    return decoded_list"}
{"task_id": 216, "completion": "def is_subset_list(list1, list2):\n    # Base case: If list1 is empty, it's a subset of list2\n    if not list1:\n        return True\n    \n    # Base case: If list1 is not empty but list2 is, list1 can't be a subset of list2\n    if not list2:\n        return False\n    \n    # Check if the first element of list1 is a list (nested)\n    if isinstance(list1[0], list):\n        # If the first element is a list, check for a matching subset in list2\n        for sublist in list2:\n            if isinstance(sublist, list) and is_subset_list(list1[0], sublist):\n                # If a matching subset is found, recursively check the rest of list1 with the rest of list2\n                return is_subset_list(list1[1:], list2)\n        # If no matching subset is found, return False\n        return False\n    else:\n        # If the first element of list1 is not a list, check if it's in list2\n        if list1[0] in list2:\n            # If the element is found in list2, remove it from list2 and recursively check the rest of list1\n            list2.remove(list1[0])\n            return is_subset_list(list1[1:], list2)\n        else:\n            # If the element is not found in list2, return False\n            return False"}
{"task_id": 217, "completion": "def first_Repeated_Char(s):\n    # Create an empty set to store seen characters\n    seen = set()\n    \n    # Iterate through each character in the string\n    for char in s:\n        # If the character is already in the set, it's the first repeated character\n        if char in seen:\n            return char\n        # If the character is not in the set, add it to the set\n        seen.add(char)\n    \n    # If no character is repeated, return None or an appropriate message\n    return None"}
{"task_id": 218, "completion": "def min_operations(A, B):\n    \"\"\"\n    Calculate the minimum number of operations required to make A equal to B.\n    An operation is defined as incrementing or decrementing a number by 1.\n    \n    Parameters:\n    A (int): The first number.\n    B (int): The second number.\n    \n    Returns:\n    int: The minimum number of operations required.\n    \"\"\"\n    # Calculate the absolute difference between A and B\n    return abs(A - B)"}
{"task_id": 219, "completion": "def extract_min_max(test_tup, K):\n    # First, we ensure the tuple is sorted to easily pick min and max elements\n    sorted_tup = sorted(test_tup)\n    \n    # Extracting the minimum K elements\n    min_elements = sorted_tup[:K]\n    \n    # Extracting the maximum K elements\n    # Since the tuple is sorted in ascending order, we pick the last K elements for max values\n    max_elements = sorted_tup[-K:]\n    \n    return min_elements, max_elements"}
{"task_id": 220, "completion": "def replace_max_specialchar(text, n):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    # Initialize a counter for replacements\n    replacements = 0\n    # Convert the text into a list of characters for easy manipulation\n    text_list = list(text)\n    \n    # Iterate over the list of characters\n    for i in range(len(text_list)):\n        # Check if the current character is a special character and if we haven't exceeded the replacement limit\n        if text_list[i] in special_chars and replacements < n:\n            # Replace the character with a colon\n            text_list[i] = ':'\n            # Increment the replacement counter\n            replacements += 1\n    \n    # Join the list back into a string\n    replaced_text = ''.join(text_list)\n    return replaced_text"}
{"task_id": 221, "completion": "def first_even(nums):\n    # Loop through each number in the list\n    for num in nums:\n        # Check if the number is even\n        if num % 2 == 0:\n            # Return the first even number found\n            return num\n    # Return None if no even number is found\n    return None"}
{"task_id": 222, "completion": "def check_type(test_tuple):\n    # Check if the tuple is empty\n    if not test_tuple:\n        return True  # An empty tuple can be considered as having the same type\n    \n    # Get the type of the first element\n    first_type = type(test_tuple[0])\n    \n    # Compare the type of each element with the first element's type\n    for element in test_tuple:\n        if type(element) != first_type:\n            return False  # Found an element with a different type\n    \n    # All elements have the same type\n    return True"}
{"task_id": 223, "completion": "def is_majority(arr, n, x):\n    # Find the first occurrence of x in arr\n    first_occurrence = find_first_occurrence(arr, 0, n-1, x)\n    \n    # If x is not present in arr at all\n    if first_occurrence == -1:\n        return False\n    \n    # Check if the element at index (first_occurrence + n//2) is also x\n    if (first_occurrence + n//2) < n and arr[first_occurrence + n//2] == x:\n        return True\n    else:\n        return False\n\ndef find_first_occurrence(arr, low, high, x):\n    if high >= low:\n        mid = low + (high - low) // 2\n        # If x is present at mid itself or is the first occurrence\n        if (mid == 0 or x > arr[mid-1]) and arr[mid] == x:\n            return mid\n        # If x is smaller than mid, then it can only be present in left subarray\n        elif x > arr[mid]:\n            return find_first_occurrence(arr, (mid + 1), high, x)\n        # Else the element can only be present in right subarray\n        else:\n            return find_first_occurrence(arr, low, (mid - 1), x)\n    else:\n        # Element is not present in array\n        return -1"}
{"task_id": 224, "completion": "def count_Set_Bits(n):\n    count = 0\n    while n:\n        n &= (n - 1)  # Flip the least significant bit set to 1\n        count += 1\n    return count"}
{"task_id": 225, "completion": "def find_Min(arr, low, high):\n    # If the array is not rotated at all\n    if high < low:\n        return arr[0]\n\n    # If there is only one element left\n    if high == low:\n        return arr[low]\n\n    # Find mid\n    mid = low + (high - low) // 2\n\n    # Check if element (mid+1) is the minimum element.\n    if mid < high and arr[mid+1] < arr[mid]:\n        return arr[mid + 1]\n\n    # Check if mid itself is the minimum element\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return arr[mid]\n\n    # Decide whether we need to go to the left half or the right half\n    if arr[high] > arr[mid]:\n        return find_Min(arr, low, mid-1)\n    return find_Min(arr, mid+1, high)"}
{"task_id": 226, "completion": "def odd_values_string(s):\n    # Using string slicing to select characters at even indices (0, 2, 4, ...)\n    # Remember: In Python, indexing starts at 0, so even indices represent the \"odd\" positions in common numbering.\n    return s[::2]"}
{"task_id": 227, "completion": "def min_of_three(a, b, c):\n    # Check if a is less than both b and c\n    if a <= b and a <= c:\n        return a\n    # Check if b is less than both a and c\n    elif b <= a and b <= c:\n        return b\n    # If neither a nor b is the minimum, c must be\n    else:\n        return c"}
{"task_id": 228, "completion": "def all_bits_unset_in_the_given_range(n, l, r):\n    # Create a mask with all bits set in the range [l, r]\n    mask = ((1 << (r-l+1)) - 1) << (l-1)\n    \n    # Use the mask to check the bits in the range\n    # If the result is 0, then all bits in the range are unset\n    return (n & mask) == 0"}
{"task_id": 229, "completion": "def re_arrange_array(arr, n):\n    # Initialize the index for the next position of a negative element\n    j = 0\n    for i in range(0, n):\n        # If the current element is negative, we need to swap it with\n        # the element at index j (if i != j) and increment j\n        if arr[i] < 0:\n            arr[i], arr[j] = arr[j], arr[i]\n            j += 1\n    return arr"}
{"task_id": 230, "completion": "def replace_blank(str1, char):\n    # Replace all blank spaces in str1 with the character provided in char\n    return str1.replace(' ', char)"}
{"task_id": 231, "completion": "def max_sum(tri, n):\n    \"\"\"\n    Finds the maximum sum in a given right triangle of numbers.\n\n    Parameters:\n    - tri: A list of lists where each inner list represents a row in the triangle.\n    - n: The number of rows in the triangle.\n\n    Returns:\n    - The maximum sum possible from top to bottom.\n    \"\"\"\n    # Start from the second last row and move upwards\n    for i in range(n-2, -1, -1):\n        for j in range(i+1):\n            # For each element, find the maximum of the two below it and add it to the current element\n            tri[i][j] += max(tri[i+1][j], tri[i+1][j+1])\n    \n    # The top element now contains the maximum sum\n    return tri[0][0]"}
{"task_id": 232, "completion": "import heapq\n\ndef larg_nnum(list1, n):\n    return heapq.nlargest(n, list1)"}
{"task_id": 233, "completion": "def lateral_surface_area_cylinder(r, h):\n    pi = 3.14159\n    lateral_surface_area = 2 * pi * r * h\n    return lateral_surface_area"}
{"task_id": 234, "completion": "def volume_cube(l):\n    return l**3"}
{"task_id": 235, "completion": "def even_bit_set_number(n):\n    # Calculate the number of bits in the given number\n    num_bits = n.bit_length()\n    \n    # Create a mask with all even bits set\n    # Start with 0 and set every other bit to 1\n    mask = 0\n    for i in range(0, num_bits, 2):\n        mask |= (1 << i)\n    \n    # Use bitwise OR to set all even bits in the given number\n    result = n | mask\n    \n    return result"}
{"task_id": 236, "completion": "def no_of_triangle(N, K):\n    # Ensure K is a divisor of N\n    if N % K != 0:\n        return \"K must be a divisor of N\"\n    \n    # Calculate the number of triangles\n    return (N // K) ** 2"}
{"task_id": 237, "completion": "def check_occurrences(test_list):\n    # Flatten the list of tuples\n    flattened_list = [item for sublist in test_list for item in sublist]\n    \n    # Count occurrences of each element\n    occurrences = Counter(flattened_list)\n    \n    # Group elements by their occurrence count\n    occurrence_groups = {}\n    for element, count in occurrences.items():\n        if count in occurrence_groups:\n            occurrence_groups[count].append(element)\n        else:\n            occurrence_groups[count] = [element]\n    \n    # Filter groups where more than one element has the same occurrence count\n    similar_occurrences = {count: elements for count, elements in occurrence_groups.items() if len(elements) > 1}\n    \n    return similar_occurrences\n`"}
{"task_id": 238, "completion": "def number_of_substrings(s):\n    n = len(s)\n    return n * (n + 1) // 2"}
{"task_id": 239, "completion": "def count_sequences(start, n, m):\n    # Base case: If the length of the sequence is 1, return 1\n    if n == 1:\n        return 1\n    count = 0\n    # Try to extend the sequence with each possible next element\n    for next_start in range(start * 2, m + 1):\n        count += count_sequences(next_start, n - 1, m)\n    return count"}
{"task_id": 240, "completion": "def replace_list(list1, list2):\n    # Replace the last element of list1 with all elements of list2\n    list1 = list1[:-1] + list2\n    return list1"}
{"task_id": 241, "completion": "def create_3d_array(m, n, o):\n    return [[['*' for _ in range(o)] for _ in range(n)] for _ in range(m)]"}
{"task_id": 242, "completion": "def count_charac(str1):\n    # Count the total number of characters in the string\n    total_characters = len(str1)\n    return total_characters"}
{"task_id": 243, "completion": "def sort_on_occurrence(lst):\n    # Count the occurrences of each first element\n    occurrence_count = {}\n    for item in lst:\n        if item[0] in occurrence_count:\n            occurrence_count[item[0]] += 1\n        else:\n            occurrence_count[item[0]] = 1\n    \n    # Sort the list based on the occurrence count\n    # If two elements have the same count, they are sorted based on their first element\n    sorted_lst = sorted(lst, key=lambda x: (occurrence_count[x[0]], x[0]))\n    \n    return sorted_lst"}
{"task_id": 244, "completion": "import math\n\ndef next_Perfect_Square(N):\n    # Find the square root of the given number\n    sqrt_N = math.sqrt(N)\n    \n    # If sqrt_N is not an integer, round it up to the nearest integer\n    next_int = math.ceil(sqrt_N)\n    \n    # The next perfect square is the square of the next integer\n    next_perfect_square = next_int ** 2\n    \n    return next_perfect_square"}
{"task_id": 245, "completion": "def max_sum(arr, n):\n    # Initialize two arrays for storing the maximum increasing subsequence sum (MIS)\n    # and maximum decreasing subsequence sum (MDS) for each element.\n    MIS = arr.copy()  # Maximum Increasing Subsequence sum ending at each index\n    MDS = arr.copy()  # Maximum Decreasing Subsequence sum starting at each index\n\n    # Calculate MIS for each element\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and MIS[i] < MIS[j] + arr[i]:\n                MIS[i] = MIS[j] + arr[i]\n\n    # Calculate MDS for each element\n    for i in range(n-2, -1, -1):\n        for j in range(n-1, i, -1):\n            if arr[i] > arr[j] and MDS[i] < MDS[j] + arr[i]:\n                MDS[i] = MDS[j] + arr[i]\n\n    # Find the maximum sum of MIS and MDS for each element\n    max_sum = 0\n    for i in range(n):\n        current_sum = MIS[i] + MDS[i] - arr[i]  # Subtract arr[i] since it's added twice\n        if current_sum > max_sum:\n            max_sum = current_sum\n\n    return max_sum"}
{"task_id": 246, "completion": "def babylonian_square_root(number, tolerance=1e-10):\n    if number < 0:\n        raise ValueError(\"Cannot compute the square root of a negative number.\")\n    \n    if number == 0:\n        return 0\n\n    guess = number / 2.0\n\n    while True:\n        new_guess = (guess + number / guess) / 2.0\n\n        if abs(new_guess - guess) < tolerance:\n            break\n\n        guess = new_guess\n\n    return guess"}
{"task_id": 247, "completion": "def lps(str):\n    n = len(str)\n    \n    # Create a table to store results of subproblems\n    dp = [[0 for x in range(n)] for y in range(n)]\n    \n    # Strings of length 1 are palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Build the table. The bottom-up approach is used here.\n    # cl is the length of the substring.\n    for cl in range(2, n+1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if str[i] == str[j] and cl == 2:\n                dp[i][j] = 2\n            elif str[i] == str[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n    \n    # The result is in dp[0][n-1]\n    return dp[0][n-1]"}
{"task_id": 248, "completion": "def harmonic_sum(n):\n    # Initialize the sum to 0\n    sum = 0.0\n    \n    # Loop from 1 to n-1\n    for i in range(1, n):\n        sum += 1 / i  # Add the reciprocal of i to the sum\n    \n    return sum"}
{"task_id": 249, "completion": "def intersection_array(array_nums1, array_nums2):\n    # Using filter() with a lambda function to find intersection\n    result = list(filter(lambda x: x in array_nums2, array_nums1))\n    return result"}
{"task_id": 250, "completion": "def count_X(tup, x):\n    # Count and return the number of occurrences of x in tup\n    return tup.count(x)"}
{"task_id": 251, "completion": "def insert_element(original_list, element):\n    # Initialize an empty list to store the result\n    result_list = []\n    # Iterate through each item in the original list\n    for item in original_list:\n        # Insert the specified element before the current item\n        result_list.append(element)\n        # Add the current item to the result list\n        result_list.append(item)\n    return result_list"}
{"task_id": 252, "completion": "import cmath\n\ndef convert_to_polar(complex_num):\n    \"\"\"\n    Convert a complex number to polar coordinates.\n    \n    Parameters:\n    - complex_num: A complex number (type complex).\n    \n    Returns:\n    - A tuple containing the magnitude and angle (in radians) of the complex number.\n    \"\"\"\n    polar_coordinates = cmath.polar(complex_num)\n    return polar_coordinates"}
{"task_id": 253, "completion": "def count_integer(list1):\n    # Initialize a counter to keep track of integers\n    count = 0\n    # Iterate through each element in the list\n    for element in list1:\n        # Check if the element is an instance of int\n        if isinstance(element, int):\n            # Increment the counter if the element is an integer\n            count += 1\n    # Return the total count of integers\n    return count"}
{"task_id": 254, "completion": "def words_ae(text):\n    # Split the text into words\n    words = text.split()\n    \n    # Filter words that start with 'a' or 'e'\n    ae_words = [word for word in words if word.startswith('a') or word.startswith('e')]\n    \n    return ae_words"}
{"task_id": 255, "completion": "def combinations_colors(colors, n):\n    \"\"\"\n    Generate all combinations of n colors from a given list of colors with repetitions.\n    \n    :param colors: List of available colors.\n    :param n: Number of colors to choose.\n    :return: List of tuples, each representing a combination of colors.\n    \"\"\"\n    # Use itertools.product to generate combinations with repetitions\n    combinations = list(product(colors, repeat=n))\n    \n    return combinations"}
{"task_id": 256, "completion": "def count_primes_nums(n):\n    if n <= 2:\n        return 0  # There are no prime numbers less than 2\n    \n    # Initialize a list to keep track of prime status for each number\n    # True means \"is prime\", and False means \"is not prime\".\n    # We start by assuming all numbers are prime (True), except for 0 and 1.\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # The Sieve of Eratosthenes algorithm\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            # Mark all multiples of i as not prime\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count and return the number of prime numbers found\n    return sum(is_prime)\n`"}
{"task_id": 257, "completion": "def swap_numbers(a, b):\n    # Swapping the values\n    a, b = b, a\n    return a, b"}
{"task_id": 258, "completion": "def count_odd(array_nums):\n    # Using filter() with a lambda function to filter out odd numbers\n    odd_numbers = filter(lambda x: x % 2 != 0, array_nums)\n    # Converting the filter object to a list and returning its length\n    return len(list(odd_numbers))"}
{"task_id": 259, "completion": "def maximize_elements(test_tup1, test_tup2):\n    \"\"\"\n    Function to maximize elements between two tuples.\n    It compares each element of the tuples and selects the maximum.\n    \n    :param test_tup1: First tuple for comparison.\n    :param test_tup2: Second tuple for comparison.\n    :return: A tuple containing maximum elements from both tuples.\n    \"\"\"\n    # Ensure both tuples are of the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Tuples must be of the same length\")\n    \n    # Use a generator expression to compare elements and select the maximum\n    max_tuple = tuple(max(a, b) for a, b in zip(test_tup1, test_tup2))\n    \n    return max_tuple"}
{"task_id": 260, "completion": "def newman_prime(n):\n    \"\"\"Find the nth Newman\u2013Shanks\u2013Williams prime number.\"\"\"\n    if n < 1:\n        return \"Please enter a positive integer greater than 0.\"\n    \n    S = [1, 1]  # Initial values of the sequence\n    primes_found = []\n    \n    # Generate the NSW sequence and check for primes\n    while len(primes_found) < n:\n        next_S = 2 * S[-1] + S[-2]\n        S.append(next_S)\n        \n        if is_prime(next_S):\n            primes_found.append(next_S)\n    \n    return primes_found[-1]"}
{"task_id": 261, "completion": "def division_elements(test_tup1, test_tup2):\n    \"\"\"\n    Perform element-wise division between elements of two tuples.\n\n    Parameters:\n    test_tup1 (tuple): The first tuple containing numerators.\n    test_tup2 (tuple): The second tuple containing denominators.\n\n    Returns:\n    tuple: A tuple containing the results of the division.\n    \"\"\"\n    # Check if the tuples are of the same length\n    if len(test_tup1) != len(test_tup2):\n        return \"Error: The tuples must be of the same length.\"\n    \n    # Perform division and handle division by zero\n    result = []\n    for i in range(len(test_tup1)):\n        try:\n            # Append the result of division to the result list\n            result.append(test_tup1[i] / test_tup2[i])\n        except ZeroDivisionError:\n            # Handle division by zero\n            result.append('Infinity')  # or use 'Error' or any other placeholder\n    \n    return tuple(result)"}
{"task_id": 262, "completion": "def split_two_parts(list1, L):\n    # Ensure L is not greater than the length of the list\n    if L > len(list1):\n        return \"L is greater than the length of the list\", []\n    \n    # Split the list into two parts\n    first_part = list1[:L]\n    second_part = list1[L:]\n    \n    return first_part, second_part"}
{"task_id": 263, "completion": "def merge_dict(d1, d2):\n    \"\"\"\n    Merges two dictionaries. If there are overlapping keys, values from d2 overwrite those from d1.\n\n    Parameters:\n    d1 (dict): The first dictionary.\n    d2 (dict): The second dictionary, whose values will overwrite d1's in case of overlapping keys.\n\n    Returns:\n    dict: The merged dictionary.\n    \"\"\"\n    # Python 3.5+ allows using the {**d1, **d2} syntax for merging dictionaries.\n    merged_dict = {**d1, **d2}\n    return merged_dict"}
{"task_id": 264, "completion": "def dog_age(h_age):\n    if h_age <= 0:\n        return \"Age must be a positive number.\"\n    elif h_age == 1:\n        return 15\n    elif h_age == 2:\n        return 15 + 9\n    else:\n        return 15 + 9 + (h_age - 2) * 5"}
{"task_id": 265, "completion": "def list_split(S, step):\n    # Check if the step is valid\n    if step <= 0:\n        raise ValueError(\"Step must be a positive integer\")\n    \n    # Split the list\n    return [S[i:i+step] for i in range(0, len(S), step)]"}
{"task_id": 266, "completion": "def lateral_surface_cube(l):\n    \"\"\"\n    Calculate the lateral surface area of a cube.\n\n    Parameters:\n    l (float): The length of one side of the cube.\n\n    Returns:\n    float: The lateral surface area of the cube.\n    \"\"\"\n    return 4 * l**2"}
{"task_id": 267, "completion": "def square_sum_formula(n):\n    return n * (4*n**2 - 1) // 3"}
{"task_id": 268, "completion": "def find_star_num(n):\n    return 6 * n * (n - 1) + 1"}
{"task_id": 269, "completion": "def ascii_value(char):\n    return ord(char)"}
{"task_id": 270, "completion": "def sum_even_and_even_index(arr, n):\n    # Initialize the sum to 0\n    sum_even = 0\n    \n    # Loop through the array, considering only even indices\n    for i in range(0, n, 2):  # Start from 0, go till n, step by 2\n        if arr[i] % 2 == 0:  # Check if the number at even index is even\n            sum_even += arr[i]  # Add it to the sum\n    \n    return sum_even"}
{"task_id": 271, "completion": "def even_Power_Sum(n):\n    # Initialize the sum to 0\n    sum_of_powers = 0\n    \n    # Loop through the first n even numbers\n    for i in range(1, n + 1):\n        # Calculate the even number (2 * i gives the ith even number)\n        even_number = 2 * i\n        \n        # Calculate the fifth power of the even number\n        fifth_power = even_number ** 5\n        \n        # Add the fifth power to the sum\n        sum_of_powers += fifth_power\n    \n    # Return the final sum\n    return sum_of_powers\n`"}
{"task_id": 272, "completion": "def rear_extract(test_list):\n    # Using list comprehension to extract the last element of each tuple\n    result = [item[-1] for item in test_list]\n    return result"}
{"task_id": 273, "completion": "def subtract_elements(test_tup1, test_tup2):\n    \"\"\"\n    Subtract elements of test_tup2 from test_tup1 based on their index.\n\n    Parameters:\n    test_tup1 (tuple): The first tuple.\n    test_tup2 (tuple): The second tuple to subtract from the first tuple.\n\n    Returns:\n    tuple: A new tuple with the results of the subtraction.\n    \"\"\"\n    # Ensure that both tuples have the same length to avoid IndexError\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Both tuples must have the same number of elements.\")\n\n    # Subtract elements of the second tuple from the first tuple using a tuple comprehension\n    result = tuple(a - b for a, b in zip(test_tup1, test_tup2))\n\n    return result"}
{"task_id": 274, "completion": "def even_binomial_coeff_sum(n):\n    # For n = 0, the sum is 1 since the only term is C(n, 0) = 1\n    if n == 0:\n        return 1\n    # For n > 0, the sum of even-indexed binomial coefficients\n    return 2 ** (n - 1)"}
{"task_id": 275, "completion": "def get_position(a, n, m):\n    \"\"\"\n    Find the position of the last removed element in a circular elimination process.\n    \n    :param a: The size of the initial array/list.\n    :param n: The step count for removal (e.g., every nth element is removed).\n    :param m: The position to start from in the array (1-based index).\n    :return: The original position (1-based index) of the last removed element.\n    \"\"\"\n    # Convert the starting position to 0-based index\n    m -= 1\n    \n    # Create an array to simulate the positions\n    positions = list(range(1, a + 1))\n    \n    # While more than one element remains\n    while len(positions) > 1:\n        # Calculate the index of the element to remove\n        m = (m + n - 1) % len(positions)\n        # Remove the element and store it as the last removed\n        last_removed = positions.pop(m)\n    \n    # Return the position of the last removed element\n    return last_removed"}
{"task_id": 276, "completion": "def volume_cylinder(r, h):\n    \"\"\"\n    Calculate the volume of a cylinder.\n\n    Parameters:\n    r (float): The radius of the cylinder's base.\n    h (float): The height of the cylinder.\n\n    Returns:\n    float: The volume of the cylinder.\n    \"\"\"\n    volume = math.pi * (r ** 2) * h\n    return volume"}
{"task_id": 277, "completion": "def dict_filter(input_dict, n):\n    \"\"\"\n    Filters a dictionary based on values greater than n.\n\n    Parameters:\n    input_dict (dict): The dictionary to filter.\n    n (int or float): The threshold value for filtering.\n\n    Returns:\n    dict: A new dictionary with items where values are greater than n.\n    \"\"\"\n    # Use dictionary comprehension to filter items\n    filtered_dict = {key: value for key, value in input_dict.items() if value > n}\n    return filtered_dict"}
{"task_id": 278, "completion": "def count_first_elements(test_tup):\n    # Initialize a dictionary to keep count of elements\n    element_count = {}\n    # Initialize the result list\n    result = []\n    \n    # Iterate over each sub-tuple in the given tuple\n    for sub_tup in test_tup:\n        if not sub_tup:  # Check if the sub-tuple is empty\n            result.append(0)\n            continue\n        # Get the first element of the sub-tuple\n        first_element = sub_tup[0]\n        # Count the occurrence of the first element before the current position\n        # If the element is not in the dictionary, get method returns 0\n        result.append(element_count.get(first_element, 0))\n        # Update the count of the first element in the dictionary\n        element_count[first_element] = element_count.get(first_element, 0) + 1\n    \n    return result"}
{"task_id": 279, "completion": "def is_num_decagonal(n):\n    # Calculate the nth decagonal number using the formula\n    decagonal_number = 4*n**2 - 3*n\n    return decagonal_number"}
{"task_id": 280, "completion": "def sequential_search(dlist, item):\n    \"\"\"\n    This function searches for an item in dlist using a sequential search algorithm.\n    :param dlist: List where the search is to be performed.\n    :param item: The item to search for in the dlist.\n    :return: Boolean value indicating if the item was found.\n    \"\"\"\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return True  # Item found\n    return False  # Item not found"}
{"task_id": 281, "completion": "def all_unique(test_list):\n    # Convert the list into a set\n    # Sets contain only unique elements\n    test_set = set(test_list)\n    \n    # Compare the length of the original list and the set\n    # If lengths are equal, all elements were unique\n    return len(test_list) == len(test_set)"}
{"task_id": 282, "completion": "def sub_list(nums1, nums2):\n    # Using map and lambda to subtract elements of the two lists\n    result = list(map(lambda x, y: x - y, nums1, nums2))\n    return result"}
{"task_id": 283, "completion": "def validate(n):\n    # Convert the number to a string\n    n_str = str(n)\n    \n    # Initialize a dictionary to keep track of digit frequencies\n    digit_freq = {}\n    \n    # Iterate through each digit in the string\n    for digit in n_str:\n        # Update the frequency of the current digit\n        if digit in digit_freq:\n            digit_freq[digit] += 1\n        else:\n            digit_freq[digit] = 1\n    \n    # Check if the frequency of each digit is less than or equal to the digit itself\n    for digit, freq in digit_freq.items():\n        if freq > int(digit):\n            return False\n    \n    return True"}
{"task_id": 284, "completion": "def check_element(lst, element):\n    # Iterate through each item in the list\n    for item in lst:\n        # If an item is not equal to the given element, return False\n        if item != element:\n            return False\n    # If the loop completes without returning False, all items match the element\n    return True"}
{"task_id": 285, "completion": "import re\n\ndef text_match_two_three(text):\n    pattern = 'ab{2,3}'\n    match = re.search(pattern, text)\n    if match:\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\""}
{"task_id": 286, "completion": "def max_sub_array_sum_repeated(a, n, k):\n    max_kadane = kadane_algorithm(a)\n    if k == 1:\n        return max_kadane\n    \n    array_sum = sum(a)\n    max_prefix = max_prefix_sum(a)\n    max_suffix = max_suffix_sum(a)\n    \n    if array_sum > 0:\n        return max(max_kadane, max_prefix + max_suffix + (array_sum * (k-2)))\n    else:\n        return max(max_kadane, max_prefix + max_suffix)"}
{"task_id": 287, "completion": "def square_sum(n):\n    # Initialize sum\n    sum_of_squares = 0\n    \n    # Loop through the first n even natural numbers\n    for i in range(1, n + 1):\n        # The ith even number is 2*i\n        even_number = 2 * i\n        # Square the even number and add it to the sum\n        sum_of_squares += even_number ** 2\n    \n    return sum_of_squares"}
{"task_id": 288, "completion": "def modular_inverse_count(arr, P):\n    # Function to count elements equal to their modular inverse under prime P\n    count = 0\n    for a in arr:\n        if a % P == 0:  # Skip elements divisible by P (no inverse)\n            continue\n        # Check if the element is equal to its modular inverse\n        if (a * a) % P == 1:\n            count += 1\n    return count"}
{"task_id": 289, "completion": "def odd_days(year):\n    \"\"\"\n    Calculate the number of odd days in a given year.\n    \"\"\"\n    if is_leap_year(year):\n        # Leap year has 366 days\n        days = 366\n    else:\n        # Non-leap year has 365 days\n        days = 365\n    \n    # The number of odd days is the remainder when days are divided by 7\n    odd_days = days % 7\n    return odd_days"}
{"task_id": 290, "completion": "def max_length_lists(list_of_lists):\n    # First, find the maximum length of the lists\n    max_length = max(len(lst) for lst in list_of_lists)\n    \n    # Now, find all lists that have this maximum length\n    max_length_lists = [lst for lst in list_of_lists if len(lst) == max_length]\n    \n    return max_length_lists"}
{"task_id": 291, "completion": "def count_no_of_ways(n, k):\n    if n == 0:  # No fence to paint\n        return 0\n    elif n == 1:  # Only one way to paint a single post\n        return k\n    else:\n        # For the first post\n        same = k\n        diff = k * (k-1)\n        \n        # For the rest of the posts\n        for i in range(3, n + 1):\n            # The new 'same' is the previous 'diff'\n            new_same = diff\n            # The new 'diff' is the total ways of the previous post times (k-1)\n            new_diff = (same + diff) * (k-1)\n            \n            # Update 'same' and 'diff' for the next iteration\n            same = new_same\n            diff = new_diff\n        \n        # The total ways is the sum of the last 'same' and 'diff'\n        return same + diff\n`"}
{"task_id": 292, "completion": "def find(n, m):\n    # Check if m is not zero to avoid division by zero error\n    if m == 0:\n        return \"Error: Cannot divide by zero\"\n    else:\n        # Calculate and return the quotient\n        quotient = n / m\n        return quotient"}
{"task_id": 293, "completion": "import math\n\ndef otherside_rightangle(w, h):\n    \"\"\"\n    Calculate the length of the unknown side of a right-angled triangle.\n    \n    Parameters:\n    w (float): The length of one side. This is assumed to be the hypotenuse if it's the longest side.\n    h (float): The length of the other side.\n    \n    Returns:\n    float: The length of the unknown side.\n    \"\"\"\n    if w < h:\n        # If w is less than h, it means w is not the hypotenuse, so swap them.\n        w, h = h, w\n    \n    if w**2 == h**2:  # This condition checks if both sides are equal, which is not possible in a right-angled triangle.\n        return \"Invalid input: Both sides cannot be equal in a right-angled triangle.\"\n    \n    if w**2 > h**2:\n        # If w is the hypotenuse, calculate the other side.\n        return math.sqrt(w**2 - h**2)\n    else:\n        # If w is not the hypotenuse, calculate the hypotenuse.\n        return math.sqrt(w**2 + h**2)\n`"}
{"task_id": 294, "completion": "def max_val(listval):\n    # Initialize max_value to None; this will help handle an empty list or a list without any numeric values\n    max_value = None\n    \n    for item in listval:\n        # Check if the item is an instance of int or float\n        if isinstance(item, (int, float)):\n            # If max_value is None, it means this is the first numeric value we've found\n            if max_value is None:\n                max_value = item\n            # If the current item is greater than max_value, update max_value\n            elif item > max_value:\n                max_value = item\n    \n    # Return the maximum numeric value found; returns None if no numeric value was found\n    return max_value\n`"}
{"task_id": 295, "completion": "def sum_div(number):\n    # Initialize the sum of divisors to 0\n    sum_of_divisors = 0\n    \n    # Loop through all possible divisors from 1 to the number\n    for i in range(1, number + 1):\n        # If 'i' is a divisor of 'number', add it to the sum\n        if number % i == 0:\n            sum_of_divisors += i\n            \n    return sum_of_divisors"}
{"task_id": 296, "completion": "def get_Inv_Count(arr, n):\n    temp_arr = [0]*n\n    return mergeSort(arr, temp_arr, 0, n-1)"}
{"task_id": 297, "completion": "def flatten_list(nested_list):\n    # This will hold the flattened list\n    flattened_list = []\n    \n    # Loop through each item in the current list\n    for item in nested_list:\n        # If the item is a list, extend the flattened list with the result of a recursive call\n        if isinstance(item, list):\n            flattened_list.extend(flatten_list(item))\n        else:\n            # If the item is not a list, append it directly to the flattened list\n            flattened_list.append(item)\n    \n    return flattened_list"}
{"task_id": 298, "completion": "def intersection_nested_lists(l1, l2):\n    def flatten_list(l):\n        \"\"\"Flatten a nested list into a single list of elements.\"\"\"\n        flat_list = []\n        for item in l:\n            if isinstance(item, list):\n                flat_list.extend(flatten_list(item))\n            else:\n                flat_list.append(item)\n        return flat_list\n\n    def intersect_flattened(flat_l1, l2):\n        \"\"\"Find the intersection of a flattened list with another list, preserving the structure of the second list.\"\"\"\n        result = []\n        for item in l2:\n            if isinstance(item, list):\n                nested_result = intersect_flattened(flat_l1, item)\n                if nested_result:\n                    result.append(nested_result)\n            elif item in flat_l1:\n                result.append(item)\n        return result\n\n    flat_l1 = flatten_list(l1)\n    return intersect_flattened(flat_l1, l2)"}
{"task_id": 299, "completion": "def max_aggregate(stdata):\n    # Check if the input list is not empty\n    if not stdata:\n        return \"The list is empty\"\n    \n    # Calculate the sum of each tuple using a list comprehension\n    # and find the maximum value among those sums\n    max_sum = max([sum(tup) for tup in stdata])\n    \n    return max_sum"}
{"task_id": 300, "completion": "def count_binary_seq(n):\n    \"\"\"Count binary sequences of length 2n with equal sum in both halves.\"\"\"\n    count = 0\n    for k in range(n + 1):\n        count += binomial_coefficient(n, k) ** 2\n    return count"}
{"task_id": 301, "completion": "def dict_depth(d):\n    \"\"\"\n    Function to find the depth of a dictionary.\n    \n    Parameters:\n    d (dict): The dictionary whose depth is to be found.\n    \n    Returns:\n    int: The depth of the dictionary.\n    \"\"\"\n    if isinstance(d, dict):\n        if d:\n            return 1 + max(dict_depth(value) for value in d.values())\n        return 1\n    else:\n        return 0"}
{"task_id": 302, "completion": "def set_Bit_Number(n):\n    # Initialize position\n    position = 0\n    \n    # Loop until n becomes 0\n    while n != 0:\n        # Increment position\n        position += 1\n        \n        # Right shift n by 1\n        n = n >> 1\n    \n    # Return the most significant set bit number\n    # Use 1 << (position - 1) to get the value of the bit at that position\n    return 1 << (position - 1)"}
{"task_id": 303, "completion": "def count_inversions(arr):\n    def merge_count(arr):\n        if len(arr) <= 1:\n            return arr, 0, 0\n        else:\n            mid = len(arr) // 2\n            left, left_inv, left_inv_double = merge_count(arr[:mid])\n            right, right_inv, right_inv_double = merge_count(arr[mid:])\n            merged, count, count_double = merge(left, right)\n            return merged, left_inv + right_inv + count, left_inv_double + right_inv_double + count_double\n\n    def merge(left, right):\n        result = []\n        count = 0\n        count_double = 0\n        i, j = 0, 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                count += len(left) - i  # Type 1 Inversion\n                if left[i] > 2 * right[j]:  # Type 2 Inversion\n                    count_double += len(left) - i\n                j += 1\n        result += left[i:]\n        result += right[j:]\n        return result, count, count_double\n\n    _, type1_inversions, type2_inversions = merge_count(arr)\n    return type1_inversions == type2_inversions"}
{"task_id": 304, "completion": "def find_Element(arr, ranges, rotations, index):\n    # For each rotation in reverse order\n    for _ in range(rotations):\n        for start, end in reversed(ranges):\n            # Check if the index is within the current rotation range\n            if start <= index <= end:\n                # If the index is not the start of the range, move it to the left\n                if index > start:\n                    index -= 1\n                # If the index is at the start of the range, move it to the end\n                else:\n                    index = end\n    # Return the element at the final index\n    return arr[index]"}
{"task_id": 305, "completion": "def start_withp(words):\n    # Initialize an empty list to hold words starting with 'p'\n    p_words = []\n    \n    # Loop through each word in the input list\n    for word in words:\n        # Check if the word starts with 'p'\n        if word.lower().startswith('p'):\n            p_words.append(word)\n            # If we have found 2 words starting with 'p', break the loop\n            if len(p_words) == 2:\n                break\n    \n    # Return the list of words starting with 'p'\n    return p_words"}
{"task_id": 306, "completion": "def max_sum_increasing_subseq(a, n, index, k):\n    # DP array to store the maximum sum of increasing subsequence till each index\n    dp = [0] * n\n    \n    # Base case: The maximum sum of increasing subsequence ending with the first element is the element itself\n    dp[0] = a[0]\n    \n    # Fill dp array\n    for i in range(1, n):\n        for j in range(i):\n            # Update dp[i] if it's an increasing subsequence and sum is greater\n            if a[i] > a[j] and dp[i] < dp[j] + a[i]:\n                dp[i] = dp[j] + a[i]\n        # If no increasing subsequence is found, the subsequence consists of the element itself\n        if dp[i] == 0:\n            dp[i] = a[i]\n    \n    # Now, find the maximum sum of increasing subsequence from prefix till 'index'\n    # and also including 'k'th element\n    max_sum = 0\n    for i in range(index + 1):\n        # Ensure that including kth element keeps the sequence increasing\n        if i == index or a[k] > a[i]:\n            max_sum = max(max_sum, dp[i] + a[k])\n    \n    return max_sum"}
{"task_id": 307, "completion": "def colon_tuplex(tuplex, m, n):\n    \"\"\"\n    Extracts a slice from the tuple from index m to n-1.\n    \n    Parameters:\n    - tuplex: The original tuple.\n    - m: The starting index of the slice.\n    - n: The ending index of the slice (exclusive).\n    \n    Returns:\n    A tuple containing the elements from index m to n-1 of the original tuple.\n    \"\"\"\n    # Ensure m and n are within bounds and correct if not\n    m = max(m, 0)  # Ensure m is not less than 0\n    n = min(n, len(tuplex))  # Ensure n does not exceed the length of the tuple\n    \n    # Return the sliced tuple\n    return tuplex[m:n]\n`"}
{"task_id": 308, "completion": "import heapq\n\ndef large_product(nums1, nums2, N):\n    # Sort both lists in descending order\n    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    \n    # Use a max heap to keep track of the largest products\n    # Python's heapq is a min heap, so we'll store negative values to simulate a max heap\n    max_heap = []\n    heapq.heapify(max_heap)\n    \n    # A set to keep track of indices combinations we have already visited\n    visited = set()\n    \n    # Push the product of the largest elements along with their indices to the heap\n    heapq.heappush(max_heap, (-(nums1[0] * nums2[0]), 0, 0))\n    visited.add((0, 0))\n    \n    # Result list to store the top N products\n    result = []\n    \n    # Extract the largest elements from the heap N times\n    while N > 0 and max_heap:\n        product, i, j = heapq.heappop(max_heap)\n        result.append(-product)  # Convert back to positive before appending\n        \n        # Try to push the next product in the same row, if not already visited\n        if (i + 1, j) not in visited and i + 1 < len(nums1):\n            heapq.heappush(max_heap, (-(nums1[i + 1] * nums2[j]), i + 1, j))\n            visited.add((i + 1, j))\n        \n        # Try to push the next product in the same column, if not already visited\n        if (i, j + 1) not in visited and j + 1 < len(nums2):\n            heapq.heappush(max_heap, (-(nums1[i] * nums2[j + 1]), i, j + 1))\n            visited.add((i, j + 1))\n        \n        N -= 1\n    \n    return result"}
{"task_id": 309, "completion": "def maximum(a, b):\n    if a > b:\n        return a\n    else:\n        return b"}
{"task_id": 310, "completion": "def string_to_tuple(str1):\n    return tuple(str1)"}
{"task_id": 311, "completion": "def set_left_most_unset_bit(n):\n    # Special case: If n is 0, return 1 since the left-most unset bit is the least significant bit\n    if n == 0:\n        return 1\n    \n    # Step 1: Find the left-most unset bit\n    # Create a mask starting with the most significant bit set\n    mask = 1 << (n.bit_length() - 1)\n    \n    # Move the mask to the right until we find the left-most unset bit\n    while mask & n:\n        mask >>= 1\n    \n    # Step 2: Set the left-most unset bit\n    # If all bits are set, we need to add a bit at the left-most position\n    if mask == 0:\n        return n | (1 << n.bit_length())\n    else:\n        return n | mask\n`"}
{"task_id": 312, "completion": "def volume_cone(r, h):\n    # Calculate the volume using the formula\n    volume = (1/3) * math.pi * r**2 * h\n    return volume"}
{"task_id": 313, "completion": "def pos_nos(list1):\n    # Loop through each number in the list\n    for num in list1:\n        # Check if the number is positive\n        if num > 0:\n            print(num)"}
{"task_id": 314, "completion": "def max_sum_rectangular_grid(grid, n):\n    # Initialize dp array to store the maximum sum until the current column\n    # dp[i] will store the maximum sum we can achieve by considering columns up to the i-th one\n    dp = [0] * (n + 1)\n    \n    # Base case: When there are no columns, the maximum sum is 0\n    dp[0] = 0\n    \n    # If there's at least one column, initialize the first column\n    if n > 0:\n        dp[1] = max(grid[0][0], grid[1][0])\n    \n    # Iterate through the grid starting from the second column\n    for i in range(2, n + 1):\n        # Case 1: Take both numbers from the current column\n        take_both = grid[0][i-1] + grid[1][i-1]\n        \n        # Case 2: Take the maximum of one number from the current column\n        take_one = max(grid[0][i-1], grid[1][i-1])\n        \n        # Update the dp array for the i-th column by considering the maximum sum we can achieve:\n        # 1. By taking the maximum sum until the (i-2)-th column and adding the sum of taking both numbers from the current column\n        # 2. By taking the maximum sum until the (i-1)-th column (effectively skipping the current column)\n        # 3. By taking the maximum sum until the (i-2)-th column and adding the maximum of taking one number from the current column\n        dp[i] = max(dp[i-2] + take_both, dp[i-1], dp[i-2] + take_one)\n    \n    # The maximum sum we can achieve is stored in dp[n]\n    return dp[n]\n`"}
{"task_id": 315, "completion": "def find_Max_Len_Even(input_str):\n    # Split the input string into words\n    words = input_str.split()\n    \n    # Initialize variables to keep track of the maximum even length word\n    max_even_len_word = \"\"\n    max_len = 0\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Check if the length of the word is even and greater than the current max length\n        if len(word) % 2 == 0 and len(word) > max_len:\n            # Update the maximum length and the word\n            max_len = len(word)\n            max_even_len_word = word\n            \n    # Return the word with the maximum even length\n    return max_even_len_word\n`"}
{"task_id": 316, "completion": "def find_last_occurrence(A, x):\n    left, right = 0, len(A) - 1\n    result = -1  # Initialize result to -1 to indicate not found by default\n    \n    while left <= right:\n        mid = left + (right - left) // 2  # Find the middle index\n        \n        if x == A[mid]:\n            result = mid  # Update result because we found x\n            left = mid + 1  # Move to the right half to find the last occurrence\n        elif x < A[mid]:\n            right = mid - 1  # Move to the left half\n        else:\n            left = mid + 1  # Move to the right half\n    \n    return result"}
{"task_id": 317, "completion": "def modified_encode(alist):\n    # This function performs modified run-length encoding.\n    if not alist:\n        return []\n\n    # Initialize the list to store the result\n    encoded_list = []\n    \n    # Initialize the current element and its count\n    current_element = alist[0]\n    count = 1\n    \n    # Iterate over the list starting from the second element\n    for element in alist[1:]:\n        if element == current_element:\n            # If the current element is the same as the previous, increment the count\n            count += 1\n        else:\n            # If the current element is different, append the previous element (and its count if > 1) to the result\n            if count > 1:\n                encoded_list.append((count, current_element))\n            else:\n                encoded_list.append(current_element)\n            # Reset the current element and count\n            current_element = element\n            count = 1\n    \n    # Append the last element (or its count) to the result\n    if count > 1:\n        encoded_list.append((count, current_element))\n    else:\n        encoded_list.append(current_element)\n    \n    return encoded_list"}
{"task_id": 318, "completion": "def max_volume(s):\n    # Each side of the cuboid should be one-third of the average of the sum of sides divided by 4\n    side_length = s / 12\n    # The volume of the cuboid is the cube of the side length\n    volume = side_length ** 3\n    return volume"}
{"task_id": 319, "completion": "import re\n\ndef find_long_word(text):\n    # Regular expression to find words that are exactly 5 characters long\n    pattern = r'\\b\\w{5}\\b'\n    \n    # Find all matches in the text\n    matches = re.findall(pattern, text)\n    \n    return matches"}
{"task_id": 320, "completion": "def sum_difference(n):\n    # Calculate the sum of the first n natural numbers\n    sum_n = n * (n + 1) // 2\n    # Calculate the sum of the squares of the first n natural numbers\n    sum_squares = n * (n + 1) * (2 * n + 1) // 6\n    # Calculate the difference\n    difference = sum_n**2 - sum_squares\n    return difference"}
{"task_id": 321, "completion": "def find_demlo(n):\n    \"\"\"\n    Function to find the Demlo number for a given number of 1's.\n    :param n: Number of 1's\n    :return: Demlo number for the given n\n    \"\"\"\n    # Generate the number consisting of n 1's\n    number = int(\"1\" * n)\n    \n    # Calculate the Demlo number by squaring the number\n    demlo_number = number ** 2\n    \n    return demlo_number"}
{"task_id": 322, "completion": "def position_min(list1):\n    # Step 1: Find the minimum value in the list\n    min_value = min(list1)\n    \n    # Step 2: Find all indices where this minimum value occurs\n    min_indices = [index for index, value in enumerate(list1) if value == min_value]\n    \n    return min_indices"}
{"task_id": 323, "completion": "def right_rotate(arr, n, out_of_place, cur):\n    # Store the out-of-place element\n    tmp = arr[cur]\n    # Shift elements to the right up to the current position\n    for i in range(cur, out_of_place, -1):\n        arr[i] = arr[i - 1]\n    # Place the out-of-place element in its correct position\n    arr[out_of_place] = tmp\n    return arr\n\ndef rearrange(arr):\n    n = len(arr)\n    out_of_place = -1\n    for index in range(n):\n        if out_of_place >= 0:\n            # Check if the element at index is a positive element and the out_of_place is a negative element or vice versa\n            if (arr[index] >= 0 and arr[out_of_place] < 0) or (arr[index] < 0 and arr[out_of_place] >= 0):\n                # Right rotate the array from out_of_place index to the current index\n                arr = right_rotate(arr, n, out_of_place, index)\n                # If the distance between out_of_place and the current index is more than 2, move out_of_place 2 steps ahead\n                if index - out_of_place >= 2:\n                    out_of_place += 2\n                else:\n                    out_of_place = -1\n        # Find the first out of place element\n        if out_of_place == -1:\n            if (arr[index] >= 0 and index % 2 == 0) or (arr[index] < 0 and index % 2 == 1):\n                out_of_place = index\n    return arr"}
{"task_id": 324, "completion": "def sum_of_alternates(test_tuple):\n    # Sum of elements at odd positions (1st, 3rd, 5th, ...)\n    sum_odd = sum(test_tuple[::2])\n    # Sum of elements at even positions (2nd, 4th, 6th, ...)\n    sum_even = sum(test_tuple[1::2])\n    \n    return sum_odd, sum_even"}
{"task_id": 325, "completion": "def get_Min_Squares(n):\n    # Create a dynamic programming array to store the minimum squares for each number up to n\n    dp = [float('inf')] * (n + 1)\n    \n    # Base case: 0 can only be represented as the sum of 0 squares\n    dp[0] = 0\n    \n    # Fill dp array\n    for i in range(1, n + 1):\n        j = 1\n        while j*j <= i:\n            dp[i] = min(dp[i], dp[i - j*j] + 1)\n            j += 1\n    return dp[n]"}
{"task_id": 326, "completion": "def most_occurrences(test_list):\n    # Create a dictionary to store the frequency of each word\n    word_count = {}\n    \n    # Iterate over each string in the list\n    for string in test_list:\n        # Split the string into words\n        words = string.split()\n        # Count the occurrences of each word\n        for word in words:\n            if word in word_count:\n                word_count[word] += 1\n            else:\n                word_count[word] = 1\n    \n    # Find the word with the maximum frequency\n    max_occurrence = max(word_count.values())\n    for word, count in word_count.items():\n        if count == max_occurrence:\n            return word  # Return the first word found with the maximum frequency\n`"}
{"task_id": 327, "completion": "def check_isosceles(x, y, z):\n    # Check if at least two sides are equal\n    if x == y or y == z or z == x:\n        print(\"The triangle is isosceles.\")\n    else:\n        print(\"The triangle is not isosceles.\")"}
{"task_id": 328, "completion": "def rotate_left(list1, m, n):\n    # Ensure n does not exceed the length of the list\n    n = min(n, len(list1))\n    \n    # Perform the rotation on the first n elements\n    rotated_part = list1[:n][m % n:] + list1[:n][:m % n]\n    \n    # Combine the rotated part with the rest of the list (if any)\n    result = rotated_part + list1[n:]\n    \n    return result"}
{"task_id": 329, "completion": "def neg_count(lst):\n    # Initialize a counter for negative numbers\n    neg_numbers_count = 0\n    \n    # Loop through each element in the list\n    for num in lst:\n        # Check if the current element is a negative number\n        if num < 0:\n            # Increment the counter if a negative number is found\n            neg_numbers_count += 1\n            \n    # Return the total count of negative numbers\n    return neg_numbers_count"}
{"task_id": 330, "completion": "import re\n\ndef find_char(text):\n    # Define the regex pattern to find words of 3 to 5 characters\n    pattern = r'\\b\\w{3,5}\\b'\n    \n    # Use re.findall() to find all matches in the text\n    matches = re.findall(pattern, text)\n    \n    return matches"}
{"task_id": 331, "completion": "def count_unset_bits(n):\n    # Convert the number to its binary representation and remove the '0b' prefix\n    binary_representation = bin(n)[2:]\n    # Count the number of '0's in the binary representation\n    count_of_unset_bits = binary_representation.count('0')\n    return count_of_unset_bits"}
{"task_id": 332, "completion": "def char_frequency(str1):\n    # Initialize an empty dictionary to store character frequencies\n    freq = {}\n    # Loop through each character in the string\n    for char in str1:\n        # If the character is already in the dictionary, increment its count\n        if char in freq:\n            freq[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            freq[char] = 1\n    return freq"}
{"task_id": 333, "completion": "def sort_sublists_by_second_element(sub_li):\n    # Sort the list in place using the second element of each sublist\n    sub_li.sort(key=lambda x: x[1])\n    return sub_li"}
{"task_id": 334, "completion": "def check_validity(a, b, c):\n    # Check if the sum of any two sides is greater than the third side\n    if (a + b > c) and (a + c > b) and (b + c > a):\n        return True  # The triangle is valid\n    else:\n        return False  # The triangle is not valid"}
{"task_id": 335, "completion": "def ap_sum(a, n, d):\n    \"\"\"\n    Calculate the sum of the first n terms of an arithmetic progression.\n\n    Parameters:\n    a (int or float): The first term of the arithmetic progression.\n    n (int): The number of terms to sum.\n    d (int or float): The common difference between terms.\n\n    Returns:\n    int or float: The sum of the first n terms.\n    \"\"\"\n    return n / 2 * (2 * a + (n - 1) * d)"}
{"task_id": 336, "completion": "def check_monthnum(monthname):\n    # Normalize the month name to lowercase to make the function case-insensitive\n    monthname = monthname.lower()\n    \n    # Check if the month is February\n    if monthname == \"february\":\n        return True  # February has 28 days in common years\n    else:\n        return False  # Other months do not have 28 days"}
{"task_id": 337, "completion": "import re\n\ndef text_match_word(text, word):\n    \"\"\"\n    Matches a word at the end of a string, considering optional punctuation.\n    \n    Args:\n    text (str): The string to search in.\n    word (str): The word to match at the end of the string.\n    \n    Returns:\n    bool: True if the word matches at the end of the string, False otherwise.\n    \"\"\"\n    # Define a regular expression pattern to match the word at the end of the string,\n    # followed by optional punctuation and optional whitespace.\n    pattern = r'\\b' + re.escape(word) + r'\\b[\\.\\!\\?\\,\\;\\:]*\\s*$'\n    \n    # Use re.search to find the pattern in the text.\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n`"}
{"task_id": 338, "completion": "def check_equality(s):\n    # Initialize a counter to keep track of substrings\n    count = 0\n    \n    # Get the length of the string\n    n = len(s)\n    \n    # Iterate through the string to get all possible substrings\n    for i in range(n):\n        for j in range(i, n):\n            # Check if the first and last characters of the substring are the same\n            if s[i] == s[j]:\n                # Increment the counter\n                count += 1\n                \n    return count"}
{"task_id": 339, "completion": "def find_Divisor(x, y):\n    # Function to find all divisors of a given number\n    def find_divisors(n):\n        divisors = []\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:\n                    divisors.append(n // i)\n        return divisors\n    \n    # Dictionary to keep track of divisor counts\n    divisor_counts = {}\n    \n    # Iterate through the interval\n    for num in range(x, y + 1):\n        divisors = find_divisors(num)\n        for divisor in divisors:\n            if divisor in divisor_counts:\n                divisor_counts[divisor] += 1\n            else:\n                divisor_counts[divisor] = 1\n    \n    # Find the divisor with the maximum occurrence\n    max_occurrence = 0\n    max_divisor = None\n    for divisor, count in divisor_counts.items():\n        if count > max_occurrence:\n            max_occurrence = count\n            max_divisor = divisor\n    \n    return max_divisor"}
{"task_id": 340, "completion": "def sum_three_smallest_nums(lst):\n    # Filter the list to include only positive numbers\n    positive_nums = [num for num in lst if num > 0]\n    \n    # Sort the list of positive numbers\n    sorted_positive_nums = sorted(positive_nums)\n    \n    # Sum the first three elements of the sorted list\n    # If there are less than three positive numbers, it sums whatever is available\n    return sum(sorted_positive_nums[:3])"}
{"task_id": 341, "completion": "def set_to_tuple(s):\n    # Step 1: Sort the set. The sorted() function returns a list of sorted elements.\n    sorted_list = sorted(s)\n    \n    # Step 2: Convert the sorted list into a tuple.\n    ordered_tuple = tuple(sorted_list)\n    \n    return ordered_tuple"}
{"task_id": 342, "completion": "def smallestRange(nums):\n    # Initialize the min heap. The heap will store tuples of (value, list index, element index)\n    min_heap = []\n    # Initialize the range to be the maximum possible range\n    current_max = float('-inf')\n    for i in range(len(nums)):\n        # Push the first element of each list along with the list index and element index\n        heapq.heappush(min_heap, (nums[i][0], i, 0))\n        # Update the current maximum element\n        current_max = max(current_max, nums[i][0])\n    \n    # Initialize the best range to the maximum possible range initially\n    best_range = [float('-inf'), float('inf')]\n    \n    while min_heap:\n        # Pop the minimum element from the heap\n        current_min, list_idx, elem_idx = heapq.heappop(min_heap)\n        \n        # If the current range is smaller than the best range, update the best range\n        if current_max - current_min < best_range[1] - best_range[0]:\n            best_range = [current_min, current_max]\n        \n        # If we have reached the end of one of the lists, we cannot include at least one element from each list anymore\n        if elem_idx + 1 == len(nums[list_idx]):\n            return best_range\n        \n        # Push the next element from the same list into the heap\n        next_elem = nums[list_idx][elem_idx + 1]\n        heapq.heappush(min_heap, (next_elem, list_idx, elem_idx + 1))\n        # Update the current maximum element if necessary\n        current_max = max(current_max, next_elem)\n    \n    return best_range"}
{"task_id": 343, "completion": "def dig_let(s):\n    # Initialize counters for digits and letters\n    digit_count = 0\n    letter_count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            digit_count += 1\n        # Check if the character is a letter\n        elif char.isalpha():\n            letter_count += 1\n    \n    # Return a tuple with the counts of digits and letters\n    return (digit_count, letter_count)"}
{"task_id": 344, "completion": "import math\n\ndef count_Odd_Squares(n, m):\n    # Find the square root of the start and end of the range\n    sqrt_n = math.ceil(math.sqrt(n))  # Use ceil to find the next integer if sqrt(n) is not an integer\n    sqrt_m = math.floor(math.sqrt(m))  # Use floor to find the previous integer if sqrt(m) is not an integer\n    \n    # The number of elements with odd factors is the count of perfect squares in the range\n    # which is the difference between sqrt_m and sqrt_n, plus 1 (to include both ends)\n    return sqrt_m - sqrt_n + 1\n`"}
{"task_id": 345, "completion": "def diff_consecutivenums(nums):\n    # Initialize an empty list to store the differences\n    differences = []\n    # Loop through the list, except for the last element\n    for i in range(len(nums) - 1):\n        # Calculate the difference between consecutive numbers and add it to the list\n        differences.append(nums[i+1] - nums[i])\n    return differences"}
{"task_id": 346, "completion": "def entringer_number(n, k):\n    # Base case: e(n, 0) = 1 if n == 0, else 0\n    if k == 0:\n        return int(n == 0)\n    # Base case: e(n, k) = 0 if k > n\n    if k > n:\n        return 0\n    # Recursive formula: e(n, k) = e(n, k-1) + e(n-1, n-k)\n    return entringer_number(n, k-1) + entringer_number(n-1, n-k)"}
{"task_id": 347, "completion": "def count_squares(m, n):\n    # Initialize count of squares\n    count = 0\n    \n    # Loop through each possible square size\n    for side in range(1, min(m, n) + 1):\n        # Count how many squares of this size fit in the rectangle\n        count += (m - side + 1) * (n - side + 1)\n    \n    return count"}
{"task_id": 348, "completion": "def bin_coff(values, n):\n    # Maximum possible sum assuming all values are positive.\n    # This is used to define the size of our DP table.\n    # You might need to adjust this based on the problem constraints or calculate it based on the input.\n    max_sum = n * max(values)\n    \n    # Initialize the DP table.\n    # dp[i][j] will store the number of ways to form a sequence of length i with a prefix sum of j.\n    dp = [[0] * (max_sum + 1) for _ in range(n + 1)]\n    \n    # Base case: There's 1 way to form a sequence of length 0 with a prefix sum of 0.\n    dp[0][0] = 1\n    \n    # Fill the DP table.\n    for i in range(1, n + 1):\n        for j in range(max_sum + 1):\n            for value in values:\n                if j - value >= 0:\n                    dp[i][j] += dp[i - 1][j - value]\n    \n    # Sum up the ways to form sequences of length n with all non-negative prefix sums.\n    result = sum(dp[n][:max_sum + 1])\n    \n    return result"}
{"task_id": 349, "completion": "def check_binary_string(s):\n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is not '0' or '1'\n        if char not in ('0', '1'):\n            # If a character is not '0' or '1', return False\n            return False\n    # If the loop completes without returning False, return True\n    return True"}
{"task_id": 350, "completion": "def minimum_length(s):\n    # Count the frequency of each character in the string\n    from collections import Counter\n    char_count = Counter(s)\n    \n    # Find the character whose removal will minimize the string length\n    # This is equivalent to finding the character with the maximum frequency\n    max_freq = max(char_count.values())\n    \n    # Calculate the minimum length after removing the character with the maximum frequency\n    min_length_after_removal = len(s) - max_freq\n    \n    return min_length_after_removal"}
{"task_id": 351, "completion": "def first_Element(arr, n, k):\n    # Create a dictionary to store the count of each element\n    element_count = {}\n    \n    # Iterate through the array and count the occurrences of each element\n    for element in arr:\n        if element in element_count:\n            element_count[element] += 1\n        else:\n            element_count[element] = 1\n    \n    # Iterate through the array again and check the count of each element\n    # Return the first element that occurs k times\n    for element in arr:\n        if element_count[element] == k:\n            return element\n    \n    # If no element occurs k times, return None\n    return None\n`"}
{"task_id": 352, "completion": "def unique_Characters(str):\n    # Create a set to store unique characters\n    char_set = set()\n    \n    # Iterate through each character in the string\n    for char in str:\n        # If the character is already in the set, return False\n        if char in char_set:\n            return False\n        # Otherwise, add the character to the set\n        else:\n            char_set.add(char)\n    \n    # If the loop completes without returning False, all characters are unique\n    return True"}
{"task_id": 353, "completion": "def remove_column(list1, n):\n    # Check if the specified column index is within the range of list columns\n    if not list1 or n < 0 or n >= len(list1[0]):\n        print(\"Invalid column index.\")\n        return list1\n    \n    # Use list comprehension to rebuild each row without the specified column\n    modified_list = [row[:n] + row[n+1:] for row in list1]\n    \n    return modified_list"}
{"task_id": 354, "completion": "def tn_ap(a, n, d):\n    \"\"\"\n    Function to find the nth term of an arithmetic progression.\n\n    Parameters:\n    a (int/float): The first term of the AP.\n    n (int): The term number to find.\n    d (int/float): The common difference between the terms.\n\n    Returns:\n    int/float: The nth term of the AP.\n    \"\"\"\n    return a + (n - 1) * d"}
{"task_id": 355, "completion": "def count_squares_in_circle(radius, side_length):\n    # Diameter of the circle\n    diameter = 2 * radius\n    # Maximum number of squares along the diameter\n    # This is an approximation, as it does not account for partial squares\n    max_squares_along_diameter = diameter / side_length\n    # Estimate the number of squares that can fit in a circle\n    # by multiplying the max squares along the diameter by itself\n    # and adjusting by a factor of pi/4, which is an approximation\n    # to account for the circular shape vs the square grid.\n    estimated_squares = (max_squares_along_diameter ** 2) * (math.pi / 4)\n    return math.floor(estimated_squares)"}
{"task_id": 356, "completion": "def find_angle(a, b):\n    # Calculate the third angle\n    third_angle = 180 - (a + b)\n    return third_angle"}
{"task_id": 357, "completion": "def find_max(test_list):\n    # Initialize the maximum element to be the smallest possible value\n    max_element = float('-inf')\n    \n    # Iterate through each tuple in the list\n    for record in test_list:\n        # Find the maximum element in the current tuple\n        current_max = max(record)\n        # Update the global maximum element if the current maximum is greater\n        if current_max > max_element:\n            max_element = current_max\n    \n    return max_element"}
{"task_id": 358, "completion": "def moddiv_list(nums1, nums2):\n    # Use map with a lambda function to perform modulo division between corresponding elements of the two lists\n    # The lambda function takes two arguments: x (from nums1) and y (from nums2) and returns x % y\n    # It's important to handle the case where y might be 0 to avoid a ZeroDivisionError\n    result = map(lambda x, y: x % y if y != 0 else None, nums1, nums2)\n    return list(result)"}
{"task_id": 359, "completion": "def check_solution(a, b, c):\n    # Check if the discriminant is non-negative\n    discriminant = b**2 - 4*a*c\n    if discriminant < 0:\n        return False  # No real roots, so the condition cannot be satisfied\n    \n    # Calculate the roots using the quadratic formula\n    root1 = (-b + discriminant**0.5) / (2*a)\n    root2 = (-b - discriminant**0.5) / (2*a)\n    \n    # Check if one root is twice the other\n    if root1 == 2*root2 or root2 == 2*root1:\n        return True\n    else:\n        return False"}
{"task_id": 360, "completion": "def get_carol(n):\n    # Calculate the n'th Carol number using the formula\n    carol_number = (2**n - 1)**2 - 2\n    return carol_number"}
{"task_id": 361, "completion": "def remove_empty(list1):\n    # Use a list comprehension to filter out empty lists\n    return [sublist for sublist in list1 if sublist]"}
{"task_id": 362, "completion": "def max_occurrences(nums):\n    # Check if the list is empty\n    if not nums:\n        return None, 0\n    \n    # Create a dictionary to count occurrences of each item\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Find the item with the maximum occurrences\n    max_item = max(count_dict, key=count_dict.get)\n    max_count = count_dict[max_item]\n    \n    return max_item, max_count"}
{"task_id": 363, "completion": "def add_K_element(test_list, K):\n    return [(tuple(element + K for element in tup)) for tup in test_list]"}
{"task_id": 364, "completion": "def make_flip(ch):\n    # Scenario 1: Alternating sequence starting with '0'\n    flips_for_0_start = 0\n    for i in range(len(ch)):\n        # For even indices, we expect '0', and for odd indices, we expect '1'\n        expected_char = '0' if i % 2 == 0 else '1'\n        if ch[i] != expected_char:\n            flips_for_0_start += 1\n\n    # Scenario 2: Alternating sequence starting with '1'\n    flips_for_1_start = 0\n    for i in range(len(ch)):\n        # For even indices, we expect '1', and for odd indices, we expect '0'\n        expected_char = '1' if i % 2 == 0 else '0'\n        if ch[i] != expected_char:\n            flips_for_1_start += 1\n\n    # Return the minimum number of flips required between the two scenarios\n    return min(flips_for_0_start, flips_for_1_start)"}
{"task_id": 365, "completion": "def count_Digit(n):\n    # Convert n to its absolute value to handle negative numbers\n    n = abs(n)\n    \n    # Convert the number to a string and return its length\n    return len(str(n))"}
{"task_id": 366, "completion": "def adjacent_num_product(list_nums):\n    # Check if the list has fewer than 2 elements\n    if len(list_nums) < 2:\n        return \"List must contain at least two elements.\"\n    \n    # Initialize the largest product with the product of the first two elements\n    largest_product = list_nums[0] * list_nums[1]\n    \n    # Iterate through the list starting from the second element\n    for i in range(1, len(list_nums) - 1):\n        # Calculate the product of the current element and the next element\n        current_product = list_nums[i] * list_nums[i + 1]\n        \n        # Update the largest product if the current product is greater\n        if current_product > largest_product:\n            largest_product = current_product\n            \n    return largest_product"}
{"task_id": 367, "completion": "def isBalanced(root):\n    \"\"\"\n    Check if a binary tree is balanced.\n    :type root: TreeNode\n    :rtype: bool\n    \"\"\"\n    def checkHeight(node):\n        # Base case: An empty tree is balanced and has a height of -1\n        if not node:\n            return 0\n        \n        # Check the height of the left and right subtrees\n        leftHeight = checkHeight(node.left)\n        rightHeight = checkHeight(node.right)\n        \n        # If the left or right subtree is not balanced, propagate the failure\n        if leftHeight == -1 or rightHeight == -1 or abs(leftHeight - rightHeight) > 1:\n            return -1  # Use -1 to indicate that the tree is not balanced\n        \n        # Return the height of the current node\n        return max(leftHeight, rightHeight) + 1\n    \n    # The tree is balanced if the helper function does not return -1\n    return checkHeight(root) != -1"}
{"task_id": 368, "completion": "def repeat_tuples(test_tup, N):\n    # Repeating the tuple N times using tuple multiplication\n    result_tup = test_tup * N\n    return result_tup"}
{"task_id": 369, "completion": "def lateral_surface_cuboid(l, w, h):\n    \"\"\"\n    Calculate the lateral surface area of a cuboid.\n\n    Parameters:\n    l (float): Length of the cuboid.\n    w (float): Width of the cuboid.\n    h (float): Height of the cuboid.\n\n    Returns:\n    float: Lateral surface area of the cuboid.\n    \"\"\"\n    lateral_surface_area = 2 * h * (l + w)\n    return lateral_surface_area"}
{"task_id": 370, "completion": "def float_sort(tuples):\n    # Assuming the float element is the second element in each tuple pair\n    # You can adjust the lambda function to access the correct float element as needed\n    return sorted(tuples, key=lambda x: x[1])"}
{"task_id": 371, "completion": "def smallest_missing(A, left, right):\n    # Base case: If the left index exceeds the right index, it means the smallest missing element is right+1\n    if left > right:\n        return left\n    \n    # Calculate the middle index\n    mid = left + (right - left) // 2\n    \n    # If the value at the middle index is equal to its index, the missing element is in the right half\n    if A[mid] == mid:\n        return smallest_missing(A, mid + 1, right)\n    else:\n        # Otherwise, the missing element is in the left half\n        return smallest_missing(A, left, mid - 1)\n`"}
{"task_id": 372, "completion": "import heapq\n\ndef heap_ascending(nums):\n    # Create an empty heap\n    heap = []\n    # Convert the list into a heap\n    heapq.heapify(nums)\n    \n    # While the heap is not empty, pop the smallest element\n    # and add it to the result list\n    while nums:\n        smallest = heapq.heappop(nums)\n        heap.append(smallest)\n    \n    return heap"}
{"task_id": 373, "completion": "def volume_cuboid(l, w, h):\n    \"\"\"\n    Calculate the volume of a cuboid.\n\n    Parameters:\n    l (float): Length of the cuboid.\n    w (float): Width of the cuboid.\n    h (float): Height of the cuboid.\n\n    Returns:\n    float: Volume of the cuboid.\n    \"\"\"\n    return l * w * h"}
{"task_id": 374, "completion": "def permute_string(s, answer):\n    if len(s) == 0:\n        print(answer, end=\" \")\n        return\n    \n    for i in range(len(s)):\n        # Choose the character at index i\n        ch = s[i]\n        # Left substring + right substring\n        left_substr = s[0:i]\n        right_substr = s[i+1:]\n        # Rest of the string after excluding\n        # the ith character\n        rest = left_substr + right_substr\n        # Recurse with the remaining string\n        permute_string(rest, answer + ch)"}
{"task_id": 375, "completion": "def round_num(n, m):\n    \"\"\"\n    Rounds the number n to the nearest multiple of m.\n\n    Parameters:\n    n (float): The number to be rounded.\n    m (int): The multiple to which n is to be rounded.\n\n    Returns:\n    int: The nearest multiple of m to n.\n    \"\"\"\n    # Calculate the nearest multiple of m to n\n    nearest_multiple = round(n / m) * m\n    return nearest_multiple"}
{"task_id": 376, "completion": "def remove_replica(test_tup, custom_value):\n    # Count the occurrence of each element in the tuple\n    count_dict = {}\n    for item in test_tup:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    \n    # Replace duplicates with the custom value\n    result = tuple(item if count_dict[item] == 1 else custom_value for item in test_tup)\n    \n    return result"}
{"task_id": 377, "completion": "def remove_Char(s, c):\n    # Use the replace method to remove all occurrences of c from s\n    return s.replace(c, \"\")"}
{"task_id": 378, "completion": "def move_first(test_list):\n    # Check if the list is not empty\n    if test_list:\n        # Pop the last element and insert it at the beginning\n        test_list.insert(0, test_list.pop())\n    return test_list"}
{"task_id": 379, "completion": "def surfacearea_cuboid(l, w, h):\n    \"\"\"\n    Calculate the surface area of a cuboid.\n\n    Parameters:\n    l (float): Length of the cuboid.\n    w (float): Width of the cuboid.\n    h (float): Height of the cuboid.\n\n    Returns:\n    float: Surface area of the cuboid.\n    \"\"\"\n    return 2 * (l*w + l*h + w*h)"}
{"task_id": 380, "completion": "def multi_list(rownum, colnum):\n    \"\"\"\n    Generate a two-dimensional array with the specified number of rows and columns.\n    \n    Parameters:\n    rownum (int): Number of rows in the array.\n    colnum (int): Number of columns in the array.\n    \n    Returns:\n    list: A two-dimensional array (list of lists) with each element initialized to 0.\n    \"\"\"\n    return [[0 for _ in range(colnum)] for _ in range(rownum)]"}
{"task_id": 381, "completion": "def index_on_inner_list(list_data, index_no):\n    \"\"\"\n    Sorts a list of lists based on a given index of the inner lists.\n\n    Parameters:\n    - list_data: A list of lists to be sorted.\n    - index_no: The index in the inner lists to sort by.\n\n    Returns:\n    - A new list of lists sorted based on the specified index of the inner lists.\n    \"\"\"\n    # Use sorted function with a lambda as the key to sort by the specified index\n    return sorted(list_data, key=lambda x: x[index_no])"}
{"task_id": 382, "completion": "def find_rotation_count(A):\n    low = 0\n    high = len(A) - 1\n    n = len(A)\n\n    while low <= high:\n        if A[low] <= A[high]:\n            return low\n        \n        mid = (low + high) // 2\n        next = (mid + 1) % n\n        prev = (mid - 1 + n) % n\n\n        if A[mid] <= A[next] and A[mid] <= A[prev]:\n            return mid\n        \n        elif A[mid] <= A[high]:\n            high = mid - 1\n        else:\n            low = mid + 1\n\n    return 0\n`"}
{"task_id": 383, "completion": "def even_bit_toggle_number(n):\n    # Initialize mask with 0\n    mask = 0\n    \n    # Assuming 32-bit integer for the purpose of this example\n    # Adjust the range accordingly if you're working with a different integer size\n    for i in range(32):\n        # Check if the bit position is odd (i % 2 == 1)\n        if i % 2 == 1:\n            # Set the corresponding bit in the mask\n            mask |= (1 << i)\n    \n    # Toggle the odd bits in n using XOR operation with the mask\n    toggled_n = n ^ mask\n    \n    return toggled_n"}
{"task_id": 384, "completion": "def frequency_Of_Smallest(n, arr):\n    # First, find the smallest value in the array\n    smallest = min(arr)\n    \n    # Now, count how many times the smallest value appears in the array\n    frequency = arr.count(smallest)\n    \n    # Return the frequency of the smallest value\n    return frequency"}
{"task_id": 385, "completion": "def get_perrin(n):\n    # Base cases\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        # Recursive call\n        return get_perrin(n - 2) + get_perrin(n - 3)"}
{"task_id": 386, "completion": "def swap_count(s):\n    # Initialize variables to keep track of imbalances and swaps\n    imbalance = 0\n    swaps = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # If it's an opening bracket, increment imbalance\n        if char == '[':\n            imbalance += 1\n        # If it's a closing bracket\n        elif char == ']':\n            # If there's an imbalance, a swap can fix it\n            if imbalance > 0:\n                imbalance -= 1\n            # If there's no imbalance, this closing bracket needs to be swapped\n            else:\n                # To balance, we need to swap this closing bracket with an opening one\n                # Increment swaps and also consider this as an opening bracket now, hence imbalance is incremented\n                swaps += 1\n                imbalance += 1\n                \n    return swaps"}
{"task_id": 387, "completion": "def even_or_odd(hex_num):\n    # Convert the hexadecimal number to an integer\n    num = int(hex_num, 16)\n    \n    # Check if the number is even or odd\n    if num % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\""}
{"task_id": 388, "completion": "def highest_Power_of_2(n):\n    # Edge case: if n is 0 or negative, return 0 as there's no positive power of 2 in this case.\n    if n < 1:\n        return 0\n    \n    # Keep shifting n to the right until it becomes 1.\n    # This effectively finds the highest bit set in n, which corresponds to the highest power of 2 less than or equal to n.\n    power = 1\n    while n > 1:\n        n >>= 1\n        power <<= 1\n    \n    return power"}
{"task_id": 389, "completion": "def find_lucas_recursive(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return find_lucas_recursive(n-1) + find_lucas_recursive(n-2)"}
{"task_id": 390, "completion": "def add_string(lst, string):\n    # Using list comprehension to add string at the beginning of each item\n    return [string + str(item) for item in lst]"}
{"task_id": 391, "completion": "def convert_list_dictionary(*lists):\n    \"\"\"\n    Convert multiple lists into a nested dictionary.\n    \n    Each list in the input is transformed into a level in the nested dictionary.\n    The first element of each list becomes a key, and this process is repeated\n    for subsequent elements, creating a nested structure.\n    \n    Parameters:\n    *lists: Variable length list arguments. Each argument is a list that contributes\n            to a level in the resulting nested dictionary.\n            \n    Returns:\n    A nested dictionary constructed from the input lists.\n    \"\"\"\n    # Base case: If there's no list or only empty lists left, return an empty dictionary\n    if not lists or all(len(lst) == 0 for lst in lists):\n        return {}\n    \n    # Recursive case:\n    # 1. Use the first element of each list as keys at the current level\n    # 2. For the value, call the function recursively with the rest of each list\n    #    (i.e., elements from the second position onwards)\n    # This constructs the nested structure\n    result = {}\n    for i in range(len(lists[0])):\n        # Extract the key from the first list and the rest of the lists for the next level\n        key = lists[0][i]\n        next_level_lists = [lst[i+1:] for lst in lists]\n        \n        # Use recursion to build the next level of the dictionary\n        value = convert_list_dictionary(*next_level_lists)\n        \n        # Assign the constructed value to the key in the result dictionary\n        result[key] = value\n    \n    return result"}
{"task_id": 392, "completion": "def get_max_sum(n, memo={}):\n    # Base case: if n is 0 or 1, the maximum sum is n itself\n    if n <= 1:\n        return n\n    \n    # Check if the result for this n is already calculated\n    if n in memo:\n        return memo[n]\n    \n    # Recursively calculate the sum using the given formula\n    max_sum = max(\n        get_max_sum(n // 2, memo) + \n        get_max_sum(n // 3, memo) + \n        get_max_sum(n // 4, memo) + \n        get_max_sum(n // 5, memo),\n        n\n    )\n    \n    # Store the result in memo dictionary to avoid recalculating\n    memo[n] = max_sum\n    \n    return max_sum\n`"}
{"task_id": 393, "completion": "def max_length_list(input_list):\n    return max(input_list, key=lambda x: len(x))"}
{"task_id": 394, "completion": "def check_distinct(test_tup):\n    \"\"\"\n    Check if the given tuple is distinct or not.\n\n    Parameters:\n    test_tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if the tuple is distinct, False otherwise.\n    \"\"\"\n    # Convert the tuple into a set to remove duplicates\n    unique_elements = set(test_tup)\n    \n    # Compare the length of the original tuple with the set\n    if len(unique_elements) == len(test_tup):\n        return True\n    else:\n        return False"}
{"task_id": 395, "completion": "def first_non_repeating_character(str1):\n    char_count = {}  # Dictionary to store count of characters\n    # Counting each character in string\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    # Finding the first non-repeating character\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    return None  # In case there's no non-repeating character"}
{"task_id": 396, "completion": "import re\n\ndef check_char(string):\n    # The regex pattern to match a string that starts and ends with the same character\n    pattern = r\"^(.).*\\1$\"\n    \n    # Using re.match to check if the pattern matches the entire string\n    if re.match(pattern, string):\n        return True\n    else:\n        return False"}
{"task_id": 397, "completion": "def median_numbers(a, b, c):\n    # Sort the numbers\n    sorted_numbers = sorted([a, b, c])\n    # Return the middle number\n    return sorted_numbers[1]"}
{"task_id": 398, "completion": "def sum_of_digits(nums):\n    # Function to calculate the sum of digits of a single number\n    def digit_sum(n):\n        return sum(int(digit) for digit in str(abs(n)))  # Use abs(n) to handle negative numbers\n    \n    # Apply the digit_sum function to each number in the list and return the result\n    return [digit_sum(num) for num in nums]"}
{"task_id": 399, "completion": "def bitwise_xor(test_tup1, test_tup2):\n    # Check if the tuples are of the same length\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Tuples must be of the same length\")\n    \n    # Perform bitwise XOR on each pair of elements and collect the results\n    result = tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n    \n    return result"}
{"task_id": 400, "completion": "def extract_freq(test_list):\n    # Dictionary to store the frequency of unique tuples\n    freq_dict = {}\n    \n    for tup in test_list:\n        # Sort the tuple to make the order of elements irrelevant\n        sorted_tup = tuple(sorted(tup))\n        \n        # Update the frequency of the sorted tuple in the dictionary\n        if sorted_tup in freq_dict:\n            freq_dict[sorted_tup] += 1\n        else:\n            freq_dict[sorted_tup] = 1\n            \n    return freq_dict"}
{"task_id": 401, "completion": "def add_nested_tuples(tup1, tup2):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the tuples using zip to pair elements\n    for item1, item2 in zip(tup1, tup2):\n        # Check if the items are tuples themselves (nested)\n        if isinstance(item1, tuple) and isinstance(item2, tuple):\n            # Recursively call the function for nested tuples\n            result.append(add_nested_tuples(item1, item2))\n        else:\n            # Add the items if they are not tuples (base case)\n            result.append(item1 + item2)\n    \n    # Convert the result list back to a tuple before returning\n    return tuple(result)\n`"}
{"task_id": 402, "completion": "def ncr_modp(n, r, p):\n    \"\"\"Function to compute nCr % p\"\"\"\n    if r == 0:\n        return 1\n    \n    # Initialize numerator and denominator\n    numerator = 1\n    denominator = 1\n    \n    # Calculate n! % p\n    for i in range(1, n+1):\n        numerator = (numerator * i) % p\n    \n    # Calculate r! % p\n    for i in range(1, r+1):\n        denominator = (denominator * i) % p\n    \n    # Calculate (n-r)! % p\n    for i in range(1, n-r+1):\n        denominator = (denominator * i) % p\n    \n    # Calculate denominator^(-1) mod p\n    denominator_inv = modInverse(denominator, p)\n    \n    # Calculate nCr % p\n    return (numerator * denominator_inv) % p"}
{"task_id": 403, "completion": "def is_valid_URL(str):\n    # Regular expression for validating a URL\n    pattern = re.compile(r'^(https?:\\/\\/)?' # http:// or https://\n                         r'((([a-zA-Z0-9\\-]+\\.)+[a-zA-Z]{2,})' # domain...\n                         r'|' # ...or...\n                         r'localhost' # localhost...\n                         r'|' # ...or...\n                         r'(\\d{1,3}\\.){3}\\d{1,3})' # ...or ip (v4) address\n                         r'(\\:\\d+)?' # optional port\n                         r'(\\/[-a-zA-Z0-9%_\\+.~#?&//=]*)?$') # path\n    # Matching the string with the pattern\n    if pattern.match(str):\n        return True\n    else:\n        return False\n`"}
{"task_id": 404, "completion": "def find_minimum(a, b):\n    if a < b:\n        return a\n    else:\n        return b"}
{"task_id": 405, "completion": "def check_tuplex(tuplex, tuple1):\n    # Check if all elements in tuple1 exist in tuplex\n    return all(item in tuplex for item in tuple1)"}
{"task_id": 406, "completion": "def find_Parity(x):\n    parity = 0\n    while x:\n        parity ^= 1\n        x &= (x - 1)  # Drop the lowest set bit\n    return parity"}
{"task_id": 407, "completion": "def rearrange_bigger(n):\n    # Convert the number to a list of its digits\n    digits = [int(i) for i in str(n)]\n    \n    # Step 2: Find the first digit that is smaller than the digit immediately after it, from right to left\n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    \n    # If no such digit is found, return that the number cannot be made bigger\n    if i == -1:\n        return \"Cannot rearrange to a bigger number\"\n    \n    # Step 4: Find the smallest digit on the right side of 'i' that is bigger than digits[i]\n    j = len(digits) - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    \n    # Step 5: Swap\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Step 6: Sort the digits after the original position of 'i' to get the smallest number bigger than the original\n    digits[i+1:] = sorted(digits[i+1:])\n    \n    # Step 7: Convert back to a number\n    return int(''.join(map(str, digits)))"}
{"task_id": 408, "completion": "def k_smallest_pairs(nums1, nums2, k):\n    if not nums1 or not nums2 or k <= 0:\n        return []\n\n    min_heap = [(nums1[0] + nums2[j], 0, j, nums1[0], nums2[j]) for j in range(len(nums2))]\n    heapq.heapify(min_heap)\n\n    result = []\n    while min_heap and len(result) < k:\n        _, i, j, val1, val2 = heapq.heappop(min_heap)\n        result.append([val1, val2])\n        if i + 1 < len(nums1):\n            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j, nums1[i + 1], nums2[j]))\n\n    return result\n`"}
{"task_id": 409, "completion": "def min_product_tuple(list1):\n    # Check if the list is empty or contains less than one tuple\n    if not list1 or len(list1) < 1:\n        return None  # Return None or an appropriate value indicating the list is not valid for operation\n    \n    # Initialize min_product with the product of the first tuple to ensure comparison starts with a valid product value\n    min_product = list1[0][0] * list1[0][1]\n    \n    # Iterate through the list starting from the second tuple (if exists)\n    for tup in list1[1:]:\n        # Calculate the product of the current tuple\n        product = tup[0] * tup[1]\n        # Update min_product if the current product is less than the current min_product\n        if product < min_product:\n            min_product = product\n    \n    return min_product\n`"}
{"task_id": 410, "completion": "def min_val(listval):\n    # Initialize a variable to store the minimum value. Set it to None as we haven't found a numeric value yet.\n    min_numeric = None\n    \n    for item in listval:\n        # Check if the current item is a numeric value (int or float)\n        if isinstance(item, (int, float)):\n            # If min_numeric is None, it means this is the first numeric value we've found\n            if min_numeric is None:\n                min_numeric = item\n            # If the current item is less than the current minimum, update min_numeric\n            elif item < min_numeric:\n                min_numeric = item\n    \n    # Return the minimum numeric value found, or None if no numeric values were in the list\n    return min_numeric"}
{"task_id": 411, "completion": "def snake_to_camel(word):\n    # Use a regular expression to replace '_[a-z]' with its uppercase counterpart\n    return re.sub(r'_([a-z])', lambda match: match.group(1).upper(), word)"}
{"task_id": 412, "completion": "def remove_odd(l):\n    # Using list comprehension to filter out odd numbers\n    return [x for x in l if x % 2 == 0]"}
{"task_id": 413, "completion": "def extract_nth_element(list1, n):\n    # Initialize an empty list to store the nth elements\n    extracted_elements = []\n    \n    # Loop through each tuple in the list\n    for tup in list1:\n        # Check if the tuple is long enough\n        if len(tup) > n:\n            # Append the nth element of the tuple to the extracted_elements list\n            extracted_elements.append(tup[n])\n        else:\n            # If the tuple does not have an nth element, you might want to handle it\n            # For now, let's append None to indicate the absence of the nth element\n            extracted_elements.append(None)\n    \n    # Return the list of extracted elements\n    return extracted_elements\n`"}
{"task_id": 414, "completion": "def overlapping(list1, list2):\n    # Using a simple loop to check each element in list1 against all elements in list2\n    for element in list1:\n        if element in list2:\n            return True\n    # If no common elements are found, return False\n    return False"}
{"task_id": 415, "completion": "def max_product(arr):\n    # First, sort the array\n    arr.sort()\n    \n    # The maximum product can either be from the two largest values\n    # or from the two smallest values (in case they are negative)\n    max_product_end = arr[-1] * arr[-2]  # Product of the two largest numbers\n    max_product_start = arr[0] * arr[1]  # Product of the two smallest numbers\n    \n    # Return the maximum of the two products\n    return max(max_product_end, max_product_start)"}
{"task_id": 416, "completion": "def breakSum(n):\n    if n <= 1:\n        return n\n    \n    max_sum = max(breakSum(n//2) + breakSum(n//3) + breakSum(n//4), n)\n    \n    return max_sum"}
{"task_id": 417, "completion": "def group_tuples(input_list):\n    # Dictionary to hold the groups\n    groups = {}\n    # Iterate over each tuple in the input list\n    for tup in input_list:\n        # Check if the first element of the tuple is already a key in the dictionary\n        if tup[0] in groups:\n            # If yes, append the tuple to the corresponding list\n            groups[tup[0]].append(tup)\n        else:\n            # If no, create a new list with the tuple\n            groups[tup[0]] = [tup]\n    # Return the grouped tuples as a list of lists\n    return list(groups.values())\n`"}
{"task_id": 418, "completion": "def find_max_sublist(lst):\n    # Initialize variables to keep track of the maximum length and the sublist\n    max_length = 0\n    max_sublist = []\n    \n    # Iterate through the list to find the sublist with the maximum length\n    for sublist in lst:\n        # Check if the current item is a list to ensure we are looking at sublists\n        if isinstance(sublist, list):\n            # Update max_length and max_sublist if the current sublist is longer\n            if len(sublist) > max_length:\n                max_length = len(sublist)\n                max_sublist = sublist\n    \n    # Return the sublist with the maximum length\n    return max_sublist\n`"}
{"task_id": 419, "completion": "def round_and_sum(list1):\n    # Step 1: Round every number in the list\n    rounded_numbers = [round(num) for num in list1]\n    \n    # Step 2: Calculate the sum of the rounded numbers\n    total_sum = sum(rounded_numbers)\n    \n    # Step 3: Multiply the sum by the length of the list\n    result = total_sum * len(list1)\n    \n    # Step 4: Print the result\n    print(result)"}
{"task_id": 420, "completion": "def cube_sum_efficient(n):\n    # Calculate the sum of the first n even numbers' cubes using the formula\n    sum = ((n * (n + 1)) // 2) ** 2\n    # Adjust the formula for even numbers\n    sum = 4 * sum\n    return sum"}
{"task_id": 421, "completion": "def concatenate_tuple(test_tup, delimiter):\n    # Convert each element of the tuple to a string and concatenate them with the delimiter\n    return delimiter.join(map(str, test_tup))"}
{"task_id": 422, "completion": "def find_Average_Of_Cube(n):\n    # Step 1 & 2: Calculate the sum of cubes of first n natural numbers\n    sum_of_cubes = sum([i**3 for i in range(1, n+1)])\n    \n    # Step 3: Calculate the average\n    average = sum_of_cubes / n\n    \n    return average"}
{"task_id": 423, "completion": "def get_max_gold(gold, m, n):\n    # Create a table for storing intermediate results and initialize all cells to 0.\n    # The table will store the maximum amount of gold that can be collected\n    # when starting from a particular cell.\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    \n    for col in range(n-1, -1, -1):\n        for row in range(m):\n            # Gold collected on going to the cell on the right(->)\n            right = dp[row][col+1] if col < n-1 else 0\n            \n            # Gold collected on going to the cell to right up (/)\n            right_up = dp[row-1][col+1] if row > 0 and col < n-1 else 0\n            \n            # Gold collected on going to the cell to right down (\\)\n            right_down = dp[row+1][col+1] if row < m-1 and col < n-1 else 0\n            \n            # Update the dp table by choosing the maximum of the three possibilities\n            dp[row][col] = gold[row][col] + max(right, right_up, right_down)\n    \n    # The maximum amount of gold collected will be the max value\n    # in the first column of dp table since that's where the journey starts.\n    max_gold = max(dp[row][0] for row in range(m))\n    \n    return max_gold"}
{"task_id": 424, "completion": "def extract_rear(test_tuple):\n    result = tuple(s[-1] for s in test_tuple if s)\n    return result"}
{"task_id": 425, "completion": "def count_element_in_list(list1, x):\n    # Initialize a counter to keep track of sublists containing x\n    count = 0\n    \n    # Iterate through each sublist in list1\n    for sublist in list1:\n        # Check if the current sublist is actually a list to avoid errors\n        if isinstance(sublist, list):\n            # If x is found in the sublist, increment the counter\n            if x in sublist:\n                count += 1\n    \n    # Return the total count of sublists containing x\n    return count"}
{"task_id": 426, "completion": "def filter_oddnumbers(nums):\n    # Using filter() with a lambda function to filter odd numbers\n    return list(filter(lambda x: x % 2 != 0, nums))"}
{"task_id": 427, "completion": "import re\n\ndef change_date_format(dt):\n    # Define the regex pattern to match the yyyy-mm-dd format\n    pattern = r'(\\d{4})-(\\d{2})-(\\d{2})'\n    \n    # Use re.sub to replace the format. The replacement pattern changes the order of the matched groups\n    new_format = re.sub(pattern, r'\\3-\\2-\\1', dt)\n    \n    return new_format"}
{"task_id": 428, "completion": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap.\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements arr[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n`"}
{"task_id": 429, "completion": "def and_tuples(test_tup1, test_tup2):\n    # Using zip to iterate over both tuples simultaneously\n    # Applying bitwise AND operation '&' to each pair of elements\n    result = tuple(a & b for a, b in zip(test_tup1, test_tup2))\n    return result"}
{"task_id": 430, "completion": "def parabola_directrix(a, b, c):\n    # Calculate the directrix of the parabola\n    D = c - (b**2 + 1) / (4 * a)\n    return D"}
{"task_id": 431, "completion": "def common_element(list1, list2):\n    # Convert the first list to a set to improve lookup times\n    set1 = set(list1)\n    \n    # Iterate through the second list\n    for element in list2:\n        # Check if the current element exists in the set created from the first list\n        if element in set1:\n            return True\n    # If no common elements were found, return False\n    return False"}
{"task_id": 432, "completion": "def median_trapezium(base1, base2):\n    \"\"\"\n    Calculate the median of a trapezium given its two bases.\n\n    Parameters:\n    base1 (float): The length of the first base.\n    base2 (float): The length of the second base.\n\n    Returns:\n    float: The median of the trapezium.\n    \"\"\"\n    return (base1 + base2) / 2"}
{"task_id": 433, "completion": "def check_greater(arr, number):\n    # Iterate through each element in the array\n    for element in arr:\n        # If any element is greater than or equal to the number, return False\n        if element >= number:\n            return False\n    # If the loop completes without finding any element greater than or equal to the number, return True\n    return True"}
{"task_id": 434, "completion": "import re\n\ndef text_match_one(text):\n    # Define the regular expression pattern\n    pattern = 'ab+'\n    \n    # Use re.search() to search the text for the pattern\n    if re.search(pattern, text):\n        return True\n    else:\n        return False"}
{"task_id": 435, "completion": "def last_digit(n):\n    return abs(n) % 10"}
{"task_id": 436, "completion": "def neg_nos(list1):\n    # Loop through each number in the list\n    for num in list1:\n        # Check if the current number is negative\n        if num < 0:\n            # Print the negative number\n            print(num)"}
{"task_id": 437, "completion": "def remove_odd(str1):\n    # Initialize an empty string to store the result\n    result = \"\"\n    # Iterate through the string using enumerate to get both index and character\n    for index, char in enumerate(str1):\n        # Check if the index is even\n        if index % 2 == 0:\n            # Append the character to the result string\n            result += char\n    # Return the result string\n    return result"}
{"task_id": 438, "completion": "def count_bidirectional(test_list):\n    # Initialize a set to keep track of visited pairs\n    visited = set()\n    # Initialize a counter for bidirectional pairs\n    bidirectional_count = 0\n    \n    # Iterate through each tuple in the list\n    for tup in test_list:\n        # Check if the reverse tuple exists in the list and the tuple is not already visited\n        if tup[::-1] in test_list and tup not in visited:\n            # Increment the counter\n            bidirectional_count += 1\n            # Add both the tuple and its reverse to the visited set to avoid double counting\n            visited.add(tup)\n            visited.add(tup[::-1])\n    \n    # Return the count of bidirectional pairs\n    return bidirectional_count\n`"}
{"task_id": 439, "completion": "def multiple_to_single(L):\n    # Convert each integer in the list to a string and concatenate them\n    concatenated_string = ''.join(map(str, L))\n    # Convert the concatenated string back to an integer\n    single_integer = int(concatenated_string)\n    return single_integer"}
{"task_id": 440, "completion": "def find_adverb_position(text):\n    # Tokenize the sentence into words\n    words = word_tokenize(text)\n    # Tag each word with part of speech\n    pos_tags = pos_tag(words)\n    \n    # Find adverbs and their positions\n    adverbs = []\n    for i, (word, tag) in enumerate(pos_tags):\n        if tag.startswith('RB'):  # RB, RBR, and RBS are tags for adverbs\n            adverbs.append((word, i))\n    \n    return adverbs"}
{"task_id": 441, "completion": "def surface_area_cube(l):\n    return 6 * l**2"}
{"task_id": 442, "completion": "def positive_count(nums):\n    # Check if the input list is not empty to avoid division by zero\n    if not nums:\n        return 0.0\n    \n    # Count the number of positive numbers\n    positive_numbers = sum(1 for num in nums if num > 0)\n    \n    # Calculate the ratio of positive numbers\n    ratio = positive_numbers / len(nums)\n    \n    return ratio"}
{"task_id": 443, "completion": "def largest_neg(list1):\n    # Filter the list to keep only negative numbers\n    negative_numbers = [num for num in list1 if num < 0]\n    \n    # Check if there are any negative numbers\n    if not negative_numbers:\n        return None\n    \n    # Return the largest negative number\n    return max(negative_numbers)"}
{"task_id": 444, "completion": "def trim_tuple(test_list, K):\n    # Trim each tuple in the list by removing the last K elements\n    trimmed_list = [t[:-K] if len(t) > K else () for t in test_list]\n    return trimmed_list"}
{"task_id": 445, "completion": "def index_multiplication(test_tup1, test_tup2):\n    # Using zip() to pair up elements of the two tuples and a generator expression to multiply them\n    result = tuple(a * b for a, b in zip(test_tup1, test_tup2))\n    return result"}
{"task_id": 446, "completion": "def count_occurrence(tup, lst):\n    # Initialize an empty dictionary to store the count of each element\n    count_dict = {}\n    \n    # Iterate through the list\n    for item in lst:\n        # Count the occurrence of the item in the tuple and update the dictionary\n        count_dict[item] = tup.count(item)\n    \n    return count_dict"}
{"task_id": 447, "completion": "def cube_nums(nums):\n    # Use map with a lambda function to cube each element\n    return list(map(lambda x: x**3, nums))"}
{"task_id": 448, "completion": "def cal_sum(n):\n    # Check if n is less than 0\n    if n < 0:\n        return \"n should be a non-negative integer\"\n    \n    # Base cases\n    if n == 0:\n        return 3  # The sum of the first Perrin number\n    if n == 1:\n        return 3  # The sum of the first two Perrin numbers\n    if n == 2:\n        return 5  # The sum of the first three Perrin numbers\n    \n    # Initialize the first three Perrin numbers\n    p0, p1, p2 = 3, 0, 2\n    sum_perrin = p0 + p1 + p2  # Initialize sum with the first three numbers\n    \n    # Generate Perrin sequence and calculate sum up to n\n    for _ in range(3, n + 1):\n        p_next = p0 + p1  # Calculate next Perrin number\n        sum_perrin += p_next  # Add it to the sum\n        # Update the last three numbers\n        p0, p1, p2 = p1, p2, p_next\n    \n    return sum_perrin"}
{"task_id": 449, "completion": "def check_Triangle(x1, y1, x2, y2, x3, y3):\n    # Calculate the lengths of the sides\n    side1 = calculate_distance(x1, y1, x2, y2)\n    side2 = calculate_distance(x2, y2, x3, y3)\n    side3 = calculate_distance(x3, y3, x1, y1)\n    \n    # Check the triangle inequality theorem\n    if (side1 + side2 > side3) and (side2 + side3 > side1) and (side1 + side3 > side2):\n        return \"Valid Triangle\"\n    else:\n        return \"Invalid Triangle\""}
{"task_id": 450, "completion": "def extract_string(str_list, l):\n    # Initialize an empty list to store strings of the specified length\n    result = []\n    \n    # Iterate through each string in the input list\n    for string in str_list:\n        # Check if the length of the current string matches the specified length\n        if len(string) == l:\n            # If it matches, append the string to the result list\n            result.append(string)\n    \n    # Return the list of strings that match the specified length\n    return result"}
{"task_id": 451, "completion": "def remove_whitespaces(text):\n    # Use regex to replace all whitespace characters with an empty string\n    return re.sub(r'\\s+', '', text)"}
{"task_id": 452, "completion": "def loss_amount(actual_cost, sale_amount):\n    # Calculate the difference between the actual cost and the sale amount\n    difference = actual_cost - sale_amount\n    \n    # Check if there is a loss\n    if difference > 0:\n        # There is a loss, return the loss amount\n        return difference\n    else:\n        # No loss, return None\n        return None"}
{"task_id": 453, "completion": "def sumOfEvenFactors(n):\n    # Initialize sum of even factors\n    sum_even_factors = 0\n    \n    # Loop through all possible factors\n    for i in range(1, n + 1):\n        # Check if i is a factor of n and even\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n            \n    return sum_even_factors"}
{"task_id": 454, "completion": "import re\n\ndef text_match_wordz(text):\n    # Regular expression pattern to find words containing 'z'\n    pattern = r'\\b\\w*z\\w*\\b'\n    \n    # Find all occurrences of the pattern in the text\n    matches = re.findall(pattern, text, re.IGNORECASE)\n    \n    return matches"}
{"task_id": 455, "completion": "def check_monthnumb_number(monthnum2):\n    # List of month numbers with 31 days\n    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]\n    \n    # Check if the given month number is in the list\n    if monthnum2 in months_with_31_days:\n        print(f\"Month number {monthnum2} has 31 days.\")\n    else:\n        print(f\"Month number {monthnum2} does not have 31 days.\")"}
{"task_id": 456, "completion": "def reverse_string_list(stringlist):\n    # Create a new list to store the reversed strings\n    reversed_list = []\n    # Loop through each string in the input list\n    for string in stringlist:\n        # Reverse the string and add it to the new list\n        reversed_list.append(string[::-1])\n    # Return the new list with reversed strings\n    return reversed_list"}
{"task_id": 457, "completion": "def find_min(lst):\n    # Check if the list is empty\n    if not lst:\n        return None  # Return None if the list is empty\n    \n    # Initialize the minimum length sublist as the first sublist\n    min_sublist = lst[0]\n    \n    # Iterate through the list of sublists\n    for sublist in lst:\n        # Update min_sublist if a sublist with a smaller length is found\n        if len(sublist) < len(min_sublist):\n            min_sublist = sublist\n            \n    return min_sublist"}
{"task_id": 458, "completion": "def rectangle_area(l, b):\n    return l * b"}
{"task_id": 459, "completion": "def remove_uppercase(str1):\n    # This regex pattern matches substrings that consist of uppercase letters.\n    # The pattern [A-Z]+ matches one or more consecutive uppercase letters.\n    pattern = r'[A-Z]+'\n    \n    # Use re.sub() to replace the matched uppercase substrings with an empty string.\n    # This effectively removes them from the original string.\n    result = re.sub(pattern, '', str1)\n    \n    return result"}
{"task_id": 460, "completion": "def extract(lst):\n    # Using list comprehension to extract the first element of each sublist\n    return [sublist[0] for sublist in lst if sublist]"}
{"task_id": 461, "completion": "def upper_ctr(str):\n    # Initialize a counter for uppercase characters\n    upper_count = 0\n    \n    # Iterate through each character in the string\n    for char in str:\n        # Check if the character is uppercase\n        if char.isupper():\n            # Increment the counter if it is\n            upper_count += 1\n            \n    # Return the count of uppercase characters\n    return upper_count"}
{"task_id": 462, "completion": "def combinations_list(list1):\n    # This will store all combinations\n    all_combinations = []\n    \n    # Loop through all possible lengths\n    for r in range(1, len(list1) + 1):\n        # itertools.combinations generates combinations of length r\n        for combo in combinations(list1, r):\n            all_combinations.append(combo)\n    \n    return all_combinations"}
{"task_id": 463, "completion": "def max_subarray_product(arr):\n    if not arr:\n        return 0\n\n    # Initialize max and min product to the first element\n    max_product = min_product = global_max = arr[0]\n\n    for num in arr[1:]:\n        # When num is negative, max_product and min_product will swap\n        if num < 0:\n            max_product, min_product = min_product, max_product\n\n        # max_product/max_product_so_far is the maximum of num and num multiplied with the previous max_product\n        max_product = max(num, max_product * num)\n        # min_product/min_product_so_far is the minimum of num and num multiplied with the previous min_product\n        min_product = min(num, min_product * num)\n\n        # Update global_max if needed\n        global_max = max(global_max, max_product)\n\n    return global_max"}
{"task_id": 464, "completion": "def check_value(dict, n):\n    # Extract all values from the dictionary\n    values = list(dict.values())\n    \n    # Check if all values in the dictionary are the same\n    # by comparing the set of values (which removes duplicates) to a single value\n    return len(set(values)) == 1"}
{"task_id": 465, "completion": "def drop_empty(dict1):\n    # Using dictionary comprehension to filter out items with empty values.\n    # This checks for values that are not None or not False (including 0) and are not empty (like [], {}, \"\", etc.)\n    return {k: v for k, v in dict1.items() if v or v is False or v == 0}"}
{"task_id": 466, "completion": "def find_peak_util(arr, low, high, n):\n    # Find the middle index\n    mid = low + (high - low) // 2\n    \n    # Check if the middle element is a peak\n    # For the first and last element, we only need to check one neighbor\n    if ((mid == 0 or arr[mid - 1] <= arr[mid]) and\n       (mid == n - 1 or arr[mid + 1] <= arr[mid])):\n        return mid\n    \n    # If the middle element is not the peak and its left neighbor is greater than it,\n    # then the left half must have a peak element\n    elif mid > 0 and arr[mid - 1] > arr[mid]:\n        return find_peak_util(arr, low, mid - 1, n)\n    \n    # If the middle element is not the peak and its right neighbor is greater than it,\n    # then the right half must have a peak element\n    else:\n        return find_peak_util(arr, mid + 1, high, n)\n\ndef find_peak(arr):\n    n = len(arr)\n    return find_peak_util(arr, 0, n - 1, n)"}
{"task_id": 467, "completion": "def decimal_to_octal(deciNum):\n    # Initialize the octal number as an empty string\n    octalNum = \"\"\n    \n    # Loop until the decimal number is greater than 0\n    while deciNum > 0:\n        # Find the remainder when the decimal number is divided by 8\n        remainder = deciNum % 8\n        # Prepend the remainder to the octal number string\n        octalNum = str(remainder) + octalNum\n        # Update the decimal number by dividing it by 8\n        deciNum = deciNum // 8\n    \n    # Return the octal number\n    return octalNum"}
{"task_id": 468, "completion": "def max_product(arr, n):\n    # Base case: If the array is empty, return 0\n    if n == 0:\n        return 0\n\n    # Initialize a dp array where dp[i] will store the maximum product\n    # subsequence ending with arr[i]\n    dp = [0] * n\n\n    # The minimum product subsequence ending with the first element is the element itself\n    dp[0] = arr[0]\n\n    # Fill the dp array\n    for i in range(1, n):\n        # Initialize current max product as the current element\n        # This covers the case where the element itself starts a new subsequence\n        current_max = arr[i]\n        for j in range(i):\n            # Check if arr[i] can extend the subsequence ending with arr[j]\n            if arr[i] > arr[j]:\n                # Update current max product if a larger product is found\n                current_max = max(current_max, dp[j] * arr[i])\n        # Update dp[i] with the maximum product found\n        dp[i] = current_max\n\n    # The answer is the maximum value in dp[]\n    return max(dp)\n`"}
{"task_id": 469, "completion": "def max_profit(prices, k):\n    if not prices or k == 0:\n        return 0\n\n    n = len(prices)\n    if k >= n // 2:\n        # If k is larger than half the number of days, it's as if we can do unlimited transactions\n        return sum(max(prices[i + 1] - prices[i], 0) for i in range(n - 1))\n\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(k + 1)]\n\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n\n    return dp[k][n - 1]\n`"}
{"task_id": 470, "completion": "def add_pairwise(tup1, tup2):\n    \"\"\"\n    Adds elements pairwise from two tuples.\n\n    Parameters:\n    - tup1: First tuple of numbers.\n    - tup2: Second tuple of numbers.\n\n    Returns:\n    A tuple containing the pairwise sums of the elements from tup1 and tup2.\n    \"\"\"\n    # Ensure the tuples are of the same length\n    if len(tup1) != len(tup2):\n        print(\"Tuples are of different lengths. Only matching pairs will be added.\")\n    \n    # Use a generator expression to add elements pairwise and convert the result to a tuple\n    result = tuple(a + b for a, b in zip(tup1, tup2))\n    \n    return result"}
{"task_id": 471, "completion": "def find_remainder(arr, n):\n    \"\"\"\n    Find the remainder of the multiplication of all elements in arr divided by n.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The divisor.\n\n    Returns:\n    int: The remainder of the product of all elements in arr divided by n.\n    \"\"\"\n    # Initialize result as 1 (the identity value for multiplication)\n    result = 1\n\n    # Iterate through all elements in the array\n    for element in arr:\n        # Update result by multiplying with the current element and taking remainder\n        # This helps in avoiding overflow for large numbers\n        result = (result * (element % n)) % n\n\n    return result\n`"}
{"task_id": 472, "completion": "def check_consecutive(l):\n    # Sort the list\n    sorted_list = sorted(l)\n    \n    # Iterate through the sorted list to check if numbers are consecutive\n    for i in range(len(sorted_list) - 1):\n        if sorted_list[i] + 1 != sorted_list[i + 1]:\n            return False\n    return True"}
{"task_id": 473, "completion": "def tuple_intersection(test_list1, test_list2):\n    # Step 1: Normalize the tuples by sorting the elements within each tuple\n    normalized_list1 = [tuple(sorted(tup)) for tup in test_list1]\n    normalized_list2 = [tuple(sorted(tup)) for tup in test_list2]\n    \n    # Step 2: Convert the lists to sets of tuples\n    set1 = set(normalized_list1)\n    set2 = set(normalized_list2)\n    \n    # Step 3: Find the intersection\n    intersection = set1.intersection(set2)\n    \n    # Step 4: Return the result (convert to list if necessary)\n    return list(intersection)"}
{"task_id": 474, "completion": "def replace_char(str1, ch, newch):\n    # Replace all occurrences of ch with newch in str1\n    return str1.replace(ch, newch)"}
{"task_id": 475, "completion": "def sort_counter(counter):\n    # Sort the counter by value and return a list of (key, value) pairs\n    return sorted(counter.items(), key=lambda x: x[1], reverse=True)"}
{"task_id": 476, "completion": "def big_sum(nums):\n    # Check if the list is empty\n    if not nums:\n        return \"The list is empty\"\n    \n    # Find the smallest and largest values\n    smallest = min(nums)\n    largest = max(nums)\n    \n    # Return their sum\n    return smallest + largest"}
{"task_id": 477, "completion": "def is_lower(string):\n    return string.lower()"}
{"task_id": 478, "completion": "def remove_lowercase(str1):\n    # Initialize an empty string to store the result\n    result = \"\"\n    # Iterate through each character in the input string\n    for char in str1:\n        # Check if the character is not lowercase\n        if not char.islower():\n            # If it's not lowercase, add it to the result string\n            result += char\n    # Return the result string\n    return result"}
{"task_id": 479, "completion": "def first_digit(n):\n    # Convert the number to a string\n    n_str = str(n)\n    \n    # Check if the number is negative\n    if n_str[0] == '-':\n        # If negative, the first digit is at index 1\n        return n_str[1]\n    else:\n        # If positive, the first digit is at index 0\n        return n_str[0]"}
{"task_id": 480, "completion": "def get_max_occuring_char(str1):\n    # Dictionary to store the count of each character\n    char_count = {}\n    \n    # Iterate through the string to count each character\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the character with the maximum count\n    max_count = 0\n    max_char = ''\n    for char, count in char_count.items():\n        if count > max_count:\n            max_count = count\n            max_char = char\n    \n    return max_char\n`"}
{"task_id": 481, "completion": "def is_subset_sum(set, n, sum):\n    # Create a 2D array to store the results of subproblems\n    dp = [[False for _ in range(sum + 1)] for _ in range(n + 1)]\n    \n    # Base Case: If sum is 0, then answer is true\n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    # Fill the dp array in a bottom-up manner\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            # If the current element is greater than the sum, we can't include it\n            if set[i-1] > j:\n                dp[i][j] = dp[i-1][j]\n            else:\n                # Check if sum can be obtained by any of the following:\n                # (a) including the current element\n                # (b) excluding the current element\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-set[i-1]]\n    \n    return dp[n][sum]"}
{"task_id": 482, "completion": "def match(text):\n    # Define the regex pattern\n    pattern = r'([A-Z][a-z]+)'\n    \n    # Find all matches of the pattern in the text\n    matches = re.findall(pattern, text)\n    \n    # Return the list of matches\n    return matches"}
{"task_id": 483, "completion": "def first_Factorial_Divisible_Number(x):\n    # Function to calculate factorial\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n-1)\n    \n    # Start checking from 1 onwards\n    n = 1\n    while True:\n        if factorial(n) % x == 0:\n            return n\n        n += 1"}
{"task_id": 484, "completion": "def remove_matching_tuple(test_list1, test_list2):\n    # Using list comprehension to remove matching tuples\n    # It creates a new list containing only the tuples that are not found in both lists\n    result_list1 = [tup for tup in test_list1 if tup not in test_list2]\n    result_list2 = [tup for tup in test_list2 if tup not in test_list1]\n    \n    return result_list1, result_list2"}
{"task_id": 485, "completion": "def find_largest_palindrome(arr):\n    \"\"\"\n    Find the largest palindromic number in the given array.\n    \"\"\"\n    largest_palindrome = -1  # Assuming all numbers are positive. Adjust accordingly if negative numbers are included.\n    for num in arr:\n        if is_palindrome(num) and num > largest_palindrome:\n            largest_palindrome = num\n    return largest_palindrome if largest_palindrome != -1 else None"}
{"task_id": 486, "completion": "def binomial_probability(n, r, p):\n    return nCr(n, r) * (p ** r) * ((1 - p) ** (n - r))"}
{"task_id": 487, "completion": "def sort_tuple(tup):\n    # Use the sorted function with a key that returns the last element of each tuple\n    return sorted(tup, key=lambda x: x[-1])"}
{"task_id": 488, "completion": "import math\n\ndef area_pentagon(a):\n    return (1/4) * math.sqrt(5 * (5 + 2 * math.sqrt(5))) * a**2"}
{"task_id": 489, "completion": "def frequency_Of_Largest(n, arr):\n    # Step 1: Find the maximum value in the array\n    max_value = max(arr)\n    \n    # Step 2: Count the frequency of the maximum value\n    frequency = arr.count(max_value)\n    \n    return frequency"}
{"task_id": 490, "completion": "def extract_symmetric(test_list):\n    # This set will hold the symmetric pairs\n    symmetric_pairs = set()\n    \n    # Convert each tuple to a frozenset so that order doesn't matter,\n    # and we can easily check for symmetry.\n    for item in test_list:\n        # Check if the reverse tuple exists in the list\n        if (item[1], item[0]) in test_list:\n            # Add the symmetric pair to the set. Using frozenset to handle symmetry.\n            symmetric_pairs.add(frozenset(item))\n    \n    # Convert each frozenset back to tuple for the final result\n    result = [tuple(pair) for pair in symmetric_pairs]\n    return result\n`"}
{"task_id": 491, "completion": "def sum_gp(a, n, r):\n    \"\"\"\n    Calculate the sum of the first n terms of a geometric progression.\n\n    Parameters:\n    a (float): The first term of the geometric progression.\n    n (int): The number of terms to sum.\n    r (float): The common ratio of the geometric progression.\n\n    Returns:\n    float: The sum of the first n terms of the geometric progression.\n    \"\"\"\n    # Check if the common ratio is 1\n    if r == 1:\n        return a * n\n    else:\n        # Calculate the sum using the formula\n        return a * (1 - r ** n) / (1 - r)\n`"}
{"task_id": 492, "completion": "def binary_search(item_list, item):\n    low = 0\n    high = len(item_list) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        guess = item_list[mid]\n        if guess == item:\n            return mid  # Item found, return its index\n        if guess > item:\n            high = mid - 1  # Item is in the left half\n        else:\n            low = mid + 1  # Item is in the right half\n    return None  # Item doesn't exist in the list"}
{"task_id": 493, "completion": "import math\n\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    # Calculate the width and height of the hexagon\n    hex_width = math.sqrt(3) * radius\n    hex_height = 1.5 * radius\n    \n    # Initialize the list to store the centers of the hexagons\n    hex_centers = []\n    \n    # Calculate the row and column increments\n    row_increment = hex_height\n    col_increment = hex_width\n    \n    # Initialize y coordinate\n    y = starty\n    \n    # Calculate the number of rows and columns\n    while y + radius * 2 <= endy:\n        x_offset = 0\n        if (y / hex_height) % 2 == 1:\n            # For every other row, offset x to interlock the hexagons\n            x_offset = hex_width / 2\n        x = startx + x_offset\n        while x + radius * 2 <= endx:\n            # For each center, calculate the vertices of the hexagon\n            vertices = []\n            for i in range(6):\n                angle_deg = 60 * i + 30\n                angle_rad = math.pi / 180 * angle_deg\n                vertices.append((x + radius * math.cos(angle_rad),\n                                 y + radius * math.sin(angle_rad)))\n            hex_centers.append(vertices)\n            x += col_increment\n        y += row_increment\n    \n    return hex_centers\n`"}
{"task_id": 494, "completion": "def binary_to_integer(test_tup):\n    # Initialize the result variable to 0\n    result = 0\n    # Iterate over the tuple\n    for bit in test_tup:\n        # Shift the result one bit to the left and add the current bit to it\n        result = (result << 1) | bit\n    return result"}
{"task_id": 495, "completion": "import re\n\ndef remove_lowercase(str1):\n    # This regex pattern matches one or more lowercase letters\n    pattern = '[a-z]+'\n    # Replace the matched lowercase substrings with an empty string\n    result = re.sub(pattern, '', str1)\n    return result"}
{"task_id": 496, "completion": "def heap_queue_smallest(nums, n):\n    \"\"\"\n    Find the n smallest integers from a given list nums using heap queue algorithm.\n    \n    Parameters:\n    nums (list): The list of numbers from which to find the smallest integers.\n    n (int): The number of smallest integers to find.\n    \n    Returns:\n    list: A list of the n smallest integers from the given list.\n    \"\"\"\n    # Use heapq.nsmallest to find the n smallest elements\n    return heapq.nsmallest(n, nums)"}
{"task_id": 497, "completion": "def surfacearea_cone(r, h):\n    # Calculate the slant height of the cone\n    l = math.sqrt(h**2 + r**2)\n    # Calculate the surface area using the formula\n    surface_area = math.pi * r * (r + l)\n    return surface_area"}
{"task_id": 498, "completion": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x"}
{"task_id": 499, "completion": "def diameter_circle(r):\n    return 2 * r"}
{"task_id": 500, "completion": "def concatenate_elements(input_list):\n    # Initialize an empty string to hold the concatenated result\n    result = \"\"\n    # Iterate through each element in the list\n    for element in input_list:\n        # Convert the element to a string (in case it's not) and concatenate\n        result += str(element)\n    # Return the concatenated string\n    return result"}
{"task_id": 501, "completion": "def find_common_divisors(x, y):\n    # Initialize an empty list to store common divisors\n    common_divisors = []\n    \n    # The maximum possible divisor is the smaller of the two numbers\n    for i in range(1, min(x, y) + 1):\n        if x % i == 0 and y % i == 0:\n            common_divisors.append(i)\n    \n    return common_divisors"}
{"task_id": 502, "completion": "def find_remainder(n, m):\n    \"\"\"\n    Returns the remainder of n divided by m.\n    \n    Parameters:\n    n (int): The dividend.\n    m (int): The divisor.\n    \n    Returns:\n    int: The remainder of the division.\n    \"\"\"\n    return n % m"}
{"task_id": 503, "completion": "def add_consecutive_nums(nums):\n    # Check if the list is empty or contains only one element\n    if not nums or len(nums) == 1:\n        return nums\n    \n    # Initialize an empty list to store the sums\n    result = []\n    \n    # Iterate through the list, except for the last element\n    for i in range(len(nums) - 1):\n        # Add the current element and the next one, then append the sum to the result list\n        result.append(nums[i] + nums[i + 1])\n    \n    return result"}
{"task_id": 504, "completion": "def sum_of_series(n):\n    # Calculate the sum of cubes of first n natural numbers\n    sum = (n * (n + 1) // 2) ** 2\n    return sum"}
{"task_id": 505, "completion": "def re_order(A):\n    # Index to place the next non-zero element\n    position = 0\n    \n    # Loop through the array\n    for i in range(len(A)):\n        # If the current element is not zero,\n        # place it at the 'position' index and increment 'position'\n        if A[i] != 0:\n            A[position] = A[i]\n            position += 1\n    \n    # After all non-zero elements have been moved to the beginning,\n    # fill the rest of the array with zeroes\n    for i in range(position, len(A)):\n        A[i] = 0\n`"}
{"task_id": 506, "completion": "def permutation_coefficient(n, k):\n    \"\"\"Function to calculate the permutation coefficient P(n, k).\"\"\"\n    if k > n:\n        return 0  # Since we cannot choose more elements than available\n    else:\n        return factorial(n) // factorial(n-k)"}
{"task_id": 507, "completion": "def remove_words(list1, removewords):\n    # Using list comprehension to filter out the words to be removed\n    result = [word for word in list1 if word not in removewords]\n    return result"}
{"task_id": 508, "completion": "def same_order(l1, l2):\n    # Find common elements while preserving the order in l1\n    common_elements = [element for element in l1 if element in l2]\n    \n    # Iterator for traversing the common elements\n    common_iter = iter(common_elements)\n    \n    # Try to find the common elements in l2 in the same order\n    try:\n        for element in l2:\n            if element == next(common_iter):\n                continue\n    except StopIteration:\n        # If StopIteration is raised, all common elements have been found in order\n        return True\n    \n    # If not all common elements were found in order, check if we actually went through all of them\n    return all(element not in l2 for element in common_iter)\n`"}
{"task_id": 509, "completion": "def average_odd(n):\n    # Check if n is odd\n    if n % 2 == 0:\n        return \"Input must be an odd number\"\n    \n    # Generate list of odd numbers up to n\n    odd_numbers = list(range(1, n+1, 2))\n    \n    # Calculate the sum of odd numbers\n    total_sum = sum(odd_numbers)\n    \n    # Calculate the average\n    average = total_sum / len(odd_numbers)\n    \n    return average"}
{"task_id": 510, "completion": "def countSubsequences(arr, n, k, pos=0, product=1):\n    \"\"\"\n    Counts the number of subsequences having product smaller than k.\n    \n    :param arr: List of non-negative integers.\n    :param n: Size of the array.\n    :param k: The product threshold.\n    :param pos: Current position in the array.\n    :param product: Current product of the subsequence.\n    :return: Number of subsequences with product less than k.\n    \"\"\"\n    # Base cases\n    if product >= k:\n        return 0\n    if pos == n:\n        return 1  # Empty subsequence\n    \n    # Count including the current element\n    include_count = countSubsequences(arr, n, k, pos + 1, product * arr[pos])\n    \n    # Count excluding the current element\n    exclude_count = countSubsequences(arr, n, k, pos + 1, product)\n    \n    # Return the sum of both counts, subtract 1 to exclude the empty subsequence counted twice\n    return include_count + exclude_count - 1\n`"}
