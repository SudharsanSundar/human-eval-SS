{"task_id": 11, "completion": "def remove_Occ(s, ch):\n   s = list(s)\n   for i in range(len(s)):\n      if(s[i] == ch):\n         s[i] = \"\"\n         break\n   for i in range(len(s) - 1, -1, -1):\n      if(s[i] == ch):\n         s[i] = \"\"\n         break\n   return \"\".join(s)"}
{"task_id": 12, "completion": "def sort_matrix(M):\n    # computing sum of each row\n    sum_rows = [sum(row) for row in M]\n    # Zipping the rows and their sums and then sorting\n    # according to sums\n    sorted_matrix = [row for _, row in sorted(zip(sum_rows, M))]\n    return sorted_matrix"}
{"task_id": 13, "completion": "def count_common(words):\n    # Flatten the list if the values in the dictionary are lists\n    if isinstance(list(words.values())[0], list):\n        words = [word for sublist in words.values() for word in sublist]\n\n    # Convert to lowercase for accurate comparison\n    words = [word.lower() for word in words]\n    \n    # Use Counter to count occurrences of each word\n    counts = Counter(words)\n    \n    # Get the most common words\n    common_words = counts.most_common()\n    \n    return common_words"}
{"task_id": 14, "completion": "def find_Volume(l, b, h):\n    # Calculate the volume of a triangular prism\n    volume = 0.5 * l * b * h\n\n    # Return the result\n    return volume"}
{"task_id": 15, "completion": "def split_lowerstring(text):\n    # split the text where a lowercase letter is found\n    splits = re.split('([a-z])', text)\n\n    return splits"}
{"task_id": 16, "completion": "def text_lowercase_underscore(text):\n    pattern = '[a-z]+_[a-z]+'\n    matches = re.findall(pattern, text)\n    return matches"}
{"task_id": 17, "completion": "def square_perimeter(a):\n    return 4 * a"}
{"task_id": 18, "completion": "def str_to_list(str1, str2):\n    result = [char for char in str1 if char not in str2]\n    return ''.join(result)"}
{"task_id": 19, "completion": "def test_duplicate(arraynums):\n    # Using 'set' data structure which does not allow duplicates.\n    # If the length of the set is less than the length of the list, then we have duplicates.\n    if len(arraynums) > len(set(arraynums)):\n        return True\n    else:\n        return False\n`"}
{"task_id": 20, "completion": "def is_woodall(n):\n    for i in range(1, n+1): \n        if n == i * 2**i - 1: \n            return True \n    return False"}
{"task_id": 21, "completion": "def multiples_of_num(m, n):\n    multiples = []\n    for i in range(1, m+1):\n        multiples.append(n * i)\n    return multiples"}
{"task_id": 22, "completion": "def find_first_duplicate(nums):\n    num_set = set()\n    first_duplicate = -1\n\n    for i in range(len(nums)):\n        if nums[i] in num_set:\n            first_duplicate = nums[i]\n            break\n        else:\n            num_set.add(nums[i])\n            \n    return first_duplicate"}
{"task_id": 23, "completion": "def maximum_sum(lists):\n    # We use the built-in max function and a comprehension to find the list with the greatest sum\n    return max(lists, key=sum)"}
{"task_id": 24, "completion": "def binary_to_decimal(binary):\n    binary = str(binary)  # ensures the input is string\n    decimal, i, n = 0, 0, 0\n    while(binary != 0): \n        digit = binary % 10\n        decimal = decimal + digit * pow(2, i)\n        binary = binary//10\n        i += 1\n    return decimal"}
{"task_id": 25, "completion": "def find_Product(arr,n):\n    arr_set = set(arr)  # sets are unordered collections of unique elements\n    product = 1\n    for i in arr_set:\n        product *= i  # multiplies each unique element together\n    return product"}
{"task_id": 26, "completion": "def check_k_elements(test_list, K):\n    for tup in test_list:\n        if len(tup) != K:\n            return False\n    return True"}
{"task_id": 27, "completion": "def remove_digits_from_list(lst):\n    new_list = []\n    for s in lst:\n        new_s = ''.join([i for i in s if not i.isdigit()])\n        new_list.append(new_s)\n    return new_list"}
{"task_id": 28, "completion": "def binomial_coeff(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    binom_coeff = math.factorial(n) // (math.factorial(k) * math.factorial(n - k))\n    return binom_coeff"}
{"task_id": 29, "completion": "def get_Odd_Occurrence(arr):\n    # Create a dictionary to count occurrences of each element\n    dic = {}\n\n    # Iterate over each element in the array\n    for i in arr:\n\n        # If element exists in dic then increment its value else add it in dic\n        if i in dic:\n            dic[i] += 1\n        else:\n            dic[i] = 1\n\n    # Iterate over dictionary and check if count is odd.\n    # If count of element is odd, return that element\n    for i in dic:\n        if dic[i] % 2 != 0:\n            return i\n\n    return None\n`"}
{"task_id": 30, "completion": "def count_substrings(s):\n    n = len(s) \n    count = 0\n  \n    # Iterating through all substrings in string s\n    for i in range(n): \n        for j in range(i, n): \n            # If first and last characters of substring are the same\n            if (s[i] == s[j]): \n                count += 1\n  \n    return count"}
{"task_id": 31, "completion": "def top_k_frequent(nums, k):\n    # Count the occurrences of each number\n    count = Counter(nums)\n    # Use a heap to store the top k frequent elements\n    heap, result = [], []\n    # Push elements into the heap \n    for number, frequency in count.items():\n        heapq.heappush(heap, (-frequency, number))\n\n    # Pop elements from the heap \n    for _ in range(k):\n        result.append(heapq.heappop(heap)[1])\n    return result"}
{"task_id": 32, "completion": "def max_Prime_Factors(n):\n    # Largest prime factor can only be at most the square root of the number\n    max_prime = -1\n\n    # Divide by 2 until the number isn't even\n    while n % 2 == 0:\n        max_prime = 2\n        n >>= 1  # equivalent to n /= 2\n\n    # n must be odd at this point, thus skip the even numbers and iterate only for odd\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            max_prime = i\n            n = n / i\n        i += 2\n\n    # if n is a prime number and is greater than 2\n    if n > 2:\n        max_prime = n\n\n    return max_prime"}
{"task_id": 33, "completion": "def decimal_To_Binary(N):\n   if N >= 1:\n       decimal_To_Binary(N // 2)\n   print(N % 2, end = '')"}
{"task_id": 34, "completion": "def find_missing(ar, N):\n    low = 0\n    high = len(ar) - 1\n    while low <= high:\n\n        middle = (low + high) // 2\n\n        if ar[middle] != middle + 1:\n\n            if ar[middle - 1] == middle:\n                return middle + 1\n            else:\n                high = middle - 1\n\n        else:\n            low = middle + 1\n\n    if low+1 != N+1:\n        return low+1\n    else:\n        return -1"}
{"task_id": 35, "completion": "def find_rect_num(n):\n    return n * (n + 1)"}
{"task_id": 36, "completion": "def find_nth_digit(p, q, n):\n    if q == 0:\n        return \"Cannot divide by zero\"\n\n    result = p / q\n\n    # Convert the result to string and remove the decimal point\n    result_str = str(result).replace('.', '')\n\n    # Check if the nth digit exists\n    if n < len(result_str):\n        return int(result_str[n])  # returns the nth digit as integer\n    else:\n        return \"The fraction doesn't have a {}th digit.\".format(n)  # the requested digit does not exist"}
{"task_id": 37, "completion": "def sort_mixed_list(mixed_list):\n    str_list = sorted([i for i in mixed_list if type(i) == str])\n    int_list = sorted([i for i in mixed_list if type(i) == int])\n    return str_list + int_list"}
{"task_id": 38, "completion": "def div_even_odd(list1): \n    #initialize variables for the first even and odd numbers\n    first_even_number = None\n    first_odd_number = None\n\n    #iterate over the entire list to find first even and odd numbers\n    for num in list1: \n        #if number is even and not previously met\n        if num % 2 == 0 and first_even_number is None: \n            first_even_number = num\n        #if number is odd and not previously met\n        elif num % 2 != 0 and first_odd_number is None: \n            first_odd_number = num\n\n        #if both even and odd numbers are found, break the loop\n        if first_even_number is not None and first_odd_number is not None: \n            break\n\n    # if any of them is not found, return None  \n    if first_even_number is None or first_odd_number is None: \n        return None\n    else:\n        #return the division result\n        return first_even_number / first_odd_number\n`"}
{"task_id": 39, "completion": "import heapq\ndef rearrange_string(s):\n    # Count char occurrences\n    occurences = [0]*26\n    for c in s:\n        occurences[ord(c)-ord('a')] += 1\n    \n    # Heapify the occurences\n    max_heap = []\n    for i in range(26):\n        if occurences[i]>0:\n            heapq.heappush(max_heap, (-occurences[i], chr(i+ord('a'))))\n\n    prev_char = ''\n    prev_freq = 0    \n    result = []\n\n    while max_heap:\n        freq, char = heapq.heappop(max_heap)\n\n        # Add previous character back to heap if its frequency was > 1\n        if prev_freq < 0: \n            heapq.heappush(max_heap, (prev_freq, prev_char))\n\n        # Append current character to result and update the prev_char and prev_freq to current\n        result.append(char)\n        prev_char = char\n        prev_freq = freq+1  # decrement the count of current char\n\n    # if result length < original string length, it means it's not possible to rearrange the string\n    return ''.join(result) if len(result)==len(s) else \"\""}
{"task_id": 40, "completion": "def freq_element(nums):\n    # joining all lists into one\n    merged_list = [num for sublist in nums for num in sublist]\n    \n    # using Counter from collections to count frequency\n    freq_count = Counter(merged_list)\n    \n    # return the frequencies\n    return freq_count"}
{"task_id": 41, "completion": "def filter_evennumbers(nums):\n    return list(filter(lambda x: x%2 == 0, nums))"}
{"task_id": 42, "completion": "def find_Sum(arr, n):\n    # Create an empty dictionary\n    dict = {}\n  \n    # Insert array elements to the dictionary\n    for i in range(n):\n        key = arr[i]\n        if key not in dict:\n            dict[key] = 1  # increment by one\n        else:\n            dict[key] += 1  # this is a repeated element\n\n    # Sum of repeated elements\n    sum = 0\n    for i in dict:        \n        count = dict[i]  \n        if (count > 1):  # if element is repeated, add to sum\n            sum += i  \n\n    return sum\n`"}
{"task_id": 43, "completion": "import re\n\ndef text_match(text):\n    pattern = '[a-z]+_[a-z]+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not a match!'"}
{"task_id": 44, "completion": "import re\n\ndef text_match_string(word, text):\n  return bool(re.match(word, text))"}
{"task_id": 45, "completion": "def find_gcd(x, y):\n    while(y):\n        x, y = y, x % y\n    return x"}
{"task_id": 46, "completion": "def test_distinct(data):\n    if len(data) == len(set(data)):\n        return True\n    else:\n        return False"}
{"task_id": 47, "completion": "def compute_last_digit(a, b):\n  \n    def factorial(n): \n        if n == 0: \n            return 1\n        else: \n            return n * factorial(n-1)\n\n    result = factorial(a) / factorial(b)\n    return str(result)[-1]"}
{"task_id": 48, "completion": "def odd_bit_set_number(n):\n   # uses bitwise OR operation to set all odd bits\n   return (n | 0xAAAAAAAA)"}
{"task_id": 49, "completion": "def specified_element(nums, N=1):\n    res = []\n    for sublist in nums:\n        try:\n            res.append(sublist[N-1]) # Indexing starts from 0\n        except IndexError:\n            continue  # skip if sublist is not long enough\n    return res\n`"}
{"task_id": 50, "completion": "def min_length_list(input_list):\n    return min(input_list, key=lambda x: len(x))"}
{"task_id": 51, "completion": "def check_equilateral(x, y, z):\n    if x <= 0 or y <= 0 or z <= 0:\n        return \"Invalid lengths. Lengths must be greater than zero.\"\n    \n    if x==y==z:\n        return \"This is an equilateral triangle.\"\n    else:\n        return \"This is not an equilateral triangle.\""}
{"task_id": 52, "completion": "def parallelogram_area(b, h):\n    # b = base\n    # h = height\n    # formula for parallelogram area: base * height\n    area = b * h\n    return area"}
{"task_id": 53, "completion": "def check_equality(str):\n    if len(str) == 0:\n        return False\n    else:\n        return str[0] == str[-1]"}
{"task_id": 54, "completion": "def counting_sort(my_list):\n    if my_list: \n        min_value = min(my_list)\n        max_value = max(my_list)\n        count_list = [0] * (max_value - min_value + 1)\n\n        # Counting the occurrence of each number in the list\n        for number in my_list:\n            count_list[number - min_value] += 1\n\n        # Reconstructing the sorted list\n        sorted_list = []\n        for i, count in enumerate(count_list):\n            sorted_list.extend([i + min_value] * count)\n\n        return sorted_list\n    else:\n        return []"}
{"task_id": 55, "completion": "def tn_gp(a, n, r):\n    '''\n    a: first term of the geometric progression\n    n: nth term to be found \n    r: common ratio\n    returns the nth term of geometric progression\n\n    The nth term t_n of a geometric sequence with initial term a and common ratio r is given by:\n    t_n = ar^(n-1)\n    '''\n    \n    return a * (r ** (n - 1))"}
{"task_id": 56, "completion": "def is_one_less(num):\n    # first, we calculate the reverse of the number\n    reverse_num = int(str(num)[::-1])\n    \n    # then we check if our condition is met:\n    # is the number one less than twice its reverse?\n    if num == 2*reverse_num - 1:\n        return True\n    else:\n        return False"}
{"task_id": 57, "completion": "def find_Max_Num(arr):\n    # Convert integer array to string array\n    arr = [str(i) for i in arr]\n    \n    # Sort the array in descending order\n    arr.sort(reverse = True)\n    \n    # Combine the strings elements into a single string\n    max_num = ''.join(arr)\n    \n    # Return the maximum number\n    return max_num"}
{"task_id": 58, "completion": "def opposite_Signs(x, y):\n    # If x*y < 0 then the two numbers have opposite sign\n    return ((x ^ y) < 0)"}
{"task_id": 59, "completion": "def is_octagonal(n):\n    return n * (3 * n - 2)"}
{"task_id": 60, "completion": "def max_len_sub(arr, n):\n    # Create and initialize an array to store dp values\n    dp = [1 for _ in range(n)]\n \n    # Iterate for all elements\n    for i in range(n):\n        for j in range(i):\n \n            # If this element is in an increasing sequence with a previous element\n            if (abs(arr[i] - arr[j]) == 1):\n \n                # Increase the max length for this \n                dp[i] = max(dp[i], dp[j] + 1)\n\n    # Maximum value from dp[] is the result\n    return max(dp)"}
{"task_id": 61, "completion": "def count_Substrings(s,n):\n    #initialize count to 0\n    count = 0\n\n    #iterate through the string\n    for i in range(n):\n        sum = 0\n\n        #generate substrings starting at each character\n        for j in range(i,n):\n\n            #add the integer value of each character to sum \n            sum += int(s[j])\n            \n            #if the sum is equal to length of substring, increment count\n            if sum == (j-i+1):\n                count += 1\n    #return the total count          \n    return count"}
{"task_id": 62, "completion": "def smallest_num(xs):\n    return min(xs)"}
{"task_id": 63, "completion": "def max_difference(test_list):\n    # Convert list of tuples into a list of individual elements\n    flat_list = [num for tup in test_list for num in tup]\n    \n    # Find max and min in the flattened list\n    max_val = max(flat_list)\n    min_val = min(flat_list)\n    \n    # Return the difference\n    return max_val - min_val"}
{"task_id": 64, "completion": "def sort_subject_marks(subjectmarks):\n    sorted_marks = sorted(subjectmarks, key = lambda x: x[1])\n    return sorted_marks"}
{"task_id": 65, "completion": "def recursive_list_sum(data_list):\n    total = 0\n    for element in data_list:\n        if type(element) == type([]):\n            total = total + recursive_list_sum(element)\n        else:\n            total = total + element\n    return total"}
{"task_id": 66, "completion": "def pos_count(lst):\n    count = 0\n    for num in lst:\n        if num > 0:\n            count += 1\n    return count"}
{"task_id": 67, "completion": "def bell_number(n):\n    bell = [[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    return bell[n][0]"}
{"task_id": 68, "completion": "def is_Monotonic(A):\n\n    if all(A[i] <= A[i + 1] for i in range(len(A) - 1)):\n        return True\n    elif all(A[i] >= A[i + 1] for i in range(len(A) - 1)):\n        return True\n    return False"}
{"task_id": 69, "completion": "def is_sublist(l, s):\n    sub_set = False\n    if s == []:\n        sub_set = True\n    elif s == l:\n        sub_set = True\n    elif len(s) > len(l):\n        sub_set = False\n\n    else:\n        for i in range(len(l)):\n            if l[i] == s[0]:\n                n = 1\n                while (n < len(s)) and (l[i+n] == s[n]):\n                    n += 1\n                \n                if n == len(s):\n                    sub_set = True\n\n    return sub_set\n`"}
{"task_id": 70, "completion": "def find_equal_tuple(Input, k):\n    for tup in Input:\n        if len(tup) != k:\n            # Returns False as soon as it finds a tuple of non-equal length\n            return False\n    # If code reaches here, it means all tuples have equal length\n    return True"}
{"task_id": 71, "completion": "def comb_sort(nums):\n    def swap(nums, i, j):\n        nums[i], nums[j] = nums[j], nums[i]\n\n    gap = len(nums)\n    shrink = 1.3\n    sorted = False\n\n    while not sorted:\n        gap = int(gap / shrink)\n\n        if gap <= 1:\n            gap = 1\n            sorted = True\n\n        i = 0\n\n        while i + gap < len(nums):\n            if nums[i] > nums[i + gap]:\n                swap(nums, i, i + gap)\n                sorted = False\n            i += 1\n    return nums"}
{"task_id": 72, "completion": "def dif_Square(n):\n    # If n is even, return True\n    if n % 2 == 0:\n        return True\n    # If n is a multiple of an odd number greater than 1, return True\n    elif any(n % i == 0 for i in range(3, int(n ** 0.5) + 1, 2)):\n        return True\n    return False"}
{"task_id": 73, "completion": "def multiple_split(text, delimiters = [\" \", \",\", \".\"]):\n    regexPattern = '|'.join(map(re.escape, delimiters))\n    return re.split(regexPattern, text)"}
{"task_id": 74, "completion": "def is_samepatterns(colors, patterns):\n    patterns_dict = {pat: color for pat, color in zip(patterns, colors)}\n    for color, pattern in zip(colors, patterns):\n        if patterns_dict[pattern] != color:\n            return False\n    return True"}
{"task_id": 75, "completion": "def find_tuples(test_list, K):\n    # Using list comprehension and all() \n    result = [tup for tup in test_list if all(ele % K == 0 for ele in tup)]\n  \n    return result"}
{"task_id": 76, "completion": "def count_Squares(m, n): \n    squares = 0 \n    for i in range(1, min(m, n) + 1): \n        squares += (m - i + 1) * (n - i + 1) \n    return squares"}
{"task_id": 77, "completion": "def is_Diff(n):\n    odd_sum = 0\n    even_sum = 0\n    while n > 0:\n        digit = n % 10\n        if digit % 2 == 0:\n            even_sum += digit\n        else:\n            odd_sum += digit\n        n = n // 10\n    return abs(even_sum - odd_sum)"}
{"task_id": 78, "completion": "def count_with_odd_set_bits(n):\n    count = 0\n    for i in range(n+1):\n        if bin(i).count('1') % 2 != 0:  # checks if the number of set bits is odd\n            count += 1\n    return count"}
{"task_id": 79, "completion": "def word_len(s):\n    if len(s) % 2 == 0:\n        return 'Even'\n    else:\n        return 'Odd'"}
{"task_id": 80, "completion": "def tetrahedral_number(n):\n    return n*(n+1)*(n+2)//6"}
{"task_id": 81, "completion": "def zip_tuples(tup1, tup2):\n    # Use the built-in zip() function to zip the tuples\n    zip_result = zip(tup1, tup2)\n\n    # Convert the zip object into a tuple and return it\n    return tuple(zip_result)"}
{"task_id": 82, "completion": "def volume_sphere(r):\n    return (4/3) * math.pi * (r**3)"}
{"task_id": 83, "completion": "def get_Char(strr):\n    # Initialize sum\n    sum = 0\n\n    # Get ASCII value of each character and add to sum\n    for char in strr:\n        sum += ord(char)\n\n    # Convert sum back to character and return\n    return chr(sum % 256)"}
{"task_id": 84, "completion": "def newman_conway(n):\n    if n <= 0:\n        return \"Invalid Number\"\n        \n    # Initial two values of Newman-conway sequence\n    P = [0, 1, 1] + [0] * (n - 2)\n    \n    # calculate sequence values\n    for i in range(3, n + 1):\n        P[i] = P[P[i - 1]] + P[i - P[i - 1]]\n    \n    return P[n]"}
{"task_id": 85, "completion": "def surfacearea_sphere(r):\n    return 4 * math.pi * r**2"}
{"task_id": 86, "completion": "def centered_hexagonal_number(n):\n    return 3*n*(n-1)+1"}
{"task_id": 87, "completion": "def merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = {**dict1, **dict2, **dict3}\n    return merged_dict"}
{"task_id": 88, "completion": "def freq_count(list1):\n    # Initialize a dictionary to hold the frequency counts.\n    frequency_dict = {}\n\n    # Iterate over the list.\n    for item in list1:\n        # If the item is already in the dictionary, increment its count.\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1.\n        else:\n            frequency_dict[item] = 1\n\n    return frequency_dict"}
{"task_id": 89, "completion": "def closest_num(n):\n    return n - 1"}
{"task_id": 90, "completion": "def len_long(list1):\n    return max(len(x) for x in list1)"}
{"task_id": 91, "completion": "def find_substring(str1, sub_str):\n    if sub_str in str1:\n        return True\n    else:\n        return False"}
{"task_id": 92, "completion": "def is_undulating(n):\n    # Convert to string for easier manipulation\n    n = str(n)\n\n    # The number should be at least 3 digits\n    if len(n) < 3:\n        return False\n\n    # All digits in the number must be the same or alternate\n    return all(n[i] == n[i - 2] for i in range(2, len(n)))\n`"}
{"task_id": 93, "completion": "def power(a, b):\n    return a ** b"}
{"task_id": 94, "completion": "def index_minimum(test_list):\n    # get the index of tuple in the list with the minimum value\n    min_index = min(range(len(test_list)), key = test_list.__getitem__)\n    return min_index"}
{"task_id": 95, "completion": "def find_min_length(lst):\n    if len(lst) == 0: \n        return 0 \n    return min(len(sublst) for sublst in lst if isinstance(sublst, list))"}
{"task_id": 96, "completion": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count = count + 1\n    return count"}
{"task_id": 97, "completion": "from collections import Counter\nfrom itertools import chain\n\ndef frequency_lists(list1):\n    # chain.from_iterable flattens the list of lists.\n    flat_list = list(chain.from_iterable(list1))\n    return dict(Counter(flat_list))"}
{"task_id": 98, "completion": "def multiply_num(numbers):\n    # Initialize the result as 1\n    result = 1\n\n    # Iterate through the list and multiply each number\n    for num in numbers:\n        result *= num\n\n    # Divide by the length of the list\n    return result / len(numbers)"}
{"task_id": 99, "completion": "def decimal_to_binary(n):\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary"}
{"task_id": 100, "completion": "def next_smallest_palindrome(num):\n    num = num + 1\n    while True:\n        if str(num) == str(num)[::-1]:  # checks if the number is a palindrome\n            return num\n        num += 1  # increment the current number if it's not a palindrome"}
{"task_id": 101, "completion": "def kth_element(arr, k):\n    try:\n        return arr[k]\n    except IndexError:\n        print('The given index is out of range.')\n        return None"}
{"task_id": 102, "completion": "def snake_to_camel(word):\n    import re\n    return ''.join(x.capitalize() or '_' for x in word.split('_'))"}
{"task_id": 103, "completion": "def eulerian_num(n, m): \n    euler_num = 0\n    # Apply Euler number formula\n    for i in range(m+1): \n        euler_num += ((-1)**i) * fact(n+1) * fact(m) / (fact(i) * fact(m - i) * fact(n - m + i + 1))\n    return int(euler_num)"}
{"task_id": 104, "completion": "def sort_sublists(input_list):\n    sorted_list = [sorted(sublist, key=lambda x: x) for sublist in input_list]\n    return sorted_list"}
{"task_id": 105, "completion": "def count(lst):\n    return sum([1 for i in lst if i is True])"}
{"task_id": 106, "completion": "def add_lists(test_list, test_tup):\n    # convert tuple to list\n    test_tup_to_list = list(test_tup)\n    # append the lists\n    result = test_list + test_tup_to_list\n    return result"}
{"task_id": 107, "completion": "def count_hexadecimal(L, R): \n    count = 0\n    for i in range(L, R+1):\n        try:\n            if int(hex(i), 16):\n                count += 1\n        except ValueError:\n            continue\n    return count"}
{"task_id": 108, "completion": "import heapq\n\ndef merge_sorted_list(*args):\n    # Convert the inputs into an iterable, args is a tuple of input arguments\n    sorted_inputs = list(args) \n\n    # Initialize an empty list to store the merged list\n    merged_list = []\n\n    # Use heapq to merge the input lists into one sorted iterator\n    for i in heapq.merge(*sorted_inputs):\n        merged_list.append(i)\n\n    return merged_list\n"}
{"task_id": 109, "completion": "def odd_Equivalent(s, n):\n    # Convert your string to binary\n    s = int(str(s), 2)\n    \n    # Initialize rotation count\n    rotations = 0\n\n    # Iterate through each possible rotation\n    for i in range(n):\n        # Rotate the string\n        s = ((s << 1) | (s >> (n - 1))) & ((1 << n) - 1)\n        \n        # Check if the new value is odd\n        if s % 2 != 0:\n            rotations += 1\n    return rotations"}
{"task_id": 110, "completion": "def extract_missing(test_list, strt_val, stop_val):\n    complete_range = list(range(strt_val, stop_val+1))\n    return [num for num in complete_range if num not in test_list]"}
{"task_id": 111, "completion": "def common_in_nested_lists(nested_list):\n    # Extracts the individual lists from the main one\n    individual_lists = [set(i) for i in nested_list]\n\n    # Finds common elements\n    common_elements = set.intersection(*individual_lists)\n\n    # Returns the common elements\n    return list(common_elements)"}
{"task_id": 112, "completion": "def cylinder_perimeter(diameter, height):\n    \"\"\"\n    This function calculates the perimeter of a cylinder\n    Arguments:\n    diameter : The diameter of the base of the cylinder\n    height : The height of the cylinder\n\n    Returns:\n    The perimeter of the cylinder\n    \"\"\"\n    # calculate the radius\n    radius = diameter / 2\n    # Calculate the perimeter of the two bases + the perimeter of the lateral area\n    perimeter = (2 * 3.14 * radius) * 2 + (2 * 3.14 * radius * height)\n    return perimeter"}
{"task_id": 113, "completion": "def check_integer(text):\n    try:\n        int(text)  # Try to convert the string to integer\n        return True  # If no error, return True\n    except ValueError:  # If a ValueError occurs\n        return False  # The string cannot be converted to integer, return False"}
{"task_id": 114, "completion": "def assign_freq(test_list):\n    freq_dict = {}\n    for tup in test_list:\n        if tup in freq_dict:\n            freq_dict[tup] += 1\n        else:\n            freq_dict[tup] = 1\n    return freq_dict"}
{"task_id": 115, "completion": "def empty_dict(list1):\n    return all(not d for d in list1)"}
{"task_id": 116, "completion": "def tuple_to_int(nums):\n    # join all numbers in the tuple into a single string using map() function and str.join()\n    str_nums = ''.join(map(str, nums))\n    \n    # convert the string into integer using int() function\n    result = int(str_nums)\n    \n    return result"}
{"task_id": 117, "completion": "def list_to_float(test_list):\n    float_list = []\n    for i in test_list:\n        try:\n            float_list.append(float(i))\n        except ValueError:\n            float_list.append(i)\n    return float_list"}
{"task_id": 118, "completion": "def string_to_list(str):\n    # Splitting the string by spaces and storing into a list\n    list_string = str.split(\" \")\n    return list_string"}
{"task_id": 119, "completion": "def search(arr):\n    # Initialize result\n    res = arr[0] \n    \n    # Do XOR of all elements and return the one time appearing element\n    for i in range(1, len(arr)):\n        res = res ^ arr[i]\n    return res"}
{"task_id": 120, "completion": "def max_product_tuple(lst):\n    max_product = float(\"-inf\")\n    for i in lst:\n        for j in lst:\n            if i != j:\n                product = i[0]*j[0] + i[1]*j[1]\n                if product > max_product:\n                    max_product = product\n    return max_product"}
{"task_id": 121, "completion": "def check_triplet(A, n, sum):\n    A.sort()\n    count = 0\n    for i in range(0, n-1):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            if A[i] + A[left] + A[right] == sum:\n                count+=1\n                return True, count\n            elif A[i] + A[left] + A[right] < sum:\n                left += 1\n            else:\n                right -= 1\n    return False, count"}
{"task_id": 122, "completion": "def smartNumber(n):\n    # Initialize variables\n    smart_numbers = []\n    i = 1\n\n    # Loop while we need to get more smart numbers\n    while len(smart_numbers) < n:\n        num_factors = 0\n\n        # Check how many factors a number has\n        for factor in range(1, int(i**0.5) + 1):\n            if i % factor == 0:\n                if i / factor == factor: \n                    num_factors += 1\n                else:\n                    num_factors += 2\n        # If the number of factors is odd, it's a smart number\n        if num_factors % 2 == 1:\n            smart_numbers.append(i)\n        \n        i += 1\n    # Return the nth smart number\n    return smart_numbers[-1]"}
{"task_id": 123, "completion": "def amicable_numbers_sum(limit):\n    amicable_numbers = []\n    for num in range(1, limit):\n        div_sum = d(num)\n        if num != div_sum and d(div_sum) == num:\n            if num not in amicable_numbers:\n                amicable_numbers.extend([num, div_sum])\n    return sum(amicable_numbers)"}
{"task_id": 124, "completion": "import math\n\ndef angle_complex(a, b):\n    angle = math.atan2(b, a)\n    return angle"}
{"task_id": 125, "completion": "def find_length(string, n):\n    max_diff = 0\n    curr_diff = 0\n\n    for i in range(0, n):\n        curr_diff = curr_diff + (1 if string[i] == '0' else -1)\n        \n        if curr_diff < 0:\n            curr_diff = 0\n        if curr_diff > max_diff:\n            max_diff = curr_diff\n\n    if max_diff == 0:\n        return -1\n\n    return max_diff"}
{"task_id": 126, "completion": "def sum_of_common_divisors(a, b):\n    def find_divisors(n):\n        divisors = [1]\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                if n / i == i:\n                    divisors.append(i)\n                else:\n                    divisors.extend([i, n // i])\n        return divisors\n\n    a_divisors = set(find_divisors(a))\n    b_divisors = set(find_divisors(b))\n    common_divisors = a_divisors.intersection(b_divisors)\n\n    return sum(common_divisors)\n"}
{"task_id": 127, "completion": "def multiply_int(x, y):\n    result = 0\n    for i in range(abs(y)): \n        result += abs(x)\n\n    if x > 0 and y < 0 or x < 0 and y > 0:\n        return -result\n    else:\n        return result"}
{"task_id": 128, "completion": "def long_words(n, lst):\n    return [word for word in lst if len(word) > n]"}
{"task_id": 129, "completion": "def magic_square_test(matrix):\n    # Get the size of matrix\n    N = len(matrix[0])\n    \n    # Calculate the sum of the first diagonal\n    diag_sum = sum([matrix[i][i] for i in range(N)])\n    \n    # Calculate the sum of the second diagonal\n    diag_sum2 = sum([matrix[i][N-i-1] for i in range(N)])\n    \n    # If sums of both diagonals are not equal, it's not a magic square\n    if(diag_sum != diag_sum2):\n        return False\n    \n    # Check rows and columns\n    for i in range(N):\n        row_sum = sum(matrix[i])\n        col_sum = sum([row[i] for row in matrix])\n        if(row_sum != diag_sum or col_sum != diag_sum):\n            return False\n    return True"}
{"task_id": 130, "completion": "def max_occurrences(nums):\n    from collections import Counter\n\n    # Find the frequency of each item\n    frequencies = Counter(nums)\n    \n    # Find the items with maximum frequency\n    max_freq_items = [k for k, v in frequencies.items() if v == max(frequencies.values())]\n\n    # If there's only one item with maximum frequency, return it\n    # Otherwise, return the list of items with maximum frequency\n    if len(max_freq_items) == 1:\n        return max_freq_items[0]\n    else:\n        return max_freq_items"}
{"task_id": 131, "completion": "def reverse_vowels(str1):\n    vowels = \"AEIOUaeiou\"\n    \n    # Filter out vowels from input string\n    vowels_in_str = [c for c in str1 if c in vowels]\n    \n    # Reverse the vowels\n    vowels_in_str.reverse()\n\n    # Replace the vowels in the original string with the reversed vowels\n    str_list = list(str1)\n    for i in range(len(str_list)):\n        if str_list[i] in vowels:\n            str_list[i] = vowels_in_str.pop(0)\n    \n    return \"\".join(str_list)"}
{"task_id": 132, "completion": "def tup_string(tup1):\n    str1 = ''.join(tup1)\n    return str1"}
{"task_id": 133, "completion": "def sum_negativenum(nums):\n    return sum(filter(lambda x: x < 0, nums))"}
{"task_id": 134, "completion": "def check_last(arr, n, p):\n    if len(arr) == 0:    # Check if the array is empty\n        return None\n    last_element = arr[-1]  # Get the last element\n    for _ in range(n):   # Perform the operation n times\n        last_element += p\n    if last_element % 2 == 0:  # Check if it's even\n        return \"Even\"\n    else:\n        return \"Odd\"    # Otherwise it's odd"}
{"task_id": 135, "completion": "def hexagonal_num(n):\n    return n * (2*n - 1)"}
{"task_id": 136, "completion": "def cal_electbill(units, cost_per_unit = 0.12):\n    return units * cost_per_unit"}
{"task_id": 137, "completion": "def zero_count(nums):\n    # The number of zeros in the list is determined using count function\n    zero_count = nums.count(0) \n    # The ratio of zeros to the overall array size is then computed\n    zero_ratio = zero_count / len(nums)\n    return zero_ratio"}
{"task_id": 138, "completion": "def is_Sum_Of_Powers_Of_Two(n):\n    # Binary representation of number should not have consecutive ones\n    binary = bin(n)[2:] # [2:] is used to remove the '0b' at the beginning of the binary representation\n    for i in range(len(binary) - 1):\n        if binary[i] == '1' and binary[i+1] == '1':\n            return False\n    return True"}
{"task_id": 139, "completion": "def circle_circumference(r):\n    if r >= 0:\n        circumference = 2 * math.pi * r\n        return circumference\n    else:\n        return \"The radius should be a non-negative number.\""}
{"task_id": 140, "completion": "def extract_singly(test_list):\n    # Initialize an empty dictionary to count occurrences of elements\n    occurrence_count = {}\n\n    # Loop through the list\n    for element in test_list:\n        # If element is in the dictionary, increment its count\n        if element in occurrence_count:\n            occurrence_count[element] += 1\n        # If element is not in the dictionary, add it with a count of 1\n        else:\n            occurrence_count[element] = 1\n\n    # Initialize an empty list to hold elements that occur singly\n    singly_elements = []\n\n    # Loop through the dictionary\n    for element, count in occurrence_count.items():\n        # If the count of an element is 1 (it occurs singly), add it to the list\n        if count == 1:\n            singly_elements.append(element)\n\n    return singly_elements"}
{"task_id": 141, "completion": "def pancake_sort(nums):\n    \n    def flip(sub_nums, k):\n        # Reverse the order of the first k elements of the sub_nums list\n        i = 0\n        while i < k / 2:\n            tmp = sub_nums[i]\n            sub_nums[i] = sub_nums[k - i - 1]\n            sub_nums[k - i - 1] = tmp\n            i += 1\n\n    n = len(nums)\n    while n > 1:\n        # Find the index of the largest element in the subarray nums[0...n-1]\n        mi = nums.index(max(nums[0:n]))\n        # Move the largest element to end of the sublist by\n        # Reversing the list upto the maximum element\n        flip(nums, mi + 1)\n        # Now move that maximum element to end of the array by reversing\n        # the entire list\n        flip(nums, n)\n        n -= 1\n    return nums"}
{"task_id": 142, "completion": "def count_samepair(list1, list2, list3):\n    # Create a set for each list\n    set1 = set(list1)\n    set2 = set(list2)\n    set3 = set(list3)\n\n    # Find the intersection of the three sets\n    common_elements = set1.intersection(set2, set3)\n\n    # Count the number of pairs\n    pairs_count = 0\n    for i in common_elements:\n        pairs_count += min(list1.count(i), list2.count(i), list3.count(i))\n\n    # Return the count of pairs\n    return pairs_count"}
{"task_id": 143, "completion": "def find_lists(Input):\n    count = 0\n    for item in Input:\n        if type(item) is list:\n            count += 1\n    return count"}
{"task_id": 144, "completion": "def sum_pairs(arr):\n    sum = 0\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(i+1,n):\n            sum += abs(arr[i]-arr[j])\n            \n    return sum"}
{"task_id": 145, "completion": "def max_Abs_Diff(arr, n):\n    max_val = max(arr)\n    min_val = min(arr)\n    return max_val - min_val"}
{"task_id": 146, "completion": "def ascii_value_string(str1):\n    total = 0\n    for i in str1:\n        total += ord(i)\n    return total"}
{"task_id": 147, "completion": "def max_path_sum(tri, m, n):\n    # Create a 2D list that is filled with 0's initially\n    dp = [[0 for i in range(m+1)] for i in range(2)]\n\n    # Process each row from bottom to top\n    for i in range(m-1, -1, -1):\n        # Process each column in the current row\n        for j in range(i+1):\n            # Update the maximum path sum at current position\n            dp[i%2][j] = max(dp[(i+1)%2][j], dp[(i+1)%2][j+1]) + tri[i][j]\n\n    # Return the maximum path sum at the top of the triangle\n    return dp[0][0]"}
{"task_id": 148, "completion": "def sum_digits_single(x):\n    # Convert the input number to a sorted list of digit characters in descending order\n    digits = sorted(str(x), reverse=True)\n\n    # Initialize empty strings for the two parts of the number\n    part1 = ''\n    part2 = ''\n\n    # Loop through the sorted list of digits, add half to part 1 and half to part 2\n    for i in range(len(digits)):\n        if i < len(digits) / 2:\n            part1 += digits[i]\n        else:\n            part2 += digits[i]\n    \n    # Convert strings back to integers and return tuple\n    return int(part1), int(part2)"}
{"task_id": 149, "completion": "def longest_subseq_with_diff_one(arr, n):\n    # Create a table to store results of subproblems\n    dp = [1 for _ in range(n)]\n \n    # Fill dp[] in a bottom up manner\n    for i in range(1, n):\n        for j in range(i):\n            # If arr[i] is greater than arr[j] and the difference between them is 1,\n            # update dp[i]\n            if (abs(arr[i] - arr[j]) == 1):\n                dp[i] = max(dp[i], dp[j] + 1)\n \n    # The final result will be maximum value in dp\n    return max(dp)\n`"}
{"task_id": 150, "completion": "def does_Contain_B(a, b, c):\n    if c < a:  # if the number is less than the start of the sequence\n        return False\n    return (c - a) % b == 0  # check if the number lies in the sequence"}
{"task_id": 151, "completion": "def are_coprime(a, b):\n    return gcd(a, b) == 1"}
{"task_id": 152, "completion": "def merge_sort(arr):\n    if len(arr) <= 1:  # base case\n        return arr  \n\n    mid = len(arr) // 2  # finding the mid of the array\n    left = arr[:mid]  # dividing the array elements  \n    right = arr[mid:]  # into 2 halves \n\n    left = merge_sort(left)  # sorting the left half\n    right = merge_sort(right)  # sorting the right half\n\n    return merge(left, right)\n\n\ndef merge(left, right):\n    result = []\n    left_pointer = right_pointer = 0\n\n    # until we have reached the end of either L or M:\n    while left_pointer < len(left) and right_pointer < len(right):\n        # if the current element of L is less than or equal to the current element of M\n        if left[left_pointer] <= right[right_pointer]:\n            result.append(left[left_pointer])\n            left_pointer += 1\n        else:\n            result.append(right[right_pointer])\n            right_pointer += 1\n\n    # add the remaining elements in L or M to the result\n    while left_pointer < len(left):\n        result.append(left[left_pointer])\n        left_pointer += 1\n\n    while right_pointer < len(right):\n        result.append(right[right_pointer])\n        right_pointer += 1\n\n    return result"}
{"task_id": 153, "completion": "def parabola_vertex(a, b, c):\n    # Vertex of a parabola, (h, k)\n    h = -b / (2 * a)\n    k = a * h**2 + b * h + c\n    return (h, k)"}
{"task_id": 154, "completion": "def specified_element(nums, N):\n    output = []\n    for i in nums:\n        try:\n            output.append(i[N])\n        except IndexError:\n            continue\n    return output"}
{"task_id": 155, "completion": "def even_bit_toggle_number(n):\n    # Using bitwise shift and bitwise OR to toggle even bits\n    # If n is 8-bit binary number abcdefgh, then n>>1 will be abcd.efgh\n    # And (n>>1) | 0xAAAAAAAA will toggle second, fourth, sixth and eighth bits\n    return (n >> 1) | 0xAAAAAAAA"}
{"task_id": 156, "completion": "def tuple_int_str(tuple_str):\n    return tuple(int(i) for i in tuple_str)"}
{"task_id": 157, "completion": "def encode_list(list1):\n    result = []\n    i = 0\n\n    while i < len(list1):\n        count = 1\n        while i + 1 < len(list1) and list1[i] == list1[i+1]:\n            i += 1\n            count += 1\n        result.append([count, list1[i]])\n        i += 1\n\n    return result"}
{"task_id": 158, "completion": "def min_Ops(arr, n, k):\n    # initialize a counter to count the operations\n    ops = 0\n\n    # loop through the list\n    for i in range(n):\n        # calculate the difference between the element and k\n        diff = abs(arr[i] - k)\n        # add the result to the counter\n        ops += diff \n\n    return ops"}
{"task_id": 159, "completion": "def month_season(month, days):\n    if month in ['March', 'April', 'May'] and days <= 31:\n        print('The season is Spring')\n    elif month in ['June', 'July', 'August'] and days <= 31:\n        print('The season is Summer')\n    elif month in ['September', 'October', 'November'] and days <= 30:\n        print('The season is Autumn')\n    elif month in ['December', 'January', 'February'] and days <= 28:\n        print('The season is Winter')\n    else:\n        print(\"Invalid month or day\")"}
{"task_id": 160, "completion": "def extended_gcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x, y = extended_gcd(b % a, a)\n        return gcd, y - (b // a) * x, x"}
{"task_id": 161, "completion": "def remove_elements(list1, list2):\n    return [elem for elem in list1 if elem not in list2]"}
{"task_id": 162, "completion": "def sum_series(n):\n    sum = 0\n    while n > 0:\n        sum += n\n        n -= 2\n    return sum"}
{"task_id": 163, "completion": "import math\n\ndef area_polygon(s, n):\n    \"\"\"Calculate the area of a regular polygon.\"\"\"\n    # Area formula for a regular polygon\n    area = (s**2 * n) / (4 * math.tan(math.pi / n))\n    return area\n`"}
{"task_id": 164, "completion": "def divSum(n):\n    sum_divisors = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum_divisors += i\n    return sum_divisors == n"}
{"task_id": 165, "completion": "def count_char_position(str1):\n    count = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('a')) or \n            (i == ord(str1[i]) - ord('A'))):\n            count += 1\n    return count"}
{"task_id": 166, "completion": "def find_even_Pair(A, N): \n    # Initialize count to 0\n    count = 0\n\n    # Iterate over all pairs\n    for i in range(N):\n        for j in range(i + 1, N):\n            # If the xor of the pair is even\n            if (A[i] ^ A[j]) % 2 == 0:\n                # Increment count\n                count += 1\n\n    return count"}
{"task_id": 167, "completion": "import math\n\ndef next_Power_Of_2(n):\n    # find the power of 2 just less than n\n    p = math.floor(math.log(n, 2))\n    # Next power of 2 can be found by adding 1 to it and taking 2 to that power\n    return math.pow(2, p + 1)"}
{"task_id": 168, "completion": "def frequency(arr, x):\n    return arr.count(x)"}
{"task_id": 169, "completion": "def get_pell(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return 2 * get_pell(n - 1) + get_pell(n - 2)"}
{"task_id": 170, "completion": "def sum_range_list(list1, m, n):\n    return sum(list1[m:n+1])"}
{"task_id": 171, "completion": "def perimeter_pentagon(a):\n    return 5 * a"}
{"task_id": 172, "completion": "def count_occurrence(s):\n    return s.count('std')"}
{"task_id": 173, "completion": "def remove_splchar(text):\n    # Using regex module (re), where \\w denotes alphanumeric characters.\n    import re \n    return re.sub(r'\\W+', '', text)"}
{"task_id": 174, "completion": "def group_keyvalue(pairs):\n    # Initialize an empty dictionary\n    result = {}\n    \n    # Loop over all pairs\n    for key, value in pairs:\n        # If the key is already in the dictionary, append the value to the list associated with the key\n        if key in result:\n            result[key].append(value)\n        # If the key is not in the dictionary, create a new list for that key and add the value\n        else:\n            result[key] = [value]\n    \n    return result"}
{"task_id": 175, "completion": "def is_valid_parentheses(str1):\n    stack = []\n    for paren in str1:\n        if paren == '(':\n            stack.append(paren)\n        elif paren == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n`"}
{"task_id": 176, "completion": "def perimeter_triangle(a, b, c):\n    perimeter = a + b + c\n    return perimeter"}
{"task_id": 177, "completion": "def find_numbers(L, R):\n    def gcd(a, b):\n        if b==0:\n            return a\n        else:\n            return gcd(b, a%b) \n\n    def lcm(a,b):\n        return a*b // gcd(a,b)\n\n    for i in range(L, R):\n        for j in range(i+1, R+1):\n            if lcm(i, j) >= L and lcm(i, j) <= R:\n                return i, j\n    return None, None"}
{"task_id": 178, "completion": "def string_literals(patterns, text):\n  for pattern in patterns:\n    if pattern in text:\n      return True\n  return False"}
{"task_id": 179, "completion": "def is_num_keith(x):\n    if x < 10:\n        return False\n    \n    # Create a list of digits\n    digits = [int(i) for i in str(x)]\n    sum_of_digits = sum(digits)\n    \n    while sum_of_digits < x:\n        # Remove first digit and add sum_of_digits at the end\n        digits.pop(0)\n        digits.append(sum_of_digits)\n        # Update sum_of_digits\n        sum_of_digits = sum(digits)\n        \n    return sum_of_digits == x\n"}
{"task_id": 180, "completion": "def distance_lat_long(slat, slon, elat, elon):\n    R = 6371  # radius of Earth in kilometers\n\n    # converting degrees to radians\n    slat, slon, elat, elon = map(math.radians, [slat, slon, elat, elon])\n\n    # difference between latitudes and longitudes \n    dlat = elat - slat\n    dlon = elon - slon \n\n    a = math.sin(dlat/2)**2 + math.cos(slat) * math.cos(elat) * math.sin(dlon/2)**2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))\n\n    distance = R * c\n\n    return distance\n`"}
{"task_id": 181, "completion": "def common_prefix_util(str1, str2):\n    n1 = len(str1)\n    n2 = len(str2)\n \n    j = 0\n     \n    while(j < n1 and j < n2):\n        if (str1[j] != str2[j]):\n            break\n             \n        j += 1\n \n    return (str1[0: j])\n\ndef common_prefix(arr, low, high):\n \n    if (low == high):\n        return (arr[low])\n \n    mid = low + (high - low) // 2\n \n    str1 = common_prefix(arr, low, mid)\n    str2 = common_prefix(arr, mid + 1, high)\n \n    return (common_prefix_util(str1, str2))"}
{"task_id": 182, "completion": "def find_character(string):\n    uppercase_char = re.findall(r'[A-Z]', string)\n    lowercase_char = re.findall(r'[a-z]', string)\n    special_char = re.findall(r'[^A-Za-z0-9]', string)\n    numeric_values = re.findall(r'[0-9]', string)\n\n    return {\n        \"uppercase\": uppercase_char,\n        \"lowercase\": lowercase_char,\n        \"special_characters\": special_char,\n        \"numeric_values\": numeric_values\n    }"}
{"task_id": 183, "completion": "def count_pairs(arr, n, k):\n    count = 0\n    arr_set = set(arr)\n\n    for num in arr_set:\n        if (num + k) in arr_set:\n            count += 1\n\n    return count"}
{"task_id": 184, "completion": "def greater_specificnum(lst, num):\n    # Empty list to hold values greater than specified number\n    greater_nums = []\n  \n    # Iterate through each number in the list\n    for i in lst:\n        # If current number is greater than the specified number, add it to our list\n        if i > num:\n            greater_nums.append(i)\n            \n    # Return the list of numbers greater than the specified number\n    return greater_nums"}
{"task_id": 185, "completion": "def parabola_focus(a, b, c):\n    h = -b/(2*a)\n    k = c - ((b**2 - 1) / (4*a))\n    return (h, k)"}
{"task_id": 186, "completion": "def check_literals(text, patterns):\n    found_patterns = {}\n    for pattern in patterns:\n        matches = re.findall(pattern, text)\n        if matches:\n            found_patterns[pattern] = matches\n    return found_patterns"}
{"task_id": 187, "completion": "def longest_common_subsequence(X, Y):\n    m = len(X)\n    n = len(Y)\n    # Create a table to store lengths of the longest common subsequence of two sequences. \n    # Note that LCSuff[i][j] contains length of LCS of X[0..i-1] and Y[0..j-1] \n    LCSuff = [[0 for x in range(n+1)] for x in range(m+1)]\n \n    # Fill table in bottom up manner\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0 or j == 0:\n                LCSuff[i][j] = 0\n            elif X[i-1] == Y[j-1]:\n                LCSuff[i][j] = LCSuff[i-1][j-1] + 1\n            else:\n                LCSuff[i][j] = max(LCSuff[i-1][j], LCSuff[i][j-1])\n \n    # LCSuff[m][n] contains the length of LCS of X[0..n-1] & Y[0..m-1]\n    return LCSuff[m][n]\n`"}
{"task_id": 188, "completion": "def prod_Square(n):\n    if n < 0:\n        return False\n        \n    for i in range (1, int(math.sqrt(n)) + 1):\n        if (n % i == 0):\n            j = n // i\n            if (math.sqrt(i) == int(math.sqrt(i)) and math.sqrt(j) == int(math.sqrt(j))):\n                return True\n                \n    return False"}
{"task_id": 189, "completion": "def first_Missing_Positive(arr,n):\n\n    # To mark the occurrence of elements\n    mark = [0] * (n+1)\n\n    # Traverse the array\n    for i in range(n):\n        if(arr[i] > 0 and arr[i] <= n):\n            mark[arr[i]] = 1\n\n    # Find the first unmarked number\n    for i in range(1, n+1):\n        if(mark[i] == 0):\n            return i\n\n    # If no unmarked number is found, return n+1\n    return n+1"}
{"task_id": 190, "completion": "def count_integral_points(x1, y1, x2, y2):\n    # The side of the square\n    side = abs(x2 - x1)\n    \n    # Number of integral points inside the square will be (side-1)^2 if side>1\n    # else if side is 1 which means point is the same or there is no square, return 0\n    return (side - 1) ** 2 if side > 1 else 0"}
{"task_id": 191, "completion": "def check_monthnumber(monthname):\n    if monthname == \"April\" or monthname == \"June\" or monthname == \"September\" or monthname == \"November\":\n        return True\n    else:\n        return False "}
{"task_id": 192, "completion": "def check_string(s):\n    has_digit = False\n    has_alpha = False\n    for char in s:\n        if char.isdigit():\n            has_digit = True\n        if char.isalpha():\n            has_alpha = True\n    return has_digit and has_alpha"}
{"task_id": 193, "completion": "def remove_tuple_duplicates(test_tup):\n    return tuple(set(test_tup))"}
{"task_id": 194, "completion": "def octal_to_decimal(n):\n    # Initialize variable to store the result\n    decimal_number = 0\n    # Initialize variable to store the current power of 8\n    current_power = 0\n\n    # Iterate over the string representation of the octal number from right to left\n    for i in reversed(str(n)):\n        # Add to the result the current digit times 8 raised to the power of the current digit's position\n        decimal_number += int(i) * (8 ** current_power)\n        # Increase the power for the next iteration\n        current_power += 1\n\n    return decimal_number\n`"}
{"task_id": 195, "completion": "def first(arr, x, n):\n    low = 0\n    high = n - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n\n        if (mid == 0 or x > arr[mid - 1]) and arr[mid] == x:\n            return mid\n        elif x > arr[mid]:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1"}
{"task_id": 196, "completion": "def remove_tuples(test_list, K):\n    # Using list comprehension\n    res = [tup for tup in test_list if len(tup) != K]\n    return res"}
{"task_id": 197, "completion": "def find_exponentio(test_tup1, test_tup2):\n    # It converts the tuples into lists for easier manipulation\n    res1 = list(test_tup1) \n    res2 = list(test_tup2)\n  \n    # It uses list comprehension to implement the exponent operation\n    res = [res1[i] ** res2[i] for i in range(len(res1))]\n    \n    return tuple(res)\n`"}
{"task_id": 198, "completion": "def largest_triangle(a, b):\n    # Given parameters a & b represent the semi-major and semi-minor axes of the ellipse\n    # The maximum area of an inscribed triangle is defined as sqrt(3)*(a*b) \n    max_area = math.sqrt(3) * a * b\n    return max_area"}
{"task_id": 199, "completion": "import math\n\ndef highest_Power_of_2(n):\n    # The function log2(n) returns the base-2 logarithm of n.\n    # We then apply floor() to round down to the nearest integer.\n    power = math.floor(math.log(n, 2))\n\n    # Return 2 to the power of the calculated value.\n    return math.pow(2, power)"}
{"task_id": 200, "completion": "def position_max(input_list):\n    if not input_list: # check if list is empty\n        return []\n\n    # Initial maximum is first element and its index is 0\n    max_value = input_list[0]\n    max_indexes = [0]\n\n    # Iterate from the second element\n    for i in range(1, len(input_list)):\n        if input_list[i] > max_value:\n            max_value = input_list[i]\n            max_indexes = [i]  # If a new maximum is found, refresh the indexes list \n        elif input_list[i] == max_value:\n            max_indexes.append(i)  # If equals to the maximum, add its index\n\n    return max_indexes"}
{"task_id": 201, "completion": "def chkList(lst):\n    return len(set(lst)) <= 1\n`"}
{"task_id": 202, "completion": "def remove_even(str1):\n    return str1[1::2]"}
{"task_id": 203, "completion": "# Function that calculates the hamming distance\ndef hamming_Distance(n1, n2) :\n\n    # XOR of two numbers\n    x = n1 ^ n2 \n\n    # Initialize set bit count\n    setBits = 0\n\n    while (x > 0) :\n        \n        # Increment set bit count\n        setBits += x & 1\n        \n        # Right shift to next bit  \n        x >>= 1\n     \n    # Return count of set bits\n    return setBits\n`"}
{"task_id": 204, "completion": "def count(s, c):\n\n    #Initial count is 0\n    count = 0\n\n    #process each character in the string\n    for i in range(len(s)):\n\n        #when character matches, increment count\n        if s[i] == c:\n            count += 1\n\n    #Return the count\n    return count"}
{"task_id": 205, "completion": "def inversion_elements(tuple_list):\n    inverted_tuples = []\n    \n    for tup in tuple_list:\n        invert_tup = tup[::-1]\n        inverted_tuples.append(invert_tup)\n\n    return inverted_tuples"}
{"task_id": 206, "completion": "def concatenate_elements(test_tup):\n    # Initializing an empty string to store the concatenated elements\n    res_str = \"\"\n\n    # Iterating through the tuple\n    for elem in test_tup:\n        res_str += str(elem)  # Converting the elements to string before concatenating\n\n    # Splitting the string into chunks of 2 (adjacent elements)\n    res_tuple = tuple(res_str[i:i+2] for i in range(0, len(res_str), 2))\n\n    return res_tuple"}
{"task_id": 207, "completion": "def find_longest_repeating_subseq(string):\n    n = len(string)\n\n    # Create and initialize with zeros a table to store solutions of subproblems\n    dp = [[0 for _ in range(n+1)] for __ in range(n+1)]\n\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            # When characters match and indices are not same\n            if string[i-1] == string[j-1] and i != j:\n                dp[i][j] = 1 + dp[i-1][j-1]           \n            # If characters do not match  \n            else:\n                dp[i][j] = max(dp[i][j-1], dp[i-1][j])\n\n    # the maximum length of repeated subsequence\n    return dp[n][n]"}
{"task_id": 208, "completion": "def is_decimal(num):\n    if re.match(\"^\\d+\\.\\d{2}$\", num):\n        return True\n    else:\n        return False"}
{"task_id": 209, "completion": "def heap_replace(heap, item):\n    heapq.heappop(heap)  # remove the smallest element from the heap\n    heapq.heappush(heap, item)  # insert the new item into the heap"}
{"task_id": 210, "completion": "def is_allowed_specific_char(string):\n    match = re.match(\"^[a-zA-Z0-9]*$\", string)\n    if match:\n        return True\n    else:\n        return False"}
{"task_id": 211, "completion": "def count_num(n):\n    count = 0\n    for i in range(1 << (n+1)):\n        if (i & 1) and (i & (1 << n)):\n            count += 1\n    return count"}
{"task_id": 212, "completion": "def fourth_power_sum(n):\n    sum = 0\n    for i in range(1, n + 1):\n        sum += i ** 4\n    return sum"}
{"task_id": 213, "completion": "def concatenate_strings(test_tup1, test_tup2):\n    # Convert the tuples to strings\n    str_tup1 = \"\".join(test_tup1)\n    str_tup2 = \"\".join(test_tup2)\n    \n    # Concatenate the two strings\n    result = str_tup1 + str_tup2\n    \n    # Return the result\n    return result"}
{"task_id": 214, "completion": "def radian_to_degree(radian):\n    degree = radian * (180/math.pi)\n    return degree"}
{"task_id": 215, "completion": "def decode_list(alist):\n    result_list = []\n    for index in range(0, len(alist), 2):  # Stepping by 2 to get the pairs\n        count = alist[index]\n        element = alist[index + 1]\n        \n        # repeat the element by the count and add to the result_list\n        result_list += [element] * count\n    return result_list"}
{"task_id": 216, "completion": "def check_subset_list(list1, list2):\n    for sublist1 in list1:\n        if not any(set(sublist1).issubset(set(sublist2)) for sublist2 in list2):\n            return False\n    return True"}
{"task_id": 217, "completion": "def first_Repeated_Char(str):\n    char_count = {}\n    for char in str:\n        if char in char_count:\n            return char\n        else:\n            char_count[char] = 1\n    return \"No repeating characters\""}
{"task_id": 218, "completion": "def min_Operations(A,B):\n    #Write a python function to find the minimum operations required to make two numbers equal.\n    min_operations = 0\n    \n    while(A!=B):\n        if A>B:\n            if A%2==0:\n                A//=2\n            else:\n                A+=1\n        else:\n            if B%2==0:\n                B//=2\n            else:\n                B+=1\n        min_operations += 1\n    return min_operations"}
{"task_id": 219, "completion": "def extract_min_max(test_tup, k):\n    # Checking if K is greater than the length of the tuple\n    if len(test_tup) < k:\n        return None\n    else:\n        # Preparing sorted list from tuple\n        test_tup_sorted = sorted(test_tup)\n\n        # Extracting the minimum K elements\n        min_k_elems = test_tup_sorted[:k]\n\n        # Extracting the maximum K elements\n        max_k_elems = test_tup_sorted[-k:]\n\n        return min_k_elems, max_k_elems"}
{"task_id": 220, "completion": "def replace_max_specialchar(text, n):\n    # special characters to replace are space, comma, and dot\n    special_chars = [' ', ',', '.']\n    \n    count = 0\n    new_text = ''\n    for char in text:\n        if char in special_chars and count < n:\n            new_text += ':'\n            count += 1\n        else:\n            new_text += char\n    \n    return new_text"}
{"task_id": 221, "completion": "def first_even(nums):\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return None"}
{"task_id": 222, "completion": "def check_type(test_tuple):\n    return len(set(map(type, test_tuple))) == 1"}
{"task_id": 223, "completion": "def is_majority(your_array, array_size, element):\n    first_occurrence = binary_search(your_array, 0, array_size - 1, element)\n    \n    if first_occurrence == -1:\n        return False\n     \n    if ((first_occurrence + array_size // 2) < array_size and your_array[first_occurrence + array_size // 2] == element):\n        return True\n    else:\n        return False"}
{"task_id": 224, "completion": "def count_Set_Bits(n):\n    return bin(n).count('1')"}
{"task_id": 225, "completion": "def find_Min(arr, low, high):\n    # when array is not rotated at all\n    if high < low:\n        return arr[0]\n \n    # when only one element is left\n    if high == low:\n        return arr[low]\n \n    # find mid\n    mid = low + (high - low) // 2      \n \n    # check if mid+1 is minimum element\n    if mid < high and arr[mid+1] < arr[mid]:\n        return arr[mid+1]\n \n    # check if mid is minimum element\n    elif mid > low and arr[mid] < arr[mid - 1]:\n        return arr[mid]\n \n    # decide whether to go to the right half or the left half\n    if arr[high] > arr[mid]:\n        return find_Min(arr, low, mid - 1)\n    return find_Min(arr, mid + 1, high)\n`"}
{"task_id": 226, "completion": "def odd_values_string(str):\n    result = \"\" \n    for i in range(len(str)):\n        if i % 2 == 0:\n            result += str[i]\n    return result"}
{"task_id": 227, "completion": "def min_of_three(a, b, c):\n    return min(a, b, c)"}
{"task_id": 228, "completion": "def all_Bits_Set_In_The_Given_Range(n, l, r):\n\n    # create a number with all bits set in the range [l, r]\n    num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1)\n\n    # if all bits are set in the range [l, r], then \n    # bitwise AND of n and num will be equal to num\n    if (n & num) == num:\n        return True\n    \n    return False"}
{"task_id": 229, "completion": "def re_arrange_array(arr):\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        \n        if arr[left] < 0 and arr[right] > 0:\n            left += 1\n            right -= 1\n            \n        elif arr[left] > 0 and arr[right] < 0:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n            \n        elif arr[left] > 0 and arr[right] > 0:\n            right -= 1\n            \n        else:\n            left += 1 \n\n    return arr"}
{"task_id": 230, "completion": "def replace_blank(str1, char):\n    return str1.replace(' ', char)"}
{"task_id": 231, "completion": "def max_sum(tri, n):\n    for i in range(n - 2, -1, -1):\n        for j in range(i + 1):\n            if tri[i + 1][j] > tri[i + 1][j + 1]:\n                tri[i][j] += tri[i + 1][j]\n            else:\n                tri[i][j] += tri[i + 1][j + 1]\n\n    return tri[0][0]"}
{"task_id": 232, "completion": "def larg_nnum(list1, n):\n    list1.sort()\n    return list1[-n:]"}
{"task_id": 233, "completion": "def lateral_surface_area_cylinder(r, h):\n    import math\n    return 2 * math.pi * r * h"}
{"task_id": 234, "completion": "def volume_cube(l):\n    # calculate and return the volume of the cube\n    return l**3"}
{"task_id": 235, "completion": "def even_bit_set_number(n):\n    # Binary representation is from right to left hence \n    # even position bit in binary will be at odd position in 1-indexed array representation \n    # so create a mask for numbers at odd positions\n    mask = 0xAAAAAAAA\n  \n    # Set bits of 'n' and numbers with all\n    # bits set at odd positions\n    return  (n | mask)"}
{"task_id": 236, "completion": "def No_of_Triangle(N, K):\n    # each triangle is divided into K smaller triangles\n    # each new smaller triangle can further be divided into K smaller triangles\n    # each division operation decreases the triangle side length by 1\n    # we continue until the triangle side length reaches 1 (as it cannot be divided anymore)\n    \n    count = 0\n    while N > 0:\n        count += (N ** 2) # add the number of triangles for the current size \n        N -= 1 # decrease size by 1 (as the triangle has now been divided)\n    \n    return count * K # multiply with K as each triangle can be divided into K smaller triangles"}
{"task_id": 237, "completion": "def check_occurrences(test_list):\n    # Creating an empty dictionary\n    freq = {}\n    \n    # Counting frequency\n    for i in test_list:\n        # If tuple exists in dict then increment its value else add it in dict\n        if i in freq:\n            freq[i] += 1\n        else:\n            freq[i] = 1\n            \n    # Extracting tuples with same frequency and returning\n    result = {key: value for key, value in freq.items() if list(freq.values()).count(value) > 1}\n\n    return result"}
{"task_id": 238, "completion": "def number_of_substrings(str):\n    n = len(str)\n    return int(n * (n + 1) / 2)"}
{"task_id": 239, "completion": "def get_number_of_sequences(m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    # Initializing with base cases.\n    for i in range(1, m + 1):\n        dp[i][1] = i\n    \n    for i in range(1, m + 1):\n        for j in range(2, n + 1):\n            dp[i][j] = dp[i][j-1]\n            if i // 2 >= j - 1: \n                dp[i][j] += dp[i//2][j-1]\n    \n    return dp[m][n]\n`"}
{"task_id": 240, "completion": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1"}
{"task_id": 241, "completion": "def array_3d(m, n, o):\n    return [[['*' for _ in range(o)] for _ in range(n)] for _ in range(m)]"}
{"task_id": 242, "completion": "def count_charac(str1):\n    return len(str1)"}
{"task_id": 243, "completion": "def sort_on_occurrence(tupList):\n    return sorted(tupList, key = lambda x: x[0])"}
{"task_id": 244, "completion": "import math\n\ndef next_Perfect_Square(N):\n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN"}
{"task_id": 245, "completion": "def max_sum(arr, n):\n    inc = [0 for i in range(n)]\n    dec = [0 for i in range(n)]\n    maximum = -1\n    inc[0] = arr[0]\n    dec[n-1] = arr[n-1]\n\n    # Construct increasing array\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n \n    # Construct decreasing array\n    for i in range(n-2, -1, -1):\n        for j in range(n-1, i, -1):\n            if arr[i] > arr[j] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n                \n    # Calculate max sum\n    for i in range(n):\n        maximum = max(maximum, inc[i] + dec[i] - arr[i])\n\n    # return maximum\n    return maximum"}
{"task_id": 246, "completion": "def babylonian_squareroot(number):\n    if number < 0:\n        return None  # square roots of negative numbers are complex\n    if number == 0 or number == 1:\n        return number  # quick return for 0 and 1\n    guess = number/2 # initial guess for square root\n    while True:\n        better_guess = (guess + number / guess) / 2\n        if abs(guess - better_guess) < 0.000001: # end if we're close enough\n            return better_guess\n        guess = better_guess"}
{"task_id": 247, "completion": "def lps(str):\n    n = len(str)\n \n    # Create a table to store results of subproblems\n    L = [[0 for x in range(n)]for y in range(n)]\n \n    # Strings of length 1 are palindrome of length 1\n    for i in range(n):\n        L[i][i] = 1\n \n    # Build the table.\n    # Note that the lower diagonal values of table are\n    # useless and not filled in the process.\n    for cl in range(2, n+1):\n        for i in range(n-cl+1):\n            j = i+cl-1\n            if (str[i] == str[j] and cl == 2):\n                L[i][j] = 2\n            elif (str[i] == str[j]):\n                L[i][j] = L[i+1][j-1] + 2\n            else:\n                L[i][j] = max(L[i][j-1], L[i+1][j])\n \n    # length of longest palindromic subsequence\n    return L[0][n-1]"}
{"task_id": 248, "completion": "def harmonic_sum(n):\n  if n < 2:\n    return 1\n  else:\n    return 1/n + (harmonic_sum(n-1))"}
{"task_id": 249, "completion": "def intersection_array(array_nums1, array_nums2):\n    # Use the Python built-in function filter() to filter the elements in the\n    # first array that also exist in the second array. The lambda function\n    # is used to describe the filtering rule.\n    result = filter(lambda x: x in array_nums2, array_nums1)\n \n    # Convert the filtered elements to a list and return it.\n    return list(result)"}
{"task_id": 250, "completion": "def count_X(tup, x):\n    return tup.count(x)"}
{"task_id": 251, "completion": "def insert_element(lst, element):\n    for i in range(len(lst)*2, 0, -2):\n        lst.insert(i, element)\n    return lst"}
{"task_id": 252, "completion": "def convert_complex_to_polar(complex_num):\n    magnitude = abs(complex_num)\n    phase = cmath.phase(complex_num)\n    return magnitude, phase"}
{"task_id": 253, "completion": "def count_integer(list1):\n    int_count = sum(isinstance(i, int) for i in list1)\n    return int_count"}
{"task_id": 254, "completion": "def words_ae(text):\n    # Splitting text into words\n    words = re.findall(r'\\b\\w+\\b', text)\n\n    # Words starting with 'a' or 'e'\n    ae_words = [word for word in words if word.startswith(('a', 'e', 'A', 'E'))]\n\n    return ae_words"}
{"task_id": 255, "completion": "def combinations_colors(l, n):\n    \"\"\"\n    Given a list of colours and a number, generates all combinations of the colours\n    with specified n repetitions.\n    \"\"\"\n    return list(itertools.combinations_with_replacement(l, n))"}
{"task_id": 256, "completion": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count"}
{"task_id": 257, "completion": "def swap_numbers(a, b):\n    a, b = b, a\n    return a, b"}
{"task_id": 258, "completion": "def count_odd(array_nums):\n    return len(list(filter(lambda x: x % 2 != 0, array_nums)))"}
{"task_id": 259, "completion": "def maximize_elements(test_tup1, test_tup2):\n    # Getting the length of the shorter tuple\n    length = min(len(test_tup1), len(test_tup2))\n    # Create a new tuple with the maximum elements\n    result = tuple(max(test_tup1[i], test_tup2[i]) for i in range(length))\n    return result"}
{"task_id": 260, "completion": "def newman_shanks_williams(n):\n    if n == 0 or n == 1:\n        return 1\n\n    S = [1,1]\n    \n    for i in range(2, n+1):\n        S.append(2*S[i-1] + S[i-2])\n    \n    return S[-1]"}
{"task_id": 261, "completion": "def division_elements(test_tup1, test_tup2):\n    # Given tuples are not of same length, return an error message\n    if len(test_tup1) != len(test_tup2):\n      return \"Tuples are not the same length.\"\n    \n    # Initialize an empty result list\n    result = []\n    # Use zip to traverse both tuples together\n    for elem1, elem2 in zip(test_tup1, test_tup2):\n        # Perform division and append to result list\n        # Ensure the second element is not zero to avoid ZeroDivisionError\n        if elem2 != 0:\n            result.append(elem1 / elem2)\n        else:\n            result.append('undefined') # or however you want to handle division by zero\n    # Convert result list to tuple and return\n    return tuple(result)\n"}
{"task_id": 262, "completion": "def split_two_parts(list1, L):\n    # Check if L is not exceeding the list's length\n    if L > len(list1):\n        return \"Length provided exceeds list length\"\n\n    # Create two lists: first one from index 0 to L and second from L to end\n    first_part = list1[:L]\n    second_part = list1[L:]\n  \n    return first_part, second_part"}
{"task_id": 263, "completion": "def merge_dict(dict1, dict2):\n    result = dict1.copy()   # start with dict1's keys and values\n    result.update(dict2)    # modifies result with dict2's keys and values & returns None\n    return result"}
{"task_id": 264, "completion": "def dog_age(h_age):\n    return h_age * 7"}
{"task_id": 265, "completion": "def list_split(S, step):\n    return [S[i:i+step] for i in range(0, len(S), step)]"}
{"task_id": 266, "completion": "def lateral_surface_area_cube(l):\n    # The lateral surface area of a cube = 4 * side\u00b2\n    return 4 * (l ** 2)"}
{"task_id": 267, "completion": "def square_Sum(n):\n    sum = 0\n    odd = 1\n\n    for i in range(n):\n        sum += odd ** 2\n        odd += 2\n\n    return sum"}
{"task_id": 268, "completion": "def find_star_num(n):\n    return 6 * n * (n - 1) + 1"}
{"task_id": 269, "completion": "def ascii_value(character):\n    return ord(character)"}
{"task_id": 270, "completion": "def sum_even_and_even_index(arr, n):\n    # Intializing sum to 0\n    sum = 0\n    # iterating through each element in the list\n    for i in range(n):\n        # if the index and the value at that index are both even\n        if i % 2 == 0 and arr[i] % 2 == 0:\n            # add it to the sum\n            sum += arr[i]\n    return sum"}
{"task_id": 271, "completion": "def even_Power_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2*i)**5\n    return sum"}
{"task_id": 272, "completion": "def rear_extract(test_list):\n  \n    # Using list comprehension to extract last element from each tuple\n    res = [sub[-1] for sub in test_list]\n\n    return res"}
{"task_id": 273, "completion": "def substract_elements(tup1, tup2):\n    return tuple(x1-x2 for x1, x2 in zip(tup1, tup2))"}
{"task_id": 274, "completion": "def even_binomial_Coeff_Sum(n): \n    sum = 0\n    for i in range(0, n+1, 2): \n        sum += comb(n, i)\n        \n    return sum"}
{"task_id": 275, "completion": "def get_Position(a, n, m):\n    a = a[:n] # get the array upto nth elements only\n    for i in range(n-1, -1, -1): # traverse from end to start\n        if a[i] == m: # if element is found return its position\n            return i + 1 # array index starts from 0, adding 1 to match it with position\n    return -1 # if not found return -1"}
{"task_id": 276, "completion": "def volume_cylinder(r, h):\n    # The formula for volume of a cylinder is:\n    # V = \u03c0 r^2 h (where r is the radius of the base and h is the height)\n    return math.pi * r**2 * h"}
{"task_id": 277, "completion": "def dict_filter(dictionary, n):\n    filtered_dict = {}\n    for key, value in dictionary.items():\n        if value >= n:\n            filtered_dict[key] = value\n    return filtered_dict"}
{"task_id": 278, "completion": "def count_first_elements(test_tup):\n    res = {}\n    for idx, ele in enumerate(test_tup):\n        if ele not in res:\n            res[ele] = idx\n    return res"}
{"task_id": 279, "completion": "def is_num_decagonal(n):\n    return 4*n**2 - 3*n"}
{"task_id": 280, "completion": "def sequential_search(dlist, item):\n    for i in range(len(dlist)):\n        if dlist[i] == item:\n            return True\n    return False"}
{"task_id": 281, "completion": "def all_unique(lst):\n    return len(lst) == len(set(lst))"}
{"task_id": 282, "completion": "def sub_list(nums1, nums2):\n    return list(map(lambda x, y: x - y, nums1, nums2))"}
{"task_id": 283, "completion": "def validate(n):\n    n_str = str(n)\n    for i in range(10):  # digits from 0 to 9\n        i_str = str(i)\n        frequency = n_str.count(i_str)\n        if frequency > i:\n            return False\n    return True"}
{"task_id": 284, "completion": "def check_element(lst, element):\n    \"\"\" check whether all items of a list are equal to a given string\"\"\"\n    return all(x == element for x in lst)"}
{"task_id": 285, "completion": "def text_match_two_three(text):\n    patterns = 'ab{2,3}?'\n    if re.search(patterns, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'"}
{"task_id": 286, "completion": "def max_sub_array_sum_repeated(a, n, k):\n\n    # Function to calculate maximum subarray sum\n    def max_sub_array_sum(a):\n\n        max_so_far = a[0]\n\n        max_ending_here = a[0]\n\n        for i in range(1, len(a)):\n\n            max_ending_here = max(max_ending_here + a[i], a[i])\n\n            max_so_far = max(max_so_far, max_ending_here)\n\n        return max_so_far"}
{"task_id": 287, "completion": "def square_sum(n):\n    # Initialize sum as 0\n    sum = 0\n    for i in range(2, 2*n+1, 2):  # Steps of 2 to get even numbers\n        sum += (i**2)  # Add the square of every i-th number to the sum\n    return sum"}
{"task_id": 288, "completion": "def modular_inverse(arr, P):\n    count = 0\n    for num in arr:\n        # A number is its own modular inverse if and only if it squared is 1 mod P\n        if (num * num) % P == 1:\n            count += 1\n    return count"}
{"task_id": 289, "completion": "def odd_days(N):\n    odds = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    odd_days = 0\n\n    # Check if year is a leap year\n    if N % 4 == 0:\n        if N % 100 != 0 or N % 400 == 0:\n            odds[1] = 29\n\n    for month in odds:\n        odd_days += month // 2 + month % 2\n\n    return odd_days"}
{"task_id": 290, "completion": "def max_length(list1):\n    max_len = max(len(lst) for lst in list1)\n    return [lst for lst in list1 if len(lst) == max_len]"}
{"task_id": 291, "completion": "def count_no_of_ways(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    # ways for single and two posts\n    same, diff = k, k * (k - 1) \n    for _ in range(3, n + 1):\n        # new same will be previous diff\n        same, diff = diff, (same + diff) * (k - 1)\n    # total ways will be same + diff\n    return same + diff"}
{"task_id": 292, "completion": "def find_quotient(n, m):\n    try:\n        quotient = n / m\n        return quotient\n    except ZeroDivisionError:\n        return \"Error: Division by zero is not allowed.\""}
{"task_id": 293, "completion": "import math\n\ndef otherside_rightangle(w, h):\n  # Use the Pythagorean theorem to calculate the length of the hypotenuse\n  hypotenuse = math.sqrt(w**2 + h**2)\n  return hypotenuse"}
{"task_id": 294, "completion": "def max_val(listval):\n    max_value = None\n    for val in listval:\n        if isinstance(val, (int, float)):\n            if max_value is None or val > max_value:\n                max_value = val\n    return max_value\n"}
{"task_id": 295, "completion": "def sum_div(number):\n    if number == 0:\n        return 0\n    sum = 0\n    for i in range(1, number + 1):\n        if number % i == 0:\n            sum += i\n    return sum"}
{"task_id": 296, "completion": "def get_Inv_Count(arr, n):\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n \n    return inv_count"}
{"task_id": 297, "completion": "def flatten_list(nested_list):\n    result = []\n    for i in nested_list:\n        if type(i) == list:\n            result += flatten_list(i)\n        else:\n            result.append(i)\n    return result"}
{"task_id": 298, "completion": "def intersection_nested_lists(l1, l2):\n    return [[i for i in sublist1 if any(i in sublist2 for sublist2 in l2)] for sublist1 in l1]"}
{"task_id": 299, "completion": "def max_aggregate(stdata): \n    '''Takes a list of tuples as input where each tuple contains two numbers and returns the maximum aggregate.''' \n    if stdata: \n        max_sum = sum(stdata[0]) # initial sum of the first tuple \n        for i in range(1, len(stdata)):\n            max_sum = max(max_sum, sum(stdata[i])) \n        return max_sum\n    else:\n        return None # if the list is empty\n`"}
{"task_id": 300, "completion": "def count_binary_seq(n):\n    # using dynamic programming\n    dp = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    dp[0][0] = 1\n  \n    for i in range(1, 2*n + 1):\n        # i is for prefix length\n        # j is for balance between counts of zeroes and ones\n        for j in range(min(i, n)+1):\n            dp[i%2][j] = dp[(i-1)%2][j]\n            if j > 0:\n                dp[i%2][j] += dp[(i-1)%2][j-1] \n            if j < i:\n                dp[i%2][j] -= dp[(i-1)%2][j]\n            \n    return dp[(2*n)%2][n] ** 2\n`"}
{"task_id": 301, "completion": "def dict_depth(d):\n    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0"}
{"task_id": 302, "completion": "def set_Bit_Number(n): \n  \n    # Below line will find the number \n    # of bits in the number. \n    k = int(log2(n)) \n  \n    # To return the bit number we \n    # add 1 to the 'k' obtained \n    # from log function because \n    # in programming counting \n    # starts from 0. \n    return k + 1"}
{"task_id": 303, "completion": "def solve(a, n):\n    # Define counters for inversions of type 1 and type 2\n    inv_count_1 = 0\n    inv_count_2 = 0\n\n    # Check for inversions\n    for i in range(n):\n        for j in range(i+1, n): \n            # For type 1\n            if a[i] == 1 and a[j] == 2 and i<j:\n                inv_count_1 += 1\n            # For type 2\n            if a[i] == 2 and a[j] == 1 and i<j:\n                inv_count_2 += 1\n\n    # Check if inversion counts are equal\n    if inv_count_1 == inv_count_2:\n        return True\n    else:\n        return False\n`"}
{"task_id": 304, "completion": "def find_element(arr, ranges, rotations, index):\n    while rotations > 0:\n        start, end = ranges[0], ranges[1]\n        temp = arr[start]\n        for i in range(start, end):\n            arr[i] = arr[i + 1]\n        arr[end] = temp\n        rotations -= 1\n    return arr[index]"}
{"task_id": 305, "completion": "def start_withp(words):\n    p_words = [word for word in words if word.lower().startswith('p')]\n    return p_words"}
{"task_id": 306, "completion": "def max_sum_increasing_subseq(a, n, index, k):\n    # Initialize the maximum sum increasing subsequence array\n    dp = [0]*n\n\n    # The max sum up to index 0 is the element at index 0\n    dp[0] = a[0]\n\n    # Calculate maximum sum sub sequences ending at all indexes upto and including index\n    for i in range(1, index+1):\n        for j in range(i):\n            if a[i] > a[j]:\n                dp[i] = max(dp[i], dp[j] + a[i])\n\n    # Include kth element \n    for j in range(index, k):\n        if a[k] > a[j]:\n            dp[k] = max(dp[k], dp[j] + a[k])\n\n    # Return maximum value in dp[] and dp[k]\n    return max(max(dp), dp[k])"}
{"task_id": 307, "completion": "def colon_tuplex(tuplex, m, n):\n    return tuplex[m:n]"}
{"task_id": 308, "completion": "import heapq \n\ndef large_product(nums1, nums2, N):       \n    # Initialize a min heap\n    min_heap = []\n  \n    # We work with negative numbers to use the 'heapq' library's heap functionality\n    for num1 in nums1:\n        for num2 in nums2:\n            product = -(num1 * num2)\n  \n            if len(min_heap) < N: \n                heapq.heappush(min_heap, product)\n            elif product > min_heap[0]:\n                heapq.heappop(min_heap)\n                heapq.heappush(min_heap, product)\n    \n    # Since we were working with negative numbers, we change the sign again and return the results\n    return [-num for num in min_heap]"}
{"task_id": 309, "completion": "def maximum(a, b):\n    if a >= b:\n        return a\n    else:\n        return b"}
{"task_id": 310, "completion": "def string_to_tuple(str1):\n    # Convert the string to a tuple\n    return tuple(str1)"}
{"task_id": 311, "completion": "def set_left_most_unset_bit(n):\n    # Convert the number to binary and reverse it, then convert it to a string\n    bin_n = str(bin(n))[2:][::-1]\n  \n    # Find the position of the first '0' bit. If there isn't one, we add a '1' to the end\n    pos = bin_n.find('0')\n    if pos != -1:\n        # We switch the '0' bit to a '1' bit\n        result = bin_n[:pos] + '1' + bin_n[pos+1:]\n    else:\n        # If all bits are set to 1 we add a '1' at the end\n        result = bin_n + '1'\n\n    # Convert the binary number (reversed) back to an integer and return\n    return int(result[::-1], 2)"}
{"task_id": 312, "completion": "import math\n\ndef volume_cone(radius, height):\n    # Formula: V = 1/3 * \u03c0 * r^2 * h\n    volume = (1/3) * math.pi * (radius ** 2) * height\n    return volume"}
{"task_id": 313, "completion": "def pos_nos(list1):\n    for num in list1:\n        if num > 0:\n            print(num)"}
{"task_id": 314, "completion": "def max_sum_rectangular_grid(grid):\n    n = len(grid[0])\n    \n    # Early return if the grid is empty\n    if n == 0:\n        return 0\n\n    incl = max(grid[0][0], grid[1][0]) # Include the current element\n    excl = 0 # Exclude the current element\n    \n    for i in range(1, n):\n        # Maximum sum excluding the current element\n        new_excl = max(incl, excl)\n        \n        # Maximum sum including the current element will be \n        # previous maximum sum excluding the last element and current element\n        incl = excl + max(grid[0][i], grid[1][i])\n        excl = new_excl   # Update excl to new_excl for next iteration.\n        \n    # The maximum excluding the last element will always be the answer\n    return max(incl, excl)"}
{"task_id": 315, "completion": "def find_Max_Len_Even(str):\n    words = str.split(\" \") # split the string into list of words\n    max_length = 0\n    max_word = ''\n\n    for word in words:\n        if len(word) % 2 == 0: # check if the length of the word is even\n            if len(word) > max_length: # check if the length of the word is greater than max_length\n                max_length = len(word) # if so, update max_length\n                max_word = word\n\n    return max_word"}
{"task_id": 316, "completion": "def find_last_occurrence(A, x):\n    \"\"\"Finds the last occurrence of x in sorted list A\"\"\"\n    first = 0\n    last = len(A) - 1\n    result = -1\n    while first <= last:\n        mid = (first + last) // 2\n        if A[mid] == x:\n            result = mid\n            first = mid + 1\n        elif A[mid] < x:\n            first = mid + 1\n        else:\n            last = mid - 1\n    return result"}
{"task_id": 317, "completion": "def modified_encode(lst):\n    encoded = []\n    i = 0\n\n    while i < len(lst):\n        count = lst.count(lst[i])\n        if count == 1:\n            encoded.append(lst[i])\n        else:\n            encoded.append([count, lst[i]])\n        i += count\n\n    return encoded"}
{"task_id": 318, "completion": "def max_volume(s):\n    # We need to divide the total sum by 3 to get the length of each side.\n    side_length = s / 3.0\n    # As the volume is the multiplication of the sides, we simply cube the side length.\n    max_vol = side_length ** 3\n    return max_vol"}
{"task_id": 319, "completion": "import re\n\ndef find_long_word(text):\n    five_char_words = re.findall(r'\\b\\w{5}\\b', text)\n    return five_char_words\n`"}
{"task_id": 320, "completion": "def sum_difference(n):\n    sum_of_squares = sum([i**2 for i in range(1, n+1)])\n    square_of_sum = sum(range(1, n+1))**2\n    return square_of_sum - sum_of_squares"}
{"task_id": 321, "completion": "def find_demlo(n):\n    if n < 1:\n        return \"N should be greater than or equal to 1\"\n    # Calculate a\n    a = 10**n - 1\n    # return a^2 as Demlo number\n    return a*a"}
{"task_id": 322, "completion": "def position_min(list1):\n    min_val = min(list1)\n    min_val_pos = [index for index, val in enumerate(list1) if val == min_val]\n    return min_val_pos"}
{"task_id": 323, "completion": "def rearrange(arr, n):\n    out_of_place = -1\n    for index in range(n):\n        if (out_of_place >= 0):\n            if ((arr[index] >= 0 and arr[out_of_place] < 0) or\n                (arr[index] < 0 and arr[out_of_place] >= 0)):\n                arr = right_rotate(arr, n, out_of_place, index)\n                if (index - out_of_place >= 2):\n                    out_of_place += 2\n                else:\n                    out_of_place = -1\n \n        if (out_of_place == -1):\n            if ((arr[index] >= 0 and index % 2 == 0) or\n                (arr[index] < 0 and index % 2 == 1)):\n                out_of_place = index\n    return arr\n`"}
{"task_id": 324, "completion": "def sum_of_alternates(test_tuple):\n    sum_even_index = sum(test_tuple[i] for i in range(0, len(test_tuple), 2)\n    sum_odd_index = sum(test_tuple[i] for i in range(1, len(test_tuple), 2)\n    \n    return sum_even_index, sum_odd_index"}
{"task_id": 325, "completion": "def get_Min_Squares(n):\n\n    # initializing list dp such that number of squares that sum to 'i' is 'i' as 'i' can always be represented as sum of 1's\n    dp = [i for i in range(n + 1)]\n    \n    # as 0 can be represented as sum of 0 squares\n    dp[0] = 0\n\n    for i in range(4, n + 1):\n        j = 1  # start from 1 to find all squares less than i\n        while j * j <= i:\n            dp[i] = min(dp[i], 1 + dp[i - j * j])\n            j += 1\n            \n    return dp[n]"}
{"task_id": 326, "completion": "def most_occurrences(test_list):\n    count_dict = defaultdict(int)\n    for str in test_list:\n        words = str.split()\n        for word in words:\n            count_dict[word] += 1\n    max_count = 0\n    max_word = ''\n    for word, count in count_dict.items():\n        if count > max_count:\n            max_count = count\n            max_word = word\n    return max_word"}
{"task_id": 327, "completion": "def check_isosceles(x, y, z):\n    if x == y or y == z or z == x:\n        print(\"This triangle is isosceles.\")\n    else:\n        print(\"This triangle is not isosceles.\")\n`"}
{"task_id": 328, "completion": "def rotate_left(list_, m, n):\n    return list_[m:n] + list_[:m] + list_[n:]"}
{"task_id": 329, "completion": "def neg_count(lst):\n    return len([num for num in lst if num < 0])\n`"}
{"task_id": 330, "completion": "import re\n\ndef find_char(text):\n    # Regex Pattern to find 3 to 5 character words\n    pattern = r'\\b\\w{3,5}\\b'\n    # Find all words matching the pattern\n    matches = re.findall(pattern, text)\n\n    return matches"}
{"task_id": 331, "completion": "def count_unset_bits(n):\n    # Convert the number into binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n\n    # Count the number of '0' in the binary string\n    count = binary.count('0')\n\n    return count"}
{"task_id": 332, "completion": "def char_frequency(str1):\n    # Creating an empty dictionary  \n    freq = {} \n    for i in str1: \n        if i in freq: \n            freq[i] += 1\n        else: \n            freq[i] = 1\n    return freq"}
{"task_id": 333, "completion": "def sort_sublist(lst):\n    return sorted(lst, key=lambda x: x[1])"}
{"task_id": 334, "completion": "def check_Validity(a, b, c):\n    if (a+b>c) and (a+c>b) and (b+c>a):\n        return \"Valid Triangle\"\n    else:\n        return \"Invalid Triangle\""}
{"task_id": 335, "completion": "def ap_sum(a, n, d):\n    return n / 2 * (2 * a + (n - 1) * d)"}
{"task_id": 336, "completion": "def check_monthnum(monthname):\n    # Create a list of months that have 28 days.\n    months_with_28_days = ['February']\n\n    # Check if the argument is in the list.\n    if monthname in months_with_28_days:\n        return True\n    else:\n        return False"}
{"task_id": 337, "completion": "def text_match_word(text, word):\n    pattern = r'\\b{}\\W*$'.format(word)\n    if re.search(pattern, text, re.IGNORECASE): \n        return True\n    else:\n        return False"}
{"task_id": 338, "completion": "def check_Equality(s):\n    result = 0;\n    n = len(s);\n    for i in range(n):\n        for j in range(i, n):\n            if (s[i] == s[j]): # if the first and last characters are same\n                result = result + 1 # increment the substring counter\n\n    return result"}
{"task_id": 339, "completion": "def find_Divisor(x, y):\n    # Creating count array to store the count of divisors\n    count = [0 for i in range(0, y+1)]\n    \n    # UPDATING THE COUNT ARRAY\n    # iterate from x to y\n    # for each number, check divisibility from 2 to i/2\n    # if number is divisible, then increment count of divisor\n    for i in range(x,y+1):\n        for j in range(1, int(i ** 0.5) + 1):\n            if i % j == 0:\n                # if divisors are equal, count only one\n                if i // j == j:\n                    count[j] += 1      \n                else : # else count both\n                    count[j] += 1\n                    count[i // j] += 1\n                    \n    # Finding max occurring number\n    max_count = 0\n    max_occuring_divisor = -1\n    for i in range(1, y+1):\n        if (count[i] > max_count):\n            max_count = count[i]\n            max_occuring_divisor = i\n    return max_occuring_divisor"}
{"task_id": 340, "completion": "def sum_three_smallest_nums(lst):\n    # filter positive numbers and sort them in ascending order\n    sorted_lst = sorted([num for num in lst if num > 0])\n    # return the sum of the smallest 3 numbers\n    return sum(sorted_lst[:3])"}
{"task_id": 341, "completion": "def set_to_tuple(s):\n    # Convert the set to tuple\n    tuple_s = tuple(s)\n    \n    # Sort the tuple\n    sorted_tuple_s = tuple(sorted(tuple_s))\n    \n    return sorted_tuple_s"}
{"task_id": 342, "completion": "import heapq\n\ndef smallest_range(lists):\n    pq = [(row[0], i, 0) for i, row in enumerate(lists)]\n    heapq.heapify(pq)\n    \n    res = -1e9, 1e9\n    right = max(row[0] for row in lists)\n    \n    while pq:\n        left, i, j = heapq.heappop(pq)\n        if right - left < res[1] - res[0]:\n            res = left, right\n        if j + 1 == len(lists[i]):\n            return res\n        v = lists[i][j+1]\n        right = max(right, v)\n        heapq.heappush(pq, (v, i, j+1))\n    return res"}
{"task_id": 343, "completion": "def dig_let(s):\n    digits = sum(c.isdigit() for c in s)\n    letters = sum(c.isalpha() for c in s)\n    return digits, letters"}
{"task_id": 344, "completion": "def count_odd_squares(n,m):\n    import math\n    return math.floor(math.sqrt(m)) - math.ceil(math.sqrt(n)) + 1"}
{"task_id": 345, "completion": "def diff_consecutivenums(nums):\n    return [j-i for i, j in zip(nums[:-1], nums[1:])]"}
{"task_id": 346, "completion": "def entringer_number(n, k):\n    # define base cases\n    if k > n:\n        return 0\n    elif k == n == 0:\n        return 1\n    else:\n        return ((n-1) * entringer_number(n-1, k)) + entringer_number(n, k-1)"}
{"task_id": 347, "completion": "def count_Squares(m, n):\n    return min(m, n)*(min(m, n)+1)*(2*min(m, n)+1)/6"}
{"task_id": 348, "completion": "def bin_coff(n, r):\n    f = [1]\n    for i in range(1, n + 1):\n        f.append(f[-1] * i)\n    \n    dp = [[0] * (n + 1) for _ in range(r + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, r + 1):\n        for j in range(n + 1):\n            for k in range(j + 1):\n                dp[i][j] += dp[i - 1][k]\n\n    ans = 0\n    for i in range(r, n + 1):\n        ans += f[n] // f[i] // f[n - i] * dp[i][n]\n\n    return ans"}
{"task_id": 349, "completion": "def check(string): \n    # create a set of all characters in the string\n    binary_set = set(string) \n\n    # declare a set for '0', '1'\n    binary = {'0', '1'} \n\n    # check if binary_set is same as 'binary' \n    if binary_set == binary or binary_set == {'0'} or binary_set == {'1'}: \n        print(\"The string is a binary string.\") \n    else: \n        print(\"The string is not a binary string.\") "}
{"task_id": 350, "completion": "def minimum_Length(s):\n    # Check if the string is not empty\n    if not s:\n        return \"String is empty\"\n    \n    freq = {}  # Dictionary to store frequency of each character\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n\n    # Find the character with maximum occurrence\n    max_char = max(freq, key=freq.get)\n\n    # Remove the character with maximum occurrence\n    min_string = s.replace(max_char, \"\")\n\n    return min_string"}
{"task_id": 351, "completion": "def first_Element(arr, n, k):\n    # Create a dictionary to store the count of all elements in the array \n    count = {}\n    for i in arr:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    # Iterate the given array again and return the first element \n    # with count equal to k\n    for i in arr:\n        if count[i] == k:\n            return i\n\n    # If no element has count k, return -1\n    return -1"}
{"task_id": 352, "completion": "def unique_Characters(str):\n    if len(set(str)) == len(str):\n        return True\n    else:\n        return False"}
{"task_id": 353, "completion": "def remove_column(nested_list, n):\n    try:\n        return [row[:n] + row[n+1:] for row in nested_list]\n    except IndexError:\n        print('The column you are trying to remove does not exist')"}
{"task_id": 354, "completion": "def tn_ap(a, n, d):\n    return a + (n-1)*d"}
{"task_id": 355, "completion": "def count_rectangles(radius):\n    count_points = 0\n    for x in range(0, radius+1):\n        for y in range(x, radius+1):  # Using symmetry to avoid repetitions.\n            if x**2 + y**2 <= radius**2:  # Checking if the point lies within the circle (including edge).\n                count_points += 1 if x == y else 4  # Counting the points accounting for symmetry.\n\n    # A rectangle needs 4 points so we divide the total number by 4.\n    return count_points//4"}
{"task_id": 356, "completion": "def find_angle(a,b):\n    \"\"\"This function calculates the third angle of a triangle given two angles.\"\"\"\n    if a < 0 or b < 0:\n        return 'Error: The angles of a triangle cannot be negative.'\n    elif a + b >= 180:\n        return 'Error: The sum of all angles in a triangle must be exactly 180 degrees.'\n    else:\n        return 180 - (a + b)"}
{"task_id": 357, "completion": "def find_max(test_list):\n    return max(max(t) for t in test_list)"}
{"task_id": 358, "completion": "def moddiv_list(nums1, nums2):\n    return list(map(lambda x, y: x % y, nums1, nums2))"}
{"task_id": 359, "completion": "def check_solution(a, b, c):\n    # Calculate the discriminant\n    d = b**2 - 4*a*c\n    \n    # discriminant must be greater than or equal to zero for real roots\n    if d >= 0:\n        root1 = (-b*math.sqrt(d))/(2*a)\n        root2 = (-b-math.sqrt(d))/(2*a)\n        \n        # check if one root is twice of the other\n        return abs(root1) == 2*abs(root2) or abs(root2) == 2*abs(root1)\n    else:\n        # Roots are complex\n        return False"}
{"task_id": 360, "completion": "def get_carol(n):\n    return ((2**n)-1)**2 - 2"}
{"task_id": 361, "completion": "def remove_empty(list1):\n    return [lst for lst in list1 if lst]"}
{"task_id": 362, "completion": "def max_occurrences(nums):\n    # Use a dictionary to count the occurrences of each number in the list.\n    occurrences = {}\n    for num in nums:\n        if num in occurrences:\n            occurrences[num] += 1\n        else:\n            occurrences[num] = 1\n\n    # Find the number with the maximum occurrences.\n    max_value = max(occurrences.values())\n    # Store the numbers that have the maximum occurrences in a list.\n    max_occurrences_nums = [num for num, count in occurrences.items() if count == max_value]\n\n    # Return the list of numbers with the maximum occurrences.\n    return max_occurrences_nums"}
{"task_id": 363, "completion": "def add_K_element(test_list, K):\n    # iterate over each tuple in the list\n    for idx in range(len(test_list)):\n        # convert tuple to a list, add K to each element, convert back to tuple\n        test_list[idx] = tuple([item + K for item in test_list[idx]])\n        \n    # return the modified list\n    return test_list"}
{"task_id": 364, "completion": "def make_flip(binary_string):\n    flips = 0\n    expected_char = binary_string[0]\n    for char in binary_string:\n        if char != expected_char:\n            flips += 1\n        # determine next expected character\n        expected_char = '1' if expected_char == '0' else '0'\n    return flips"}
{"task_id": 365, "completion": "def count_Digit(n):\n    return len(str(abs(n)))"}
{"task_id": 366, "completion": "def adjacent_num_product(list_nums):\n    # Initialize maximum product\n    max_product = list_nums[0] * list_nums[1]\n    for i in range(len(list_nums) - 1):\n        # Calculate product of two adjacent numbers\n        product = list_nums[i] * list_nums[i + 1]\n        # Update maximum product if current product is greater\n        if product > max_product:\n            max_product = product\n    # Return maximum product of pair of adjacent elements\n    return max_product"}
{"task_id": 367, "completion": "def is_balanced(root):\n    if root is None:\n        return True\n\n    height_diff = abs(height(root.left) - height(root.right))\n\n    if height_diff > 1:\n        return False\n    else:\n        return is_balanced(root.left) and is_balanced(root.right)"}
{"task_id": 368, "completion": "def repeat_tuples(test_tup, N):\n    # Using the * operator to repeat the tuple\n    return test_tup * N"}
{"task_id": 369, "completion": "def lateralsurface_cuboid(l, w, h):\n    # Lateral Surface Area = 2 * height * (length + width)\n    return 2 * h * (l + w)"}
{"task_id": 370, "completion": "def float_sort(price):\n    # Using the sorted() function with the lambda function key to sort tuples in ascending order base on its float element\n    return sorted(price, key=lambda x: float(x))"}
{"task_id": 371, "completion": "def smallest_missing(A, left_element, right_element):\n\n    if left_element > right_element:\n        return right_element + 1\n\n    middle_element = (left_element + right_element) // 2\n\n    if A[middle_element] == middle_element:\n        return smallest_missing(A, middle_element+1, right_element)\n    else:\n        return smallest_missing(A, left_element, middle_element-1)"}
{"task_id": 372, "completion": "def heap_assending(nums):\n    heapq.heapify(nums)\n    sorted_nums = [heapq.heappop(nums) for _ in range(len(nums)]\n    return sorted_nums"}
{"task_id": 373, "completion": "def volume_cuboid(length, width, height):\n    # calculate volume\n    volume = length * width * height\n    return volume"}
{"task_id": 374, "completion": "def permute_string(s):\n    \"\"\"\n    Print all permutations of a given string.\n\n    :param s: Input string\n    :type s: str\n    \"\"\"\n    # Generate all permutations using itertools.permutations()\n    permutations = itertools.permutations(s)\n\n    # Print each permutation\n    for p in permutations:\n        print(''.join(p))"}
{"task_id": 375, "completion": "def round_num(n, m):\n    return round(n/m) * m"}
{"task_id": 376, "completion": "def remove_replica(test_tup, replace_value):\n    seen = {}  # Tracker for seen elements\n    new_list = list(test_tup)  # Convert tuple to list for in-place modification\n\n    for i, item in enumerate(new_list):\n        if item in seen:\n            # Replace duplicates with `replace_value`\n            new_list[i] = replace_value\n        else:\n            # Keep track of this item as seen\n            seen[item] = True\n\n    return tuple(new_list)"}
{"task_id": 377, "completion": "def remove_Char(s, c):\n    # replace the character c with nothing\n    s = s.replace(c, '')\n    return s"}
{"task_id": 378, "completion": "def move_last_to_first(test_list):\n    # The last element is fetched by test_list[-1], then removed by test_list[:-1]\n    # The two are then recombined in new order \"last element + rest of the list\"\n    return [test_list[-1]] + test_list[:-1]"}
{"task_id": 379, "completion": "def surfacearea_cuboid(l, w, h):\n    # The surface area of a cuboid is 2lw + 2lh + 2wh\n    return 2 * l * w + 2 * l * h + 2 * w * h"}
{"task_id": 380, "completion": "def multi_list(rownum, colnum):\n    return [[0 for col in range(colnum)] for row in range(rownum)]"}
{"task_id": 381, "completion": "def sort_by_index(list_data, index_no):\n    \"\"\"Sorts a list of lists by a given index of inner lists.\n\n    Args:\n    list_data (List[List[Any]]): List of lists to be sorted.\n    index_no (int): Index number of inner lists to sort by.\n\n    Returns:\n    List[List[Any]]: Sorted list of lists.\n    \"\"\"\n    \n    list_data.sort(key=lambda x: x[index_no])\n    return list_data"}
{"task_id": 382, "completion": "def find_rotation_count(A):\n    # initialize variables \n    low, high = 0, len(A) - 1\n\n    # Loop until low and high meet\n    while low < high:\n\n        mid = (low + high) // 2\n\n        # If mid element is less than high element, the smallest \n        # element is in the left half of the array \n        if A[mid] < A[high]:\n            high = mid\n\n        # If mid element is greater than high element, the smallest \n        # element is in the right half of the array\n        else: \n            low = mid +  1\n\n    return low"}
{"task_id": 383, "completion": "def even_bit_toggle_number(n):\n    mask = 0xAAAAAAAA\n    return n ^ mask"}
{"task_id": 384, "completion": "def frequency_of_smallest(n, arr):\n    # Find the smallest value in the array\n    smallest = min(arr)\n\n    # Count the frequency of the smallest value\n    frequency = arr.count(smallest)\n\n    return frequency\n`"}
{"task_id": 385, "completion": "def get_perrin(n):\n    if (n==0):\n        return 3\n    elif (n==1):\n        return 0\n    elif (n==2):\n        return 2\n    else:\n        return get_perrin(n-2) + get_perrin(n-3)"}
{"task_id": 386, "completion": "def swap_count(s):\n    # Counters for left and right brackets, and swap and imbalance count\n    left_brackets = right_brackets = swap = imbalance = 0\n    \n    # Iterating over the string\n    for bracket in s:\n        if bracket == '[':\n            # Increment the left bracket count\n            left_brackets += 1\n            # If imbalance, perform swap and increment swap count\n            if imbalance > 0:\n                swap += imbalance\n                imbalance -= 1\n        elif bracket == ']':\n            # Increment the right bracket count\n            right_brackets += 1\n            # Imbalance is difference between left and right brackets\n            imbalance = (right_brackets - left_brackets)\n\n    return swap"}
{"task_id": 387, "completion": "def even_or_odd(N):\n    # Convert hexadecimal to decimal\n    decimal = int(N, 16)\n\n    # Check if the number is even or odd\n    if decimal % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n`"}
{"task_id": 388, "completion": "def highest_power_of_2(n):\n    i = 1\n    while i <= n:\n        i = i * 2\n    return i//2"}
{"task_id": 389, "completion": "def find_lucas(n):\n    if n == 0:\n        return 2\n    if n == 1:\n        return 1\n\n    a, b = 2, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b"}
{"task_id": 390, "completion": "def add_string(lst, s):\n    # Insert the given string at the beginning of all items in a list\n    return [s + str(i) for i in lst]"}
{"task_id": 391, "completion": "def convert_list_dictionary(l1, l2, l3):\n    nested_dict = {} #initialize an empty dictionary\n    \n    for i in range(len(l1)):\n        if l1[i] not in nested_dict:\n            nested_dict[l1[i]] = {}\n\n        if l2[i] not in nested_dict[l1[i]]:\n            nested_dict[l1[i]][l2[i]] = {}\n\n        nested_dict[l1[i]][l2[i]] = l3[i]\n        \n    return nested_dict"}
{"task_id": 392, "completion": "from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef get_max_sum(n):\n    if n < 2:\n        return n\n    else:\n        return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)"}
{"task_id": 393, "completion": "def max_length_list(input_list):\n    return max(input_list, key=lambda x: len(x))"}
{"task_id": 394, "completion": "def check_distinct(test_tup):\n    return len(test_tup) == len(set(test_tup))"}
{"task_id": 395, "completion": "def first_non_repeating_character(str1):\n    char_order = []\n    ctr = {}\n    for c in str1:\n        if c in ctr:\n            ctr[c] += 1\n        else:\n            ctr[c] = 1 \n            char_order.append(c)\n    for c in char_order:\n        if ctr[c] == 1:\n            return c\n    return None"}
{"task_id": 396, "completion": "def check_char(string):\n    if re.match(r'^(\\w).*\\1$', string):\n        return True\n    else:\n        return False"}
{"task_id": 397, "completion": "def median_numbers(a, b, c):\n    numbers = [a, b, c]   # Put numbers into a list\n    numbers.sort()    # Sort the numbers\n    return numbers[1]   # Return the middle number, which is the median"}
{"task_id": 398, "completion": "def sum_of_digits(nums):\n  return [sum(int(digit) for digit in str(num)) for num in nums]"}
{"task_id": 399, "completion": "def bitwise_xor(tup1, tup2):\n    # check if the lengths of both tuples are the same\n    if len(tup1) != len(tup2):\n        return \"Tuples are not the same length\"\n        \n    # create an empty list to store the result\n    result = []\n\n    # perform the XOR operation for each pair of elements in the tuples\n    for num1, num2 in zip(tup1, tup2):\n        result.append(num1 ^ num2)\n\n    # convert the result list to a tuple and return it\n    return tuple(result)"}
{"task_id": 400, "completion": "def extract_freq(test_list):\n    # Using collections.Counter to count tuples\n    freq_dict = dict(Counter(test_list))\n    return freq_dict"}
{"task_id": 401, "completion": "def add_nested_tuples(test_tup1, test_tup2):\n    # Using zip() + generator expression to add elements of nested tuples\n    return tuple(tuple(sum(i) for i in zip(*tup)) for tup in zip(test_tup1, test_tip2))"}
{"task_id": 402, "completion": "# Returns nCr % p using Fermat's little theorem.\ndef ncr_modp(n, r, p):\n    if r==0:\n        return 1\n \n    # compute factorial of n, r and n-r\n    n_fact = fact(n, p)\n    r_fact = fact(r, p)\n    n_minus_r_fact = fact(n - r, p)\n \n    # Compute denominator using modular multiplicative inverse\n    denominator = (r_fact * n_minus_r_fact) % p\n \n    # Use fermat's little theorem to find inverse: denominator^(p-2) % p\n    inverse_denominator = pow(denominator, p - 2, p)\n \n    # compute final result\n    return (n_fact * inverse_denominator) % p"}
{"task_id": 403, "completion": "def is_valid_URL(input_str):\n    pattern = re.compile(\n        r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\\\(\\\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'\n    )\n    if pattern.match(input_str):\n        return True\n    return False"}
{"task_id": 404, "completion": "def minimum(a, b):\n    if a < b:\n        return a\n    else:\n        return b"}
{"task_id": 405, "completion": "def check_tuplex(tuplex, tuple1):\n    if tuple1 in tuplex:\n        return True\n    else:\n        return False"}
{"task_id": 406, "completion": "def find_Parity(x):\n    if (x % 2 == 0):\n        return 'Even'\n    else:\n        return 'Odd'"}
{"task_id": 407, "completion": "def rearrange_bigger(n):\n    # Convert number to list of characters\n    n = list(str(n))\n\n    # Find the non-increasing suffix from the right\n    for i in range(len(n) - 1, 0, -1):\n        if n[i] > n[i-1]:\n            break\n    else: \n        return -1 \n\n    # Find the successor to pivot in the suffix and swap them\n    for j in range(len(n) - 1, -1, -1):\n        if n[j] > n[i-1]:\n            n[i-1], n[j] = n[j], n[i-1] \n            break \n\n    # Reverse the suffix to create the smallest lexicographic arrangement\n    n[i:] = reversed(n[i:])\n\n    # Convert list of characters back to integer\n    n = int(''.join(n))\n\n    return n"}
{"task_id": 408, "completion": "def k_smallest_pairs(nums1, nums2, k):\n    queue = []\n    def push(i, j):\n        if i < len(nums1) and j < len(nums2):\n            heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\n    # start from top left and push the smallest to the queue\n    push(0, 0)\n    result = []\n    while queue and len(result) < k:\n        _, i, j = heapq.heappop(queue)\n        result.append([nums1[i], nums2[j]])\n        # there are still elements in the current row\n        push(i, j + 1)\n        # if it is the first element of the row, push the first element of the next row\n        if j == 0:\n            push(i + 1, 0)\n    return result"}
{"task_id": 409, "completion": "def min_product_tuple(lst):\n    if len(lst) == 0:\n        return \"List is empty\"\n    \n    # Initialize minimum product as product of first tuple\n    min_product = lst[0][0] * lst[0][1]\n   \n    # Iterate over the list \n    for tup in lst:\n        # Calculate product of current tuple\n        product = tup[0] * tup[1]\n        \n        # If current product is smaller than min_product\n        if product < min_product:\n            # update min_product\n            min_product = product\n            \n    return min_product\n`"}
{"task_id": 410, "completion": "def min_val(listval):\n    int_float_lst = []\n    str_lst = []\n\n    for val in listval:\n        if isinstance(val, int) or isinstance(val, float):\n            int_float_lst.append(val)\n        elif isinstance(val, str): \n            str_lst.append(val)\n    \n    if int_float_lst:\n        min_int_float = min(int_float_lst)\n    else:\n        min_int_float = None\n\n    if str_lst:\n        min_str = min(str_lst, key=len)\n    else:\n        min_str = None\n\n    return {\"Min of int/float\": min_int_float, \"Min of string\": min_str}"}
{"task_id": 411, "completion": "import re \n\ndef snake_to_camel(word):\n    return ''.join(x.capitalize() or '_' for x in word.split('_'))"}
{"task_id": 412, "completion": "def remove_odd(l):\n    new_list = [i for i in l if i % 2 == 0]\n    return new_list"}
{"task_id": 413, "completion": "def extract_nth_element(input_list, n):\n    \"\"\"\n    Function to extract the nth element from a list of tuples.\n    Parameters:\n        input_list: List of tuples where each tuple represents a group of elements\n        n: The index to be extracted from each tuple in the input_list\n    Returns:\n        A list of nth elements from each tuple of the input_list\n    \"\"\"\n\n    # Check if n is valid \n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n\n    output_list = []\n    \n    for tup in input_list:\n        try:\n            output_list.append(tup[n])\n        except IndexError:\n            print(\"The n-th index is not present in all tuples.\")\n            return\n\n    return output_list"}
{"task_id": 414, "completion": "def overlapping(list1, list2):\n    \"\"\"\n    This function checks whether there is any common element in the two lists.\n    If found, it will return True otherwise it will return False.\n    \"\"\"\n    \n    for element in list1:\n        if element in list2:\n            return True\n    return False"}
{"task_id": 415, "completion": "def max_Product(arr):\n    n = len(arr)\n\n    # if the array has less than two elements\n    if (n < 2):\n        return \"No pairs exists\"\n\n    # Sorting the array in ascending order\n    arr.sort()\n    \n    # Check the product of two largest numbers and two smallest numbers\n    max_product = max(arr[0] * arr[1], arr[n - 1] * arr[n - 2])\n    \n    # Pairs with max_product\n    if max_product == arr[0] * arr[1]:\n        return \"Pair is\", arr[0], \"and\", arr[1]\n    else:\n        return \"Pair is\", arr[n - 1], \"and\", arr[n - 2]\n`"}
{"task_id": 416, "completion": "def breakSum(n):\n    if n < 4:\n        return n\n    result = n\n    for i in range(1, n):\n        sub_res = breakSum(i) + breakSum(n-i)\n        result = max(result, sub_res)\n    return result"}
{"task_id": 417, "completion": "def group_tuples(input_list):\n    # Create a list for the first elements\n    first_elements = [tup[0] for tup in input_list]\n    \n    # Create a dictionary to store the count of each element\n    element_count = {element: first_elements.count(element) for element in first_elements}\n    \n    # Return elements that have a count greater than 1 (common elements)\n    return [element for element, count in element_count.items() if count > 1]"}
{"task_id": 418, "completion": "def find_max(lst):\n    # Initialize maximum length as -1 (which is a length that sublists cannot have)\n    max_len = -1\n\n    # Initialize max_list as an empty list\n    max_list = []\n\n    # Iterate over all the sublists in lst\n    for sub_list in lst:\n        # Get the length of the current sublist\n        len_sub_list = len(sub_list)\n        \n        # If this length is longer than current maximum length\n        if len_sub_list > max_len:\n            # Update maximum length\n            max_len = len_sub_list\n\n            # Set max_list as the current sublist\n            max_list = sub_list\n            \n    # Return the sublist with maximum length\n    return max_list"}
{"task_id": 419, "completion": "def round_and_sum(list1):\n    # First, let's round every number in the list\n    rounded_list = [round(num) for num in list1]\n    \n    # Next, compute the sum of the rounded numbers\n    sum_of_rounded = sum(rounded_list)\n    \n    # Calculate the total sum, which is the sum of rounded numbers times the length of the list\n    total_sum = sum_of_rounded * len(list1)\n    \n    # Print the total sum\n    print(total_sum)"}
{"task_id": 420, "completion": "def cube_sum(n):\n    total = 0\n    for i in range(1, n*2+1):\n        if i % 2 == 0:\n            total += i ** 3\n    return total"}
{"task_id": 421, "completion": "def concatenate_tuple(input_tuple, delimiter):\n    return delimiter.join(map(str, input_tuple))"}
{"task_id": 422, "completion": "def find_Average_Of_Cube(n): \n    sum_of_cubes = 0 \n     \n    # Calculating the cubes and adding them \n    for i in range(1, n+1): \n        sum_of_cubes += i**3 \n     \n    # returning the average \n    return sum_of_cubes / n  "}
{"task_id": 423, "completion": "def get_maxgold(gold, m, n):\n    # Create a 2D list to store the max gold that can be collected\n    # from that cell until the last cell in the grid\n    goldTable = [[0 for i in range(m)] for j in range(n)]\n \n    for col in range(n-1, -1, -1):\n        for row in range(m):\n            # If this is the last column, then the max gold will be the current cell's gold\n            if col == n-1:\n                right = 0\n            else:\n                right = goldTable[row][col+1]\n \n            # If this cell is the last column or last row, then the max gold\n            # for right-up cell will be 0\n            if col == n-1 or row == 0:\n                right_up = 0\n            else:\n                right_up = goldTable[row-1][col+1]\n \n            # If this cell is the last column or first row, then the max gold for\n            # right-down cell will be 0\n            if col == n-1 or row == m-1:\n                right_down = 0\n            else:\n                right_down = goldTable[row+1][col+1]\n \n            # Update the max gold for this cell\n            goldTable[row][col] = gold[row][col] + max(right, right_up, right_down)\n    \n    # The first column's max value will be the max gold that can be collected\n    res = goldTable[0][0]\n    for i in range(1, m):\n        res = max(res, goldTable[i][0])\n \n    return res"}
{"task_id": 424, "completion": "def extract_rear(test_tuple):\n    # Initialize an empty list to store extracted rear elements\n    extracted_elements = []\n    \n    # Iterate over each string in the tuple\n    for string in test_tuple:\n        # Extract the rear element and append it to the list\n        extracted_elements.append(string[-1])\n    \n    # Convert the list back into a tuple and return it\n    return tuple(extracted_elements)"}
{"task_id": 425, "completion": "def count_element_in_list(list1, x):\n    count = 0\n    for sublist in list1:\n        # Check if the element is in the sublist\n        if x in sublist:\n            count += 1\n    return count\n"}
{"task_id": 426, "completion": "def filter_oddnumbers(nums):\n    # Filter list using lambda function for finding odd numbers\n    odd_nums = list(filter(lambda x: x % 2 != 0, nums))\n    return odd_nums"}
{"task_id": 427, "completion": "def change_date_format(dt):\n    # Checks if the input matches the correct format\n    if re.match(r'\\d{4}-\\d{2}-\\d{2}', dt):\n        # Converts the date to the new format\n        new_date = datetime.strptime(dt, \"%Y-%m-%d\").strftime(\"%d-%m-%Y\")\n        return new_date\n\n    # Returns an error message if the input format is wrong\n    else:\n        return \"Error: Date format should be 'YYYY-MM-DD'\""}
{"task_id": 428, "completion": "def shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            temp = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > temp:\n                my_list[j] = my_list[j - gap]\n                j = j-gap\n            my_list[j] = temp\n        gap = gap // 2\n    return my_list"}
{"task_id": 429, "completion": "def and_tuples(test_tup1, test_tup2):\n    # If the tuples are not of the same size\n    if len(test_tup1) != len(test_tup2):\n        return -1\n\n    # Creating an empty list\n    result = []\n\n    # Loop over tuples\n    for i in range(len(test_tup1)):\n        # Add to result list a tuple containing the elementwise and of the elements at the same indices in each tuple\n        result.append((test_tup1[i] and test_tup2[i]))\n\n    # Return the result as tuple\n    return tuple(result)\n`"}
{"task_id": 430, "completion": "def parabola_directrix(a, b, c):\n    directrix = c - (1/(4*a))\n    return directrix"}
{"task_id": 431, "completion": "def common_element(list1, list2):\n    for element in list1:\n        if element in list2:\n            return True\n    return False"}
{"task_id": 432, "completion": "def median_trapezium(base1, base2):\n    return (base1 + base2) / 2"}
{"task_id": 433, "completion": "def check_greater(arr, number):\n    # Iterate over each element in array\n    for element in arr:\n\n        # If given number is less than or equal to an element of the array\n        if number <= element:\n\n            # Return False (given number is not greater than all elements in the array)\n            return False\n\n    # If given number is greater than all elements in the array, return True\n    return True"}
{"task_id": 434, "completion": "def text_match_one(text):\n    pattern = 'ab+'\n    if re.search(pattern, text):\n        return 'Found a match.'\n    else:\n        return 'Not matched.'"}
{"task_id": 435, "completion": "def last_Digit(n):\n    # Convert the number to string and get the last character\n    last_digit_str = str(n)[-1]\n    # Convert the last character back to integer\n    return int(last_digit_str)"}
{"task_id": 436, "completion": "def print_neg_numbers(list1):\n    for num in list1:\n        if num < 0:\n            print(num)"}
{"task_id": 437, "completion": "def remove_odd(str1):\n    result = \"\"\n    for i in range(len(str1)):\n        if i % 2 == 0:  # check if the index is even\n            result += str1[i]  # add the character at even index to the result string\n    return result"}
{"task_id": 438, "completion": "def count_bidirectional(test_list):\n    # Create an empty set to store unique bidirectional pairs\n    unique_pairs = set()\n    # Loop over the list\n    for pair in test_list:\n        # Check if the reverse pair is not in the set already\n        if (pair[1], pair[0]) not in unique_pairs:\n            # If not, add the current pair to the set\n            unique_pairs.add(pair)\n    # Return the number of unique bidirectional pairs\n    return len(unique_pairs)"}
{"task_id": 439, "completion": "def multiple_to_single(L):\n    return int(''.join(map(str, L)))"}
{"task_id": 440, "completion": "def find_adverb_position(text):\n    tokens = nltk.word_tokenize(text)\n    tagged = nltk.pos_tag(tokens)\n    adverbs = [word for word, pos in tagged if pos == 'RB' or pos == 'RBR' or pos == 'RBS']\n    adverb_positions = {word: [i for i, token in enumerate(tokens) if token == word] for word in adverbs}\n    return adverb_positions"}
{"task_id": 441, "completion": "def surface_area_cube(l):\n    return 6 * (l**2)"}
{"task_id": 442, "completion": "def positive_count(nums):\n    # if list is empty, return 0\n    if not nums:\n        return 0\n    \n    # count positive numbers\n    pos_nums = sum(1 for num in nums if num > 0)\n    \n    # calculate ratio\n    pos_ratio = pos_nums / len(nums)\n    \n    return pos_ratio"}
{"task_id": 443, "completion": "def largest_neg(list1):\n    neg_numbers = [num for num in list1 if num < 0] \n    if not neg_numbers:                             \n        return None\n    return max(neg_numbers)                         "}
{"task_id": 444, "completion": "def trim_tuple(test_list, K):\n    trimmed_tuples = [t[:-K] if len(t) > K else t for t in test_list]\n    return trimmed_tuples"}
{"task_id": 445, "completion": "def index_multiplication(tup1, tup2):\n    # Check if the tuples are of equal length\n    if len(tup1) != len(tup2):\n        return \"Input tuples must be of the same length\"\n\n    # Empty list to hold the results\n    result = []\n\n    # Loop through the tuples\n    for i in range(len(tup1)):\n        # Append the resultant multiplication to the result list\n        result.append(tup1[i] * tup2[i])\n\n    # Convert the result list to a tuple and return\n    return tuple(result)"}
{"task_id": 446, "completion": "def count_occurrence(tup, lst):\n    # Create a dictionary to store the counts\n    count_dict = {} \n\n    # Iterate over the elements of the list\n    for ele in lst:         \n        # count() method returns the occurrence of an element in a tuple\n        count_dict[ele] = tup.count(ele)\n\n    return count_dict\n`"}
{"task_id": 447, "completion": "def cube_nums(nums):\n    return list(map(lambda x: x**3, nums))"}
{"task_id": 448, "completion": "def perrin(n):\n    p = [3, 0, 2]\n    if n < 3:\n        return p[n]\n    for i in range(3, n+1):\n        p.append(p[i-2] + p[i-3])\n    return p"}
{"task_id": 449, "completion": "def check_Triangle(x1,y1,x2,y2,x3,y3):\n    # calculate the area using formula: 0.5 * abs((x1*(y2-y3) + x2*(y3-y1)+ x3*(y1-y2))\n    area = 0.5 * abs((x1*(y2-y3) + x2*(y3-y1)+ x3*(y1-y2))) \n\n    # if area is zero, it's not a valid triangle\n    if area == 0:\n        return False\n    else:\n        return True\n`"}
{"task_id": 450, "completion": "def extract_string(str_list, l):\n    # This function will return a list with strings of specified size from a given list\n\n    # Initializing an empty list to hold the strings with the specified length\n    result = []\n\n    # Iterating through the list elements\n    for str in str_list:\n\n        # Checking the length of the string\n        if len(str) == l:\n\n            # Adding the string to the result list if its length matches the specified size\n            result.append(str)\n\n    # Returning the result\n    return result"}
{"task_id": 451, "completion": "def remove_whitespaces(text):\n    return re.sub(r'\\s', '', text)"}
{"task_id": 452, "completion": "def loss_amount(actual_cost, sale_amount):\n    if actual_cost > sale_amount:\n        return actual_cost - sale_amount\n    else:\n        return None"}
{"task_id": 453, "completion": "def sumofFactors(n):\n    sum = 0 \n    # Iterate from 1 to n\n    for i in range(1,n+1): \n        # if 'i' is factor of n\n        if n % i == 0:  \n            # check if it is even then add to the sum\n            if i % 2 == 0:\n                sum += i  \n    return sum"}
{"task_id": 454, "completion": "def text_match_wordz(text):\n    if 'z' in text:\n        return True\n    else:\n        return False"}
{"task_id": 455, "completion": "def check_monthnumb_number(month):\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    else:\n        return False"}
{"task_id": 456, "completion": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]"}
{"task_id": 457, "completion": "def Find_Min(lst):\n    # check if the list is empty\n    if not lst:\n        return []\n    # initially assign the first sublist as the minimum\n    min_len_sublist = lst[0]\n    # iterate over the list\n    for sublist in lst:\n        # check if the current sublist has a smaller length than the current minimum\n        if len(sublist) < len(min_len_sublist):\n            min_len_sublist = sublist  # update the minimum sublist\n    return min_len_sublist"}
{"task_id": 458, "completion": "def rectangle_area(length, breadth):\n    # Calculate the area of the rectangle\n    area = length * breadth\n\n    # Return the area of the rectangle\n    return area"}
{"task_id": 459, "completion": "def remove_uppercase(str1):\n    return re.sub(r'[A-Z]', '', str1)"}
{"task_id": 460, "completion": "def extract(lst):\n    return [item[0] for item in lst]"}
{"task_id": 461, "completion": "def upper_ctr(str):\n    upper_count = 0\n    for letter in str:\n        if letter.isupper():\n            upper_count += 1\n    return upper_count"}
{"task_id": 462, "completion": "def combinations_list(list1):\n    # This variable will hold all the possible combinations\n    combination_results = []\n\n    # Generating all combination lengths (from 1 to length of the list)\n    for r in range(1, len(list1) + 1):\n        # Use itertools.combinations() to generate and append the combinations\n        combination_results.extend(list(combinations(list1, r)))\n\n    return combination_results"}
{"task_id": 463, "completion": "def max_subarray_product(arr):\n    if len(arr) == 0:         # If array is empty, return 0\n        return 0\n\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n    max_product = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n\n        max_ending_here = max(arr[i], max_ending_here*arr[i])\n        min_ending_here = min(arr[i], min_ending_here*arr[i])\n\n        max_product = max(max_product, max_ending_here)\n\n    return max_product\n```"}
{"task_id": 464, "completion": "def check_value(dict, n):\n\n    # Get all values of the dictionary \n    values = dict.values()\n    \n    # Check if all values are equal\n    for value in values:\n        if value != n:\n            return False\n    \n    return True"}
{"task_id": 465, "completion": "def drop_empty(dictionary):\n    return {k: v for k, v in dictionary.items() if v}"}
{"task_id": 466, "completion": "def find_peak_util(arr, low, high, n):\n    mid = low + (high - low)//2 \n\n    if ((mid == 0 or arr[mid - 1] <= arr[mid]) and\n       (mid == n - 1 or arr[mid + 1] <= arr[mid])) :\n        return mid\n  \n    elif (mid > 0 and arr[mid - 1] > arr[mid]) :\n        return find_peak_util(arr, low, (mid -1), n)\n\n    else :\n        return find_peak_util(arr, (mid + 1), high, n)"}
{"task_id": 467, "completion": "def decimal_to_Octal(deciNum):\n    octalNum = 0\n    ctr = 0\n    temp = deciNum  #copying number\n\n    #computing octal using while loop\n    while(temp > 0):\n        octalNum += ((temp%8)*(10**ctr))\n        temp = int(temp/8)\n        ctr += 1\n    return octalNum"}
{"task_id": 468, "completion": "def max_product(arr, n):\n    # Create a max_product_list to store the maximum product for all \n    # subsequences ending at each index in the arr array. \n    max_product_list = [0] * n \n\n    # Traverse through the given array\n    for i in range(n):\n        # max_product_list[i] is always going to be arr[i] at the least\n        max_product_list[i] = arr[i]\n        for j in range(i):\n            # We ensure the subsequence is increasing\n            if arr[j] < arr[i]: \n                # Update the max_product_list if it's greater than existing\n                max_product_list[i] = max(max_product_list[i], arr[i]*max_product_list[j])\n        \n    # return the maximum value from max_product_list\n    return max(max_product_list)"}
{"task_id": 469, "completion": "def max_profit(prices, k):\n    if not prices:\n        return 0\n\n    if k >= len(prices) // 2:\n        return sum(i - j for i, j in zip(prices[1:], prices[:-1]) if i - j > 0)\n\n    profits = [0] * len(prices)\n    for _ in range(k):\n        prev_profit = 0\n        for i in range(1, len(prices)):\n            profit = prices[i] - prices[i - 1]\n            prev_profit = max(profits[i], prev_profit + profit)\n            profits[i] = max(profits[i - 1], prev_profit)\n\n    return profits[-1]"}
{"task_id": 470, "completion": "def add_pairwise(tup1, tup2):\n    \"\"\"\n    Function to add pairwise elements of two tuples.\n\n    Parameters:\n    tup1 (tuple): The first tuple\n    tup2 (tuple): The second tuple\n\n    Returns:\n    tuple: A tuple containing the pairwise sums\n    \"\"\"\n    \n    # Check if the length of the tuples are equal\n    if len(tup1) != len(tup2):\n        return \"Length of the tuples does not match\"\n    \n    # Add the corresponding elements of the tuples \n    result = tuple(a + b for a, b in zip(tup1, tup2))\n  \n    return result\n`"}
{"task_id": 471, "completion": "def find_remainder(arr, n):\n    result = 1\n    for i in arr:\n        result = (result * i % n) % n\n    return result % n"}
{"task_id": 472, "completion": "def check_consecutive(l):\n    if sorted(l) == list(range(min(l), max(l) + 1)):\n        return True\n    else:\n        return False"}
{"task_id": 473, "completion": "def tuple_intersection(test_list1, test_list2):\n    test_list1 = [tuple(sorted(i)) for i in test_list1]\n    test_list2 = [tuple(sorted(i)) for i in test_list2]\n    return [i for i in test_list1 if i in test_list2]"}
{"task_id": 474, "completion": "def replace_char(str1, ch, newch):\n    new_str = str1.replace(ch, newch)\n    return new_str"}
{"task_id": 475, "completion": "def sort_counter(counter):\n    return Counter(sorted(counter.items(), key=lambda item: item[1]))\n`"}
{"task_id": 476, "completion": "def big_sum(nums):\n    if not nums:\n        return 0\n    else:\n        return max(nums) + min(nums)"}
{"task_id": 477, "completion": "def is_lower(string):\n    return string.lower()"}
{"task_id": 478, "completion": "def remove_lowercase(str1):\n    res = ''\n    for char in str1:\n        if not char.islower():\n            res += char\n    return res"}
{"task_id": 479, "completion": "def first_Digit(n):\n    # convert the number into string and take the first character\n    n = str(n)\n    # return first character as int\n    return int(n[0])"}
{"task_id": 480, "completion": "def get_max_occuring_char(str1):\n    # creating a dictionary to keep track of the character frequency\n    char_count = {}\n\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # finding the max frequency and the corresponding character\n    max_count = 0\n    max_char = ''\n    for char, count in char_count.items():\n        if count > max_count:\n            max_count = count\n            max_char = char\n    return max_char"}
{"task_id": 481, "completion": "def is_subset_sum(set, n, sum):\n    # Initialize a 2D boolean array dp[][] such that dp[i][j]\n    # will be True if there is a subset of set[0..j-1] with sum equal to i\n    dp = [[False for _ in range(sum + 1)] for _ in range(n + 1)]\n    \n    # There is always a subset with sum 0, the empty set\n    for i in range(n + 1):\n        dp[i][0] = True\n  \n    # Fill dp[][] in bottom up manner\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            dp[i][j] = dp[i-1][j]\n            if j >= set[i-1]:\n                dp[i][j] = dp[i][j] or dp[i-1][j-set[i-1]]\n              \n    # return True if there is a subset with sum equal to given sum, otherwise False\n    return dp[n][sum]"}
{"task_id": 482, "completion": "def match(text):\n    pattern = r'[A-Z][a-z]*'\n    matches = re.findall(pattern, text)\n    return matches\n`"}
{"task_id": 483, "completion": "def first_Factorial_Divisible_Number(x):\n    i = 1\n    while True:\n        factorial = math.factorial(i)\n        if factorial % x == 0:\n            return i\n        i += 1"}
{"task_id": 484, "completion": "def remove_matching_tuple(test_list1, test_list2):\n    # Using list comprehension + tuple() + filter() + lambda\n    # Remove matching tuple records\n    res = [ele for ele in test_list1 if ele not in test_list2]\n  \n    return res"}
{"task_id": 485, "completion": "def largest_palindrome(arr):\n    arr = sorted(filter(is_palindrome, arr), reverse=True)\n    if arr:\n        return arr[0]\n    else:\n        return None"}
{"task_id": 486, "completion": "def nCr(n, r):\n    return math.factorial(n) / (math.factorial(r) * math.factorial(n - r))"}
{"task_id": 487, "completion": "def sort_tuple(tup):\n    # using sorted and lambda to sort the list\n    tup.sort(key = lambda x: x[-1])\n    \n    return tup"}
{"task_id": 488, "completion": "import math\n\ndef area_pentagon(s):\n    area = (5 * (s ** 2)) / (4 * math.tan(math.pi/5))\n    return area"}
{"task_id": 489, "completion": "def frequency_Of_Largest(n, arr):\n    # Get the maximum value from the array\n    max_val = max(arr)\n    \n    # Count the frequency of the max value\n    count = arr.count(max_val)\n    \n    return count"}
{"task_id": 490, "completion": "def extract_symmetric(test_list):\n    # create an empty set to store our result\n    symmetrical_pairs = []\n    # loop through the list\n    for pair in test_list:\n        # check if reverse tuple exists in list and it's not already in our result\n        if (pair[1], pair[0]) in test_list and not symmetrical_pairs.__contains__((pair[1], pair[0])):\n            symmetrical_pairs.append(pair)\n    return symmetrical_pairs"}
{"task_id": 491, "completion": "def sum_gp(a, n, r):\n    if r == 1:\n        return a * n\n    else:\n        return a * (1 - (r ** n)) / (1 - r)\n`"}
{"task_id": 492, "completion": "def binary_search(item_list, item):\n    low = 0\n    high = len(item_list) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        guess = item_list[mid]\n        if guess == item:\n            return mid  # returns the position of the item if found\n        if guess > item:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return None  # item not found"}
{"task_id": 493, "completion": "def calculate_polygons(startx, starty, endx, endy, radius):\n    \"\"\"Calculates a grid of hexagon coordinates.\"\"\"\n    hex_width = 2 * radius\n    hex_height = math.sqrt(3) * radius\n    columns = int((endx - startx) / hex_width) + 1\n    rows = int((endy - starty) / hex_height) + 1\n\n    result = []\n    for row in range(0, rows):\n        for col in range(0, columns):\n            x = startx + col * hex_width\n            y = starty + row * hex_height\n            if row % 2 == 0:\n                x += radius\n            hexagon = [\n                (x - radius, y),\n                (x - radius/2, y - hex_height/2),\n                (x + radius/2, y - hex_height/2),\n                (x + radius, y),\n                (x + radius/2, y + hex_height/2),\n                (x - radius/2, y + hex_height/2)\n            ]\n            result.append(hexagon)\n    return result"}
{"task_id": 494, "completion": "def binary_to_integer(test_tup):\n    # Convert tuple to string\n    binary_string = ''.join(str(bit) for bit in test_tup)\n    \n    # Convert binary string to integer\n    integer = int(binary_string, 2)\n    \n    return integer"}
{"task_id": 495, "completion": "def remove_lowercase(str1):\n    result = re.sub(r'[a-z]', '', str1)\n    return result"}
{"task_id": 496, "completion": "def heap_queue_smallest(nums, n):\n    \"\"\"\n    Function to find the smallest integers from a given list using heap queue algorithm\n    :param nums: List of numbers\n    :param n: The number of smallest elements to find\n    :return: List of n smallest numbers from nums list\n    \"\"\"\n    return heapq.nsmallest(n, nums)"}
{"task_id": 497, "completion": "def surfacearea_cone(r, h):\n    # The formula to calculate surface area of cone is: \u03c0r(r+sqrt(r^2 + h^2))\n    surface_area = math.pi * r * (r + math.sqrt((r ** 2) + (h ** 2)))\n    return surface_area"}
{"task_id": 498, "completion": "def gcd(x, y):\n    while(y):\n        x, y = y, x % y\n    return x"}
{"task_id": 499, "completion": "def diameter_circle(r):\n    diameter = 2 * r\n    return diameter"}
{"task_id": 500, "completion": "def concatenate_elements(input_list):\n    return ''.join(str(i) for i in input_list)"}
{"task_id": 501, "completion": "def ngcd(x, y):\n    return math.gcd(x, y)"}
{"task_id": 502, "completion": "def find(n, m):\n    try:\n        return n % m\n    except ZeroDivisionError:\n        return \"Error: Division by zero is not possible!\""}
{"task_id": 503, "completion": "def add_consecutive_nums(nums):\n    new_list = []\n    for i in range(len(nums)-1):\n        new_list.append(nums[i] + nums[i+1])\n    return new_list"}
{"task_id": 504, "completion": "def sum_Of_Series(n): \n    sum = 0\n    if n <= 0:\n        return \"Please enter a positive integer\"\n    else:\n        for i in range(1, n + 1): \n            sum += i * i * i\n        return sum"}
{"task_id": 505, "completion": "def re_order(A):\n    A.sort(key = lambda x: x == 0)\n    return A"}
{"task_id": 506, "completion": "# Permutation coefficient function\ndef permutation_coefficient(n, k):\n    return factorial(n) / factorial(n - k)"}
{"task_id": 507, "completion": "def remove_words(list1, removewords):\n    # Get a list without the words to be removed\n    new_list = [word for word in list1 if word not in removewords]\n    return new_list"}
{"task_id": 508, "completion": "def same_order(l1, l2):\n    # Firstly, find the common elements between the two lists\n    common_elements = [el for el in l1 if el in l2]\n\n    # Then, check the indexes of these common elements in both lists and\n    #     if they're not in the same positions return False\n    for i, el in enumerate(common_elements):\n        if l1.index(el) != l2.index(el):\n            return False\n\n    # If we haven't returned False, common elements are in the same positions in both lists\n    return True"}
{"task_id": 509, "completion": "def average_odd(n):\n    \n    # This function does not work for even numbers\n    if n % 2 == 0:\n        return \"Input is not odd\"\n\n    # Initialize sum and counter\n    sum = 0\n    count = 0\n\n    # Add all odd numbers till n\n    for i in range(1, n + 1, 2):\n        sum += i\n        count += 1\n\n    # Return their average\n    return sum / count\n`"}
{"task_id": 510, "completion": "def no_of_subsequences(arr, k):\n    n = len(arr)\n\n    dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = dp[i - 1][j]\n\n            if arr[i - 1] <= j and arr[i - 1] > 0:\n                dp[i][j] += dp[i - 1][j // arr[i - 1]] + 1\n\n    return dp[n][k]"}
