{"task_id": 11, "completion": "def remove_Occ(s, ch):\n    # First, find the positions of the first and last occurrence of ch\n    first_occurrence = s.find(ch)\n    last_occurrence = s.rfind(ch)\n    \n    # If the character is not found, return the string as is\n    if first_occurrence == -1:\n        return s\n    \n    # If the character to be removed is found only once, remove it\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence+1:]\n    \n    # Removing the first occurrence by slicing the string\n    result = s[:first_occurrence] + s[first_occurrence+1:]\n    \n    # Adjust the last_occurrence index since we've already removed one character\n    last_occurrence_adjusted = last_occurrence - 1\n    \n    # Removing the last occurrence (after adjustment) by slicing the result\n    final_result = result[:last_occurrence_adjusted] + result[last_occurrence_adjusted+1:]\n    \n    return final_result"}
{"task_id": 12, "completion": "def sort_matrix(M):\n    # Calculate the sum of each row and pair it with the row index\n    row_sums = [(sum(row), idx) for idx, row in enumerate(M)]\n    \n    # Sort the row sums\n    sorted_row_sums = sorted(row_sums, key=lambda x: x[0])\n    \n    # Reconstruct the sorted matrix using the sorted indices\n    sorted_matrix = [M[idx] for _, idx in sorted_row_sums]\n    \n    return sorted_matrix"}
{"task_id": 13, "completion": "def count_common(words):\n    from collections import Counter\n    \n    # Create a Counter object to count word occurrences\n    word_counts = Counter(words)\n    \n    # Find the maximum frequency/count\n    max_count = max(word_counts.values()) if word_counts else 0\n    \n    # Find all words that have the maximum count\n    most_common_words = [word for word, count in word_counts.items() if count == max_count]\n    \n    # Return the most common words and their count\n    return most_common_words, max_count"}
{"task_id": 14, "completion": "def find_Volume(base, height, length):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    base (float): The base length of the triangular base.\n    height (float): The height of the triangular base.\n    length (float): The height (length) of the prism, i.e., the distance between the triangular bases.\n\n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    # Calculate the area of the triangular base\n    area_of_triangle = 0.5 * base * height\n\n    # Multiply by the length of the prism to find the volume\n    volume = area_of_triangle * length\n\n    return volume"}
{"task_id": 15, "completion": "import re\n\ndef split_lowerstring(text):\n    # Regular expression to find lowercase letters and insert a splitting token before each\n    split_text = re.sub(r'([a-z])', r' \\1', text).split()\n    return split_text"}
{"task_id": 16, "completion": "def text_lowercase_underscore(text):\n    \"\"\"\n    Find sequences of lowercase letters joined with an underscore.\n\n    Args:\n    - text (str): The text where to look for the sequences.\n\n    Returns:\n    - list: A list containing all found sequences matching the pattern.\n    \"\"\"\n    pattern = r'[a-z]+_[a-z]+'\n    \n    matches = re.findall(pattern, text)\n    \n    return matches"}
{"task_id": 17, "completion": "def square_perimeter(a):\n    # The perimeter of a square is 4 times one of its sides\n    return 4 * a"}
{"task_id": 18, "completion": "def remove_chars_from_first_string(first_string, second_string):\n    \"\"\"\n    Remove characters from the first string which are present in the second string.\n\n    :param first_string: String to remove characters from.\n    :param second_string: String containing characters to remove from the first string.\n    :return: A new string made from the first string with characters removed that are present in the second string.\n    \"\"\"\n    result = \"\"\n    for char in first_string:\n        if char not in second_string:\n            result += char\n    return result"}
{"task_id": 19, "completion": "def test_duplicate(arraynums):\n    # If there're duplicates, set conversion would remove them reducing the size\n    if len(arraynums) != len(set(arraynums)):\n        return True  # Duplicates exist\n    else:\n        return False  # No duplicates"}
{"task_id": 20, "completion": "def is_woodall(x):\n    n = 1\n    while True:\n        woodall_n = n * (2 ** n) - 1\n        if woodall_n == x:\n            return True\n        elif woodall_n > x:\n            return False\n        n += 1\n`"}
{"task_id": 21, "completion": "def multiples_of_num(m, n):\n    # Initialize an empty list to store the multiples\n    multiples = []\n    \n    # Loop `m` times to generate multiples\n    for i in range(1, m + 1):\n        # Add the current multiple of `n` to the list\n        multiples.append(i * n)\n    \n    # Return the list of multiples\n    return multiples"}
{"task_id": 22, "completion": "def find_first_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return -1  # Indicate no duplicates were found"}
{"task_id": 23, "completion": "def maximum_Sum(list_of_lists):\n    # Use list comprehension to find the sum of each sublist and max() to find the maximum sum\n    return max([sum(sublist) for sublist in list_of_lists])"}
{"task_id": 24, "completion": "def binary_to_decimal(binary):\n    \"\"\"Convert a binary number (as a string) to its decimal equivalent.\"\"\"\n    # Initialize decimal number to 0\n    decimal = 0\n\n    # Iterate through each character in the binary string\n    for digit in binary:\n        # Multiply current decimal number by 2 and add the value of the current binary digit\n        decimal = decimal * 2 + int(digit)\n\n    return decimal"}
{"task_id": 25, "completion": "def find_Product(arr, n):\n    element_count = {}\n    \n    for element in arr:\n        if element in element_count:\n            element_count[element] += 1\n        else:\n            element_count[element] = 1\n            \n    product = 1\n    \n    found_non_repeated = False\n    \n    for element, count in element_count.items():\n        if count == 1:\n            product *= element\n            found_non_repeated = True\n    \n    if not found_non_repeated:\n        return \"No non-repeated elements found\"\n    \n    return product"}
{"task_id": 26, "completion": "def check_k_elements(test_list, K):\n    # Iterate through each tuple in the list\n    for tuple_item in test_list:\n        # Check the length of each tuple\n        if len(tuple_item) != K:\n            # If any tuple doesn't have K elements, return False\n            return False\n    # If all tuples have K elements, return True\n    return True"}
{"task_id": 27, "completion": "def remove_digits_from_strings(string_list):\n    return [''.join(char for char in string if char.isalpha()) for string in string_list]"}
{"task_id": 28, "completion": "def binomial_coeff(n, k):\n    \"\"\"Function to calculate the Binomial Coefficient.\"\"\"\n    return factorial(n) // (factorial(k) * factorial(n - k))"}
{"task_id": 29, "completion": "def get_Odd_Occurrence(arr, arr_size):\n    # Initialize result\n    result = 0\n    \n    # XOR each element in the array with the result\n    for i in range(arr_size):\n        result = result ^ arr[i]\n    \n    # The result will now be the element that occurs an odd number of times\n    return result"}
{"task_id": 30, "completion": "def check_Equality(s):\n\n    # Initialize a counter to keep track of substrings \n    # starting and ending with the same character\n    count = 0\n\n    # Determine the length of the input string\n    length = len(s)\n\n    # Iterate through the string to find all possible \n    # substrings that start and end with the same character\n    for i in range(length):\n        for j in range(i, length):\n            if s[i] == s[j]:\n                # If a substring starts and ends with the same character,\n                # increment the counter\n                count += 1\n\n    return count\n`"}
{"task_id": 31, "completion": "def find_top_k_occurrences(nums_lists, k):\n    \"\"\"Find the top k frequently occurring integers.\"\"\"\n    # Merge the lists and count occurrences\n    occurrences = merge_lists(nums_lists)\n    \n    # Use a heap to find the top k occurrences. Negate the count for max heap.\n    max_heap = [(-count, num) for num, count in occurrences.items()]\n    heapq.heapify(max_heap)\n    \n    # Extract the top k\n    top_k = [heapq.heappop(max_heap)[1] for _ in range(min(k, len(max_heap)))]\n    \n    return top_k"}
{"task_id": 32, "completion": "def max_Prime_Factors(n):\n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        maxPrime = 2\n        n /= 2\n\n    # Divide n by all odd factors starting from 3\n    # While doing this, the maximum odd factor will be kept in maxPrime\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            maxPrime = i\n            n = n / i\n\n    # If the remaining number is a prime number greater than 2,\n    # it's the largest prime factor.\n    if n > 2:\n        maxPrime = n\n\n    return int(maxPrime)"}
{"task_id": 33, "completion": "def decimal_To_Binary(N):\n    \"\"\"\n    Convert a decimal number to binary.\n    \n    Parameters:\n    N (int): The decimal number to convert.\n    \n    Returns:\n    str: The binary representation of N.\n    \"\"\"\n    # Base case: If N is 0 or 1, return it as string directly\n    if N == 0:\n        return \"0\"\n    if N == 1:\n        return \"1\"\n    \n    # Recursive case: Divide the number by 2 and store the remainder\n    binary_representation = decimal_To_Binary(N // 2) + str(N % 2)\n    \n    return binary_representation\n`"}
{"task_id": 34, "completion": "def find_missing(ar, N):\n    # Initialize start and end indexes\n    start, end = 0, N - 1\n    \n    # Perform binary search\n    while (start <= end):\n        mid = (start + end) // 2\n        \n        # If the missing number is in the left half\n        if (ar[mid] != mid + 1) and (mid == 0 or ar[mid-1] == mid):\n            return mid + 1\n        \n        # If the difference at mid is not as expected,\n        # we know the missing number is in the left half\n        if ar[mid] != mid + 1:\n            end = mid - 1\n        # Otherwise, it's in the right half\n        else:\n            start = mid + 1\n            \n    # In case the missing number is the last one\n    return N + 1\n`"}
{"task_id": 35, "completion": "def find_rect_num(n):\n    # The formula for the n-th rectangular number is n * (n + 1)\n    return n * (n + 1)"}
{"task_id": 36, "completion": "def find_Nth_Digit(p, q, N):\n    # Ensure q is not zero to avoid division by zero error\n    if q == 0:\n        return \"Error: Division by zero is not allowed.\"\n    \n    # Ensure N is positive\n    if N <= 0:\n        return \"Error: N must be a positive integer.\"\n    \n    # Convert the fraction to a decimal string\n    fraction = p / q\n    \n    # Convert to string to find the nth digit after the decimal point\n    fraction_str = str(fraction)\n\n    # Find the location of the decimal point\n    decimal_index = fraction_str.find('.')\n\n    # Check if N is within the length of the number after the decimal point\n    if N + decimal_index >= len(fraction_str):\n        return 0  # Return 0 if N is beyond the available digits\n    else:\n        # Return the Nth digit\n        return int(fraction_str[decimal_index + N])\n`"}
{"task_id": 37, "completion": "def sort_mixed_list(mixed_list):\n    int_list = [item for item in mixed_list if isinstance(item, int)]\n    str_list = [item for item in mixed_list if isinstance(item, str)]\n    \n    sorted_int_list = sorted(int_list)\n    sorted_str_list = sorted(str_list)\n    \n    return sorted_int_list + sorted_str_list"}
{"task_id": 38, "completion": "def div_even_odd(list1):\n    # Initialize variables to None\n    first_even = None\n    first_odd = None\n    \n    # Loop through the list\n    for num in list1:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        elif first_odd is None and num % 2 != 0:\n            first_odd = num\n        \n        # Check if both first_even and first_odd have been found\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # Check if we successfully found an even and an odd number\n    if first_even is not None and first_odd is not None:\n        # Perform division if both numbers are found\n        return first_even / first_odd\n    else:\n        # Return a message if we didn't find both numbers\n        return \"Couldn't find both an even and an odd number in the list.\""}
{"task_id": 39, "completion": "def rearrange_string(S):\n    # Count the occurrences of each character\n    char_count = Counter(S)\n    # Use a max heap to store the characters by their counts\n    max_heap = [(-count, char) for char, count in char_count.items()]\n    heapq.heapify(max_heap)\n    \n    prev_char = None\n    prev_count = 0\n    \n    while max_heap:\n        count, char = heapq.heappop(max_heap)\n        # If there's a character from a previous iteration, add it back\n        # (unless its count has reduced to 0)\n        if prev_char and prev_count < 0:\n            heapq.heappush(max_heap, (prev_count, prev_char))\n        \n        # Prepare the current character for the next iteration\n        prev_char = char\n        prev_count = count + 1  # Increase count because it's stored as negative\n        \n        if not max_heap and prev_count != 0:  # If this was the last character and it wasn't used up\n            return False  # It's not possible to rearrange S\n    \n    return True"}
{"task_id": 40, "completion": "def freq_element(nums):\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in nums for item in sublist]\n    # Use Counter to count occurrences of each element\n    frequency = Counter(flat_list)\n    return frequency"}
{"task_id": 41, "completion": "def filter_evennumbers(nums):\n    # Using filter function and a lambda to filter even numbers\n    even_nums = list(filter(lambda x: x % 2 == 0, nums))\n    return even_nums"}
{"task_id": 42, "completion": "def find_Sum(arr):\n    # Count the occurrences of each element in the array.\n    element_count = Counter(arr)\n    \n    # Initialize the sum of repeated elements.\n    sum_repeated = 0\n    \n    # Iterate through the element count dictionary.\n    for element, count in element_count.items():\n        # Check if the element is repeated (count > 1).\n        if count > 1:\n            # Add the element multiplied by its count to the sum.\n            sum_repeated += element * count\n    \n    # Return the sum of repeated elements.\n    return sum_repeated\n`"}
{"task_id": 43, "completion": "import re\n\ndef text_match(text):\n    # Define the regex pattern\n    pattern = r'\\b[a-z]+(?:_[a-z]+)+\\b'\n    \n    # Use findall() to find all occurrences that match the pattern\n    matches = re.findall(pattern, text)\n    \n    return matches"}
{"task_id": 44, "completion": "import re\n\ndef text_match_string(text, word):\n    \"\"\"\n    Matches a word at the beginning of a string.\n\n    Parameters:\n    text (str): The text to search in.\n    word (str): The word to match at the beginning of the text.\n\n    Returns:\n    bool: True if the word matches at the beginning of the text, False otherwise.\n    \"\"\"\n    # Create the regex pattern for matching the word at the beginning\n    # The '^' is used to match the start of the string\n    # \\b is used to ensure the match is at a word boundary\n    pattern = r'^\\b' + re.escape(word) + r'\\b'\n    \n    # Use re.match() to check if the pattern matches at the beginning of the text\n    if re.match(pattern, text):\n        return True\n    else:\n        return False"}
{"task_id": 45, "completion": "def find_gcd(arr):\n    \"\"\"\n    Find the GCD of an array of numbers.\n    \n    Parameters:\n    arr : List[int]\n        The array of numbers to find the GCD of.\n        \n    Returns:\n    int\n        The GCD of the array elements.\n    \"\"\"\n    array_gcd = arr[0]\n    for num in arr[1:]:\n        array_gcd = gcd(array_gcd, num)\n        \n        # If at any point the GCD is 1, we can stop (all integers are divisible by 1).\n        if array_gcd == 1:\n            return 1\n    return array_gcd"}
{"task_id": 46, "completion": "def test_distinct(data):\n    if len(data) == len(set(data)):\n        return True  # All elements are distinct\n    else:\n        return False  # There are duplicates"}
{"task_id": 47, "completion": "def compute_Last_Digit(A, B):\n    # Edge case handling\n    if A > B:\n        return \"Invalid input, A must be less than or equal to B\"\n    # If A equals B, then B! / A! is 1\n    if A == B:\n        return 1\n\n    last_digit = 1\n    for i in range(A + 1, B + 1):\n        # Calculate product considering only the last digit to avoid overflow\n        last_digit *= i\n        last_digit %= 10  # Keep only the last digit\n\n        # Early termination: if last digit becomes 0, no need to proceed further\n        if last_digit == 0:\n            break\n\n    return last_digit"}
{"task_id": 48, "completion": "def odd_bit_set_number(n):\n    # Determine the number of bits required to represent 'n' in binary.\n    num_bits = n.bit_length()\n    \n    # Create a bitmask where all odd-bit positions have a '1'. Note that we start from 0, \n    # so even positions in the loop correspond to odd bit positions in a 1-indexed system.\n    bitmask = sum(1 << i for i in range(num_bits) if i % 2 == 1)\n    \n    # Apply the bitmask to the input number 'n' with bitwise OR to set all odd bits.\n    result = n | bitmask\n    \n    return result"}
{"task_id": 49, "completion": "def specified_element(nums, N=0):\n    \"\"\"\n    Extracts the first or specified element from each inner list of a given two-dimensional list.\n    \n    Parameters:\n    nums (list of lists): A two-dimensional list from which elements are to be extracted.\n    N (int, optional): The index of the element to extract from each inner list. Defaults to 0 for the first element.\n    \n    Returns:\n    list: A list containing the extracted elements.\n    \"\"\"\n    extracted_elements = []\n    \n    # Iterate over each list in the two-dimensional list\n    for inner_list in nums:\n        # Check if the inner list is long enough and the Nth element exists\n        if len(inner_list) > N:\n            extracted_elements.append(inner_list[N])\n        else:\n            # You could choose to do something else if the element doesn't exist.\n            # For now, we'll append None to indicate the missing value.\n            extracted_elements.append(None)\n    \n    return extracted_elements"}
{"task_id": 50, "completion": "def min_length_list(input_list):\n    return min(input_list, key=lambda x: len(x))"}
{"task_id": 51, "completion": "def check_equilateral(x, y, z):\n    # Check if all sides are equal\n    if x == y == z:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")"}
{"task_id": 52, "completion": "def parallelogram_area(b, h):\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    - b: the length of the base of the parallelogram.\n    - h: the height of the parallelogram.\n\n    Returns:\n    The area of the parallelogram.\n    \"\"\"\n    return b * h"}
{"task_id": 53, "completion": "def check_Equality(str):\n    # Check if the string is empty or not\n    if not str:\n        return False  # An empty string has no characters to compare\n    \n    # Compare the first and the last character\n    return str[0] == str[-1]"}
{"task_id": 54, "completion": "def counting_sort(arr):\n    if not arr:\n        return []\n\n    # Find the maximum element in arr\n    max_elem = max(arr)\n\n    # Initialize count array with all zeros\n    count = [0] * (max_elem + 1)\n    \n    # Store the count of each element in count array\n    for num in arr:\n        count[num] += 1\n\n    # Update count array to store the cumulative count of elements\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n\n    # Build the output array\n    output = [0] * len(arr)\n    i = len(arr) - 1\n    while i >= 0:\n        cur_elem = arr[i]\n        count[cur_elem] -= 1\n        new_position = count[cur_elem]\n        output[new_position] = cur_elem\n        i -= 1\n\n    # Copy the sorted elements into original array\n    for i in range(len(arr)):\n        arr[i] = output[i]\n\n    return arr\n"}
{"task_id": 55, "completion": "def tn_gp(a, n, r):\n    return a * (r ** (n - 1))\n`"}
{"task_id": 56, "completion": "def rev(num):\n    # Convert the number to a string to easily reverse it\n    num_str = str(num)\n    # Reverse the string and convert it back to an integer\n    reversed_num = int(num_str[::-1])\n    # Check if the original number is one less than twice the reversed number\n    return num == (2 * reversed_num) - 1"}
{"task_id": 57, "completion": "def find_Max_Num(arr):\n    # Convert each number to a string\n    str_arr = map(str, arr)\n  \n    # Sort the string numbers in descending order\n    sorted_arr = sorted(str_arr, reverse=True, key=lambda x: x*10)\n  \n    # Concatenate them together\n    largest_num = ''.join(sorted_arr)\n  \n    # Optional: Convert it back to an integer\n    largest_num_int = int(largest_num)\n  \n    return largest_num_int\n`"}
{"task_id": 58, "completion": "def opposite_signs(x, y):\n    # Use bitwise XOR and check if the result is negative\n    return (x ^ y) < 0"}
{"task_id": 59, "completion": "def is_octagonal(n):\n    \"\"\"\n    Calculate the nth octagonal number.\n\n    Parameters:\n    n (int): The position in the sequence of octagonal numbers.\n\n    Returns:\n    int: The nth octagonal number.\n    \"\"\"\n    # Using the formula for calculating the nth octagonal number\n    return n * (3 * n - 2)"}
{"task_id": 60, "completion": "def max_len_sub(arr):\n    # Sort the array\n    arr.sort()\n    # Initialize variables\n    max_len = 1\n    current_len = 1\n\n    for i in range(1, len(arr)):\n        # If the difference between the current and previous element is at most 1\n        if arr[i] - arr[i-1] <= 1:\n            # Increase the length of the current subsequence\n            current_len += 1\n        else:\n            # If the current subsequence ends, update max_len if needed\n            max_len = max(max_len, current_len)\n            current_len = 1 # Reset the length for the next subsequence\n    \n    # Handle the case of reaching the end of the array\n    max_len = max(max_len, current_len)\n\n    return max_len"}
{"task_id": 61, "completion": "def count_substrings(s):\n    # Initialize count to keep track of substrings that meet the condition\n    count = 0\n    \n    # Length of the string\n    n = len(s)\n    \n    # Generate all possible substrings using nested loops\n    for i in range(n):\n        for j in range(i+1, n+1):\n            # Extract the substring\n            substring = s[i:j]\n            \n            # Calculate the sum of the digits within the substring\n            sum_of_digits = sum(int(char) for char in substring if char.isdigit())\n            \n            # Check if the sum of the digits equals the length of the substring\n            if sum_of_digits == len(substring):\n                count += 1\n                \n    return count\n`"}
{"task_id": 62, "completion": "def smallest_num(xs):\n    # Check if the list is empty\n    if len(xs) == 0:\n        return None # or raise an exception if preferable\n    \n    # Initialize the smallest number as the first number in the list\n    smallest = xs[0]\n    \n    # Loop through all numbers in the list\n    for num in xs[1:]:\n        # If the current number is smaller than the current smallest, update smallest\n        if num < smallest:\n            smallest = num\n            \n    # Return the smallest number found\n    return smallest"}
{"task_id": 63, "completion": "def max_difference(test_list):\n    # First, we initialize a variable `max_diff` with a very small value.\n    max_diff = float('-inf')\n    \n    # We iterate through each tuple in the given list.\n    for pair in test_list:\n        # For each pair, we calculate the difference between its two elements.\n        diff = abs(pair[1] - pair[0])\n        \n        # If this difference is greater than the current `max_diff`, we update `max_diff`.\n        if diff > max_diff:\n            max_diff = diff\n            \n    # After checking all pairs, we return the maximum difference found.\n    return max_diff"}
{"task_id": 64, "completion": "def subject_marks(subject_marks_list):\n    # Sorting the list of tuples based on the second item (marks) in each tuple\n    sorted_list = sorted(subject_marks_list, key=lambda x: x[1])\n    return sorted_list"}
{"task_id": 65, "completion": "def recursive_list_sum(data_list):\n    # Base case: if the list is empty, return 0\n    if not data_list:\n        return 0\n    else:\n        # If the first element is a list, recursively call recursive_list_sum on it\n        if isinstance(data_list[0], list):\n            head_sum = recursive_list_sum(data_list[0])\n        else:\n            # Otherwise, the first element itself is the head_sum\n            head_sum = data_list[0]\n        # Recursively call recursive_list_sum on the rest of the list and add it to the head_sum\n        return head_sum + recursive_list_sum(data_list[1:])"}
{"task_id": 66, "completion": "def pos_count(num_list):\n    # Initialize a counter for positive numbers\n    count = 0\n    # Loop through each number in the list\n    for num in num_list:\n        # Check if the number is positive\n        if num > 0:\n            # Increment the counter\n            count += 1\n    # Return the final count of positive numbers\n    return count"}
{"task_id": 67, "completion": "def bell_number(n):\n    \"\"\"\n    Calculate the n-th Bell number.\n\n    :param n: Non-negative integer to calculate the Bell number of\n    :return: n-th Bell number\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    \n    # Base case\n    if n == 0:\n        return 1\n\n    # Initialize the Bell numbers list with the first Bell number\n    bell = [1]\n    \n    # Use the previous values to calculate the next Bell number\n    for i in range(1, n + 1):\n        # Calculate i-th Bell number using the recurrence relation\n        # B_i = sum of B_(i-1, j) from j=0 to i-1\n        bell.append(sum(bell[j] * bell[i - 1 - j] for j in range(i)))\n    \n    # Return the n-th Bell number\n    return bell[-1]"}
{"task_id": 68, "completion": "def is_Monotonic(A):\n    # First, we check if the list is non-decreasing by comparing each element\n    # to its successor. If this holds true, we return True.\n    increasing = all(A[i] <= A[i + 1] for i in range(len(A) - 1))\n    \n    # Second, we check if the list is non-increasing by the same method.\n    # If any of these cases is True, the array is monotonic.\n    decreasing = all(A[i] >= A[i + 1] for i in range(len(A) - 1))\n    \n    return increasing or decreasing"}
{"task_id": 69, "completion": "def is_sublist(l, s):\n    # Check if the length of sublist is 0 - always true if it is\n    if len(s) == 0:\n        return True\n    # Check if the sublist is longer than the list - always false if it is\n    if len(s) > len(l):\n        return False\n\n    # Loop through the main list to check for the sublist\n    for i in range(len(l) - len(s) + 1):\n        # Check if the next len(s) elements of l match s\n        if l[i:i+len(s)] == s:\n            return True\n    return False\n`"}
{"task_id": 70, "completion": "def find_equal_tuple(Input, k):\n    # Iterate through each tuple in the input list\n    for current_tuple in Input:\n        # Check if the current tuple doesn't have the length as k\n        if len(current_tuple) != k:\n            # If the condition is true, return False\n            return False\n    # If all tuples match the length k, return True\n    return True"}
{"task_id": 71, "completion": "def comb_sort(nums):\n    # Initialize the gap size to the list length\n    gap = len(nums)\n    # Initialize the swapped variable to True to start the loop\n    swapped = True\n\n    while gap != 1 or swapped:\n        # Update the gap size using the shrink factor (commonly 1.3)\n        gap = max(1, int(gap // 1.3))\n        swapped = False \n\n        # Compare and swap elements if they're in the wrong order\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                swapped = True\n\n    return nums\n"}
{"task_id": 72, "completion": "def dif_square(n):\n    # If n is even, it can always be represented\n    if n % 2 == 0:\n        return True\n    else:\n        # Check if n is product of two odd numbers\n        for i in range(3, int(n**0.5)+1, 2):\n            if n % i == 0:\n                return True\n        return False"}
{"task_id": 73, "completion": "import re\n\ndef multiple_split(text, delimiters):\n    \"\"\"\n    Split the given text using the specified delimiters.\n\n    Parameters:\n    - text (str): The string to split.\n    - delimiters (list of str or str): A list of delimiter characters as strings or a single string with delimiter characters.\n    \n    Returns:\n    - list: A list of the parts of the text, split at each point where any of the specified delimiters occur.\n    \"\"\"\n    # If delimiters is a single string, convert it to a list of its characters\n    if isinstance(delimiters, str):\n        delimiters = list(delimiters)\n    \n    # Create the regex pattern to match any of the specified delimiters\n    # The pattern will look something like \"[delim1|delim2|delim3|...]\"\n    regex_pattern = '[' + '|'.join(map(re.escape, delimiters)) + ']'\n    \n    # Use re.split() to split the text using the regex pattern\n    result = re.split(regex_pattern, text)\n    \n    return result\n`"}
{"task_id": 74, "completion": "def is_samepatterns(colors, patterns):\n    if len(colors) != len(patterns):\n        return False  # Early exit if lengths do not match\n\n    color_to_pattern = {}  # Maps colors to pattern identifiers\n    pattern_to_color = {}  # Maps pattern identifiers to colors\n\n    for color, pattern in zip(colors, patterns):\n        # Check if we have already seen this color or pattern\n        if color in color_to_pattern:\n            # Check if the current pattern matches the pattern we have for this color\n            if color_to_pattern[color] != pattern:\n                return False\n        elif pattern in pattern_to_color:\n            # Check if the current color matches the color we have for this pattern\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            # If we haven't seen this color or pattern, map them to each other\n            color_to_pattern[color] = pattern\n            pattern_to_color[pattern] = color\n\n    return True  # If all checks passed, the sequence matches\n`"}
{"task_id": 75, "completion": "def find_tuples(test_list, K):\n    # List to store the result\n    result = []\n    \n    # Iterate through each tuple in the given list\n    for tup in test_list:\n        # Use all() with a generator expression to check if all elements\n        # in the tuple are divisible by K. If so, append to result.\n        if all(element % K == 0 for element in tup):\n            result.append(tup)\n    \n    return result"}
{"task_id": 76, "completion": "def count_Squares(m, n):\n    # Initialize count to 0\n    count = 0\n    \n    # Loop to count squares of all sizes\n    for i in range(1, min(m, n) + 1):\n        # Adding the number of squares of size i\n        count += (m - i + 1) * (n - i + 1)\n    \n    return count"}
{"task_id": 77, "completion": "def is_Diff(n):\n    # Convert the number to a string to easily iterate over each digit\n    n_str = str(n)\n    \n    # Initialize sums for even and odd digits\n    sum_even = 0\n    sum_odd = 0\n    \n    # Iterate over each character in the string\n    for digit in n_str:\n        # Convert the character back to an integer\n        int_digit = int(digit)\n        \n        # Check if the digit is even or odd and add to the appropriate sum\n        if int_digit % 2 == 0:\n            sum_even += int_digit\n        else:\n            sum_odd += int_digit\n    \n    # Calculate the absolute difference between the sum of even and odd digits\n    difference = abs(sum_even - sum_odd)\n    \n    return difference"}
{"task_id": 78, "completion": "def count_With_Odd_SetBits(n):\n    # Initialize count to 0\n    count = 0\n\n    # Loop through all numbers from 1 to n\n    for i in range(1, n + 1):\n        # Count set bits for the current number\n        set_bits = bin(i).count('1')\n\n        # Check if the number of set bits is odd\n        if set_bits % 2 != 0:\n            count += 1\n\n    return count"}
{"task_id": 79, "completion": "def word_len(s):\n    # Check if the length of the word is odd\n    if len(s) % 2 == 1:\n        return True\n    else:\n        return False"}
{"task_id": 80, "completion": "def tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6"}
{"task_id": 81, "completion": "def zip_tuples(test_tup1, test_tup2):\n    # Using the zip function to pair elements from both tuples\n    zipped = zip(test_tup1, test_tup2)\n    \n    # Convert the zip object into a list of tuples and return\n    return list(zipped)"}
{"task_id": 82, "completion": "def volume_sphere(r):\n    # Calculate the volume using the formula\n    volume = (4/3) * math.pi * r**3\n    # Return the calculated volume\n    return volume"}
{"task_id": 83, "completion": "def get_Char(strr):\n    total = sum(ord(char) for char in strr)  # Sum of ASCII values of all characters\n    result_char = chr(total % 256)  # Modulo 256 to ensure it's within ASCII range\n    return result_char"}
{"task_id": 84, "completion": "def newman_conway(n):\n    # Base conditions\n    if n == 1 or n == 2:\n        return 1\n    \n    # Create an array to store the sequence values up to n\n    sequence = [0] * (n+1)\n    sequence[1], sequence[2] = 1, 1\n    \n    # Calculate each value from 3 to n\n    for i in range(3, n+1):\n        sequence[i] = sequence[sequence[i-1]] + sequence[i - sequence[i-1]]\n    \n    # Return the n-th element\n    return sequence[n]"}
{"task_id": 85, "completion": "import math\n\ndef surfacearea_sphere(r):\n    \"\"\"Calculates the surface area of a sphere given its radius.\n    \n    Parameters:\n    r (float): The radius of the sphere.\n\n    Returns:\n    float: The surface area of the sphere.\n    \"\"\"\n    # Calculate the surface area using the formula\n    surface_area = 4 * math.pi * r**2\n    return surface_area"}
{"task_id": 86, "completion": "def centered_hexagonal_number(n):\n    return 1 + 6 * (n * (n - 1)) // 2"}
{"task_id": 87, "completion": "def merge_dictionaries_three(dict1, dict2, dict3):\n    \"\"\"\n    Merges three dictionaries into a single dictionary.\n    \n    Parameters:\n    - dict1, dict2, dict3 (dict): Dictionaries to be merged.\n    \n    Returns:\n    - dict: A new dictionary containing the merged key-value pairs from all input dictionaries.\n    \"\"\"\n    merged_dict = {**dict1, **dict2, **dict3}\n    return merged_dict"}
{"task_id": 88, "completion": "def freq_count(list1):\n    # Creating an empty dictionary to hold element frequencies\n    freq = {}\n    # Looping through each element in the list\n    for item in list1:\n        # If the item is already in the dict, increment its count\n        if item in freq:\n            freq[item] += 1\n        # Else, add the item to the dict with count 1\n        else:\n            freq[item] = 1\n    # Return the frequency dictionary\n    return freq"}
{"task_id": 89, "completion": "def closest_num(N, num_list):\n    \"\"\"\n    Find the closest smaller number than N within num_list.\n\n    Parameters:\n    N (int): The number to compare against.\n    num_list (list): A list of numbers to search within.\n\n    Returns:\n    int: The closest number less than N. Returns None if no such number exists.\n    \"\"\"\n    # Filter the list to only include numbers less than N\n    smaller_nums = [num for num in num_list if num < N]\n    \n    # Check if there are any numbers smaller than N\n    if not smaller_nums:\n        return None\n    \n    # Return the maximum of the filtered list, which is the closest smaller number\n    return max(smaller_nums)"}
{"task_id": 90, "completion": "def len_log(list1):\n    # Check if the list is empty\n    if not list1:\n        return 0\n    \n    # Find the longest word by comparing lengths\n    longest = len(list1[0])\n    for word in list1[1:]:\n        if len(word) > longest:\n            longest = len(word)\n    return longest"}
{"task_id": 91, "completion": "def find_substring(str1, sub_str):\n    # Iterate through each string in the list\n    for string in str1:\n        # Check if the substring is present in the current string\n        if sub_str in string:\n            # If a match is found, return True\n            return True\n    # If the loop completes without finding a match, return False\n    return False"}
{"task_id": 92, "completion": "def is_undulating(n):\n    # Convert the number to a string to easily access individual digits\n    str_n = str(n)\n    n_len = len(str_n)\n    \n    # An undulating number must be at least 3 digits\n    if n_len < 3:\n        return False\n    \n    # First digit (a)\n    a = str_n[0]\n    # Second digit (b)\n    b = str_n[1]\n    \n    # a and b should not be the same\n    if a == b:\n        return False\n    \n    # Check the repeating pattern\n    for i in range(2, n_len):\n        # If i is even, the digit should match a\n        if i % 2 == 0 and str_n[i] != a:\n            return False\n        # If i is odd, the digit should match b\n        elif i % 2 != 0 and str_n[i] != b:\n            return False\n    \n    return True"}
{"task_id": 93, "completion": "def power(a, b):\n    result = 1\n    for _ in range(abs(b)):\n        if b > 0:\n            result *= a\n        else:\n            result /= a\n    return result"}
{"task_id": 94, "completion": "def index_minimum(test_list):\n    # Initialize the index and value of the minimum to the first element\n    min_index = 0\n    min_value = test_list[0][0]  # Assuming the tuple isn't empty\n\n    # Iterate through the list, starting from the second element\n    for i in range(1, len(test_list)):\n        # Compare the first element of the current tuple to the current minimum value\n        if test_list[i][0] < min_value:\n            min_value = test_list[i][0]\n            min_index = i\n\n    return min_index"}
{"task_id": 95, "completion": "def find_min_length(lst):\n    # Initialize minimum length to a large value\n    min_length = float('inf')  # Representing infinity since we don't know the lengths yet\n    \n    # Iterate over each item in the list\n    for item in lst:\n        # Check if the current item is a list\n        if isinstance(item, list):\n            # Update the minimum length if the current list is smaller\n            if len(item) < min_length:\n                min_length = len(item)\n    \n    # If no sublist was found (min_length is still infinity), return an indication such as None or -1\n    if min_length == float('inf'):\n        return None  # Or, you might want to return -1, or raise an Exception depending on your use case\n    \n    return min_length\n`"}
{"task_id": 96, "completion": "def divisor(n):\n    # Initialize count of divisors\n    count = 0\n    \n    # Iterate through numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If n is divisible by i, it means i is a divisor\n        if n % i == 0:\n            count += 1\n            \n    return count\n`"}
{"task_id": 97, "completion": "from collections import Counter\n\ndef frequency_lists(list_of_lists):\n    # Flatten the list of lists to a single list\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Calculate the frequency of each item\n    frequency = Counter(flat_list)\n    \n    # Return the frequency dictionary\n    return dict(frequency)"}
{"task_id": 98, "completion": "def multiply_num(numbers):\n    # Ensure the list is not empty\n    if len(numbers) == 0:\n        return 0\n\n    # Initialize the multiplication result with 1\n    result = 1\n\n    # Multiply all the numbers in the list\n    for num in numbers:\n        result *= num\n\n    # Divide the multiplication result by the length of the list\n    final_result = result / len(numbers)\n\n    return final_result"}
{"task_id": 99, "completion": "def decimal_to_binary(n):\n    # Base case: If the input is 0, return '0' as its binary representation\n    if n == 0:\n        return \"0\"\n    \n    binary_number = \"\"\n    \n    while n > 0:\n        # Determine the remainder when n is divided by 2 (either 0 or 1)\n        remainder = n % 2\n        # Prepend the remainder to the binary number string\n        binary_number = str(remainder) + binary_number\n        # Update n to be the quotient of n divided by 2 (integer division)\n        n = n // 2\n    \n    return binary_number"}
{"task_id": 100, "completion": "def next_smallest_palindrome(num):\n    \"\"\"Find the next smallest palindrome after the given number.\"\"\"\n    num += 1  # Start checking from the next number\n    while not is_palindrome(str(num)):\n        num += 1\n    return num"}
{"task_id": 101, "completion": "def kth_element(arr, n, k):\n    \"\"\"\n    Function to find the kth element in the given array.\n\n    Parameters:\n    arr (list): The list from which to find the kth element.\n    n (int): The number of elements in the array.\n    k (int): The kth position (1-based indexing) to find in the array.\n\n    Returns:\n    element: The kth element from the array.\n    \"\"\"\n\n    # Adjusting k for 0-based indexing if k is provided based on 1-based indexing\n    k_adjusted = k - 1\n\n    # Check if k_adjusted is within the range of the array\n    if k_adjusted >= 0 and k_adjusted < n:\n        return arr[k_adjusted]\n    else:\n        return \"k is out of bounds\"\n`"}
{"task_id": 102, "completion": "def snake_to_camel(word):\n    # Split the word by underscore and iterate over the parts\n    parts = word.split('_')\n    # For the first part, keep it as it is, and for the rest, capitalize the first letter.\n    camel_case = parts[0] + ''.join(part.capitalize() for part in parts[1:])\n    return camel_case"}
{"task_id": 103, "completion": "def eulerian_num(n, m):\n    if n == 0 and m == 0:\n        return 1\n    if m < 0 or m >= n:\n        return 0\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        dp[i][0] = 1\n        for j in range(1, min(i, m + 1)):\n            dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n\n    return dp[n][m]"}
{"task_id": 104, "completion": "def sort_sublists(input_list):\n    # Sort each sublist using a lambda function\n    sorted_list = [sorted(sublist, key=lambda x: x) for sublist in input_list]\n    return sorted_list"}
{"task_id": 105, "completion": "def count_trues(lst):\n    \"\"\"\n    Counts and returns the number of True booleans in the given list.\n\n    Parameters:\n    lst (list): The list to search through for True booleans.\n\n    Returns:\n    int: The count of True booleans in the list.\n    \"\"\"\n    \n    # Using a generator expression to iterate over the list,\n    # checking if each element is exactly True, and summing up the instances.\n    true_count = sum(1 for item in lst if item is True)\n    \n    return true_count\n`"}
{"task_id": 106, "completion": "def add_lists(test_list, test_tup):\n    # First, convert the tuple to a list\n    temp_list = list(test_tup)\n    \n    # Combine the list with the elements of the original list\n    combined_list = temp_list + test_list\n    \n    # Then, convert the combined list back to a tuple\n    result_tuple = tuple(combined_list)\n    \n    # Return the new tuple\n    return result_tuple"}
{"task_id": 107, "completion": "def count_hexadecimal(L, R):\n    # The count is simply the difference between R and L plus 1 (to include both L and R)\n    return R - L + 1"}
{"task_id": 108, "completion": "from heapq import merge\n\ndef merge_sorted_lists(*args):\n    \"\"\"\n    Merge multiple sorted inputs into a single sorted iterator.\n    \n    Parameters:\n    *args: An arbitrary number of sorted iterables.\n    \n    Yield:\n    Elements in sorted order from all the inputs.\n    \"\"\"\n    return merge(*args)"}
{"task_id": 109, "completion": "def odd_Equivalent(s, n):\n    # Function to check if a binary string is odd\n    def is_odd(binary_str):\n        # Convert binary string to integer and check if it's odd\n        return int(binary_str, 2) % 2 != 0\n\n    # Counter for odd rotations\n    odd_count = 0\n\n    # Loop for each rotation\n    for i in range(n):\n        if is_odd(s):\n            odd_count += 1\n        # Rotate the string: Move first character to the end\n        s = s[1:] + s[0]\n\n    return odd_count\n``"}
{"task_id": 110, "completion": "def extract_missing(test_list, strt_val, stop_val):\n    # First, ensure the list is sorted\n    test_list = sorted(test_list)\n    \n    # Initialize an empty list to hold the missing ranges\n    missing_ranges = []\n    \n    # Pointer for the starting index of missing ranges\n    current = strt_val\n    \n    # Check if the start value is greater than the first element in the list. If so, adjust current accordingly.\n    if test_list and current < test_list[0]:\n        missing_ranges.append((current, test_list[0]-1))\n        current = test_list[0]\n    \n    # Iterate through the list\n    for num in test_list:\n        if num < current:\n            # Skip numbers that are not within the current missing range\n            continue\n        elif num == current:\n            # Increment current since current number is not missing\n            current += 1\n        else:\n            # Found a missing range, add it to the list\n            missing_ranges.append((current, num-1))\n            current = num + 1\n            \n    # Check if there's a missing range between the last number and the stop value\n    if current <= stop_val:\n        missing_ranges.append((current, stop_val))\n    \n    return missing_ranges\n`"}
{"task_id": 111, "completion": "def common_in_nested_lists(nested_lists):\n    # Create a dictionary to keep track of element frequencies\n    frequency_dict = {}\n\n    # Iterate through each list in the nested list\n    for a_list in nested_lists:\n        # Use a set to avoid counting duplicates within the same list\n        unique_elements = set(a_list)\n        for element in unique_elements:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n\n    # The length of nested_lists is the total number of lists\n    total_lists = len(nested_lists)\n\n    # Collect elements that are common to all lists\n    common_elements = [element for element, count in frequency_dict.items() if count == total_lists]\n\n    return common_elements\n`"}
{"task_id": 112, "completion": "import math\n\ndef cylinder_circumference(diameter):\n    \"\"\"Calculate the circumference of the cylinder's base.\"\"\"\n    circumference = math.pi * diameter\n    return circumference"}
{"task_id": 113, "completion": "def check_integer(text):\n    \"\"\"\n    This function checks if the text passed to it represents an integer.\n    \n    Parameters:\n    text (str): The string to be checked\n    \n    Returns:\n    bool: True if the text represents an integer, False otherwise.\n    \"\"\"\n    # Attempt to convert the text to an integer. If it succeeds, return True.\n    try:\n        int(text)\n        return True\n    except ValueError:\n        return False\n`"}
{"task_id": 114, "completion": "def assign_freq(test_list):\n    # Counting the frequency of each tuple\n    freq_dict = {}\n    for item in test_list:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    \n    # Assigning frequency to each tuple\n    result_list = [(item, freq_dict[item]) for item in test_list]\n    return result_list\n`"}
{"task_id": 115, "completion": "def empty_dit(list1):\n    # Check every item in the list\n    for item in list1:\n        # If the item is a dictionary and it's not empty, return False\n        if isinstance(item, dict) and item:\n            return False\n    # If the loop finishes without returning False, then all dictionaries are empty (or there are no dictionaries)\n    return True"}
{"task_id": 116, "completion": "def tuple_to_int(nums):\n    # Convert each number in the tuple to a string and concatenate them\n    concatenated_string = ''.join(map(str, nums))\n    # Convert the concatenated string back into an integer\n    result_integer = int(concatenated_string)\n    return result_integer"}
{"task_id": 117, "completion": "def list_to_float(test_list):\n    \"\"\"\n    Converts all possible convertible elements in the list to float.\n    \n    Args:\n    test_list (list): A list containing elements that may or may not be converted to float.\n    \n    Returns:\n    list: A modified list with elements converted to float wherever possible.\n    \"\"\"\n    # Iterate through each element in the list by index\n    for i in range(len(test_list)):\n        # Attempt to convert each element to float\n        try:\n            test_list[i] = float(test_list[i])\n        except ValueError:\n            # If conversion fails (ValueError), leave the element unchanged\n            continue\n    return test_list\n"}
{"task_id": 118, "completion": "def string_to_list(string):\n    return list(string)"}
{"task_id": 119, "completion": "def findSingleElement(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        mid = left + (right - left) // 2\n        # Check if mid is even or odd\n        if mid % 2 == 0:\n            # If even, single element must be to the right, if pair is broken\n            if arr[mid] != arr[mid + 1]:\n                right = mid\n            else:\n                left = mid + 2\n        else:\n            # If odd, single element must be to the right, if pair is not broken \n            if arr[mid] == arr[mid + 1]:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n    # When left == right, we have found the single element\n    return arr[left]\n`"}
{"task_id": 120, "completion": "def max_product_tuple(list1):\n    if not list1 or len(list1) < 2:\n        return None\n\n    max_product = float('-inf')\n    max_pair = None\n\n    for i in range(len(list1)):\n        for j in range(i + 1, len(list1)):\n            tuple1 = list1[i]\n            tuple2 = list1[j]\n\n            product = 1\n            for k in tuple1:\n                product *= k\n            for l in tuple2:\n                product *= l\n\n            if product > max_product:\n                max_product = product\n                max_pair = (tuple1, tuple2)\n\n    return max_product, max_pair\n`"}
{"task_id": 121, "completion": "def find_triplets_with_sum(A, n, given_sum):\n    # Sort the array to handle duplicates easily\n    A.sort()\n    count = 0  # Initialize the count of triplets\n    triplets = []  # To store the triplets\n    for i in range(n - 2):  # First point\n        # To avoid counting duplicates for the first element\n        if i > 0 and A[i] == A[i - 1]:\n            continue\n        left = i + 1  # Second point\n        right = n - 1  # Third point\n        while left < right:\n            current_sum = A[i] + A[left] + A[right]\n            if current_sum == given_sum:\n                triplets.append((A[i], A[left], A[right]))\n                count += 1\n                # Move left and right to the next different numbers\n                while left < right and A[left] == A[left + 1]:\n                    left += 1\n                while left < right and A[right] == A[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n            elif current_sum < given_sum:\n                left += 1\n            else:\n                right -= 1\n    return triplets, count\n`"}
{"task_id": 122, "completion": "import math\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef smartNumber(n):\n    smart_nums = []\n    num = 2  # Starting from the first prime number\n    while len(smart_nums) < n:\n        if is_prime(num) or math.sqrt(num).is_integer():\n            smart_nums.append(num)\n        num += 1\n    return smart_nums[-1]"}
{"task_id": 123, "completion": "def sum_proper_divisors(n):\n    \"\"\"\n    Function to calculate the sum of proper divisors of an integer n.\n    Proper divisors are numbers less than n which divide evenly into n.\n    \"\"\"\n    divisors = [1]  # 1 is a proper divisor of every integer\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:  # Avoid adding the square root twice for perfect squares\n                divisors.append(n//i)\n    return sum(divisors)\n\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Function to sum all amicable numbers from 1 up to a specified number (limit).\n    \"\"\"\n    amicable_sum = 0\n    # To avoid double counting, keep track of amicable numbers found\n    found_amicables = set()\n    \n    for number in range(2, limit):\n        if number in found_amicables:\n            # Skip if we've already identified this number as part of an amicable pair\n            continue\n            \n        # Find the sum of divisors\n        sum_divisors = sum_proper_divisors(number)\n        \n        # Check if amicable condition is met except for trivial case (number shouldn't be equal to its sum of divisors)\n        if sum_divisors != number and sum_proper_divisors(sum_divisors) == number:\n            # Update the accumulated sum of amicable numbers\n            amicable_sum += (number + sum_divisors)\n            # Add both numbers to the set to avoid double counting\n            found_amicables.update([number, sum_divisors])\n            \n    return amicable_sum\n`"}
{"task_id": 124, "completion": "import cmath\n\ndef angle_complex(a, b):\n    \"\"\"Calculate the angle of a complex number formed by a + bi.\n    \n    Parameters:\n    a (float): The real part of the complex number.\n    b (float): The imaginary part of the complex number.\n    \n    Returns:\n    float: The angle of the complex number in radians.\n    \"\"\"\n    complex_number = complex(a, b)\n    angle = cmath.phase(complex_number)\n    \n    return angle"}
{"task_id": 125, "completion": "def find_length(string, n):\n    # Convert the string into a list of +1 and -1\n    # +1 for '0' and -1 for '1'\n    arr = [1 if ch == '0' else -1 for ch in string]\n\n    # Initialize variables to store the maximum difference and the current difference\n    max_diff = 0\n    cur_diff = 0\n\n    # Loop through the array to find the maximum sum subarray\n    for i in range(n):\n        # Update the current difference\n        cur_diff += arr[i]\n\n        # If the current difference becomes negative, reset it to 0\n        if cur_diff < 0:\n            cur_diff = 0\n\n        # Update the maximum difference\n        max_diff = max(max_diff, cur_diff)\n\n    # Return the maximum difference\n    # This maximum difference actually represents the maximum difference\n    # between the number of 0s and the number of 1s in any substring.\n    return max_diff\n`"}
{"task_id": 126, "completion": "def sum_of_common_divisors(a, b):\n    \"\"\"\n    Function to find the sum of common divisors of two given numbers a and b.\n    \"\"\"\n    common_divisors_sum = 0\n    gcd_value = gcd(a, b)\n\n    # Find all divisors of gcd_value\n    for i in range(1, gcd_value + 1):\n        if gcd_value % i == 0:\n            common_divisors_sum += i\n\n    return common_divisors_sum"}
{"task_id": 127, "completion": "def multiply_int(x, y):\n    # Handle negative numbers\n    is_negative = (x < 0) ^ (y < 0)\n    x, y = abs(x), abs(y)\n    \n    # Swap if necessary to ensure x is the smaller number \n    # This is to minimize the number of loop iterations\n    if x > y:\n        x, y = y, x\n    \n    result = 0\n    for _ in range(x):\n        result += y\n    \n    # Adjust sign if one of the numbers was negative\n    if is_negative:\n        result = -result\n    \n    return result"}
{"task_id": 128, "completion": "def long_words(n, str):\n    # Split the input string into a list of words\n    words = str.split()\n    \n    # Filter and return the words that are longer than n characters\n    return [word for word in words if len(word) > n]"}
{"task_id": 129, "completion": "def magic_square_test(my_matrix):\n    # Calculate the sum of the first row to use as a comparison\n    target_sum = sum(my_matrix[0])\n    \n    # Check sums of rows\n    for row in my_matrix:\n        if sum(row) != target_sum:\n            return False  # Not a magic square\n    \n    # Check sums of columns\n    for col in range(len(my_matrix)):\n        if sum(row[col] for row in my_matrix) != target_sum:\n            return False  # Not a magic square\n    \n    # Check diagonal (top-left to bottom-right)\n    if sum(my_matrix[i][i] for i in range(len(my_matrix))) != target_sum:\n        return False  # Not a magic square\n    \n    # Check anti-diagonal (top-right to bottom-left)\n    if sum(my_matrix[i][len(my_matrix)-1-i] for i in range(len(my_matrix))) != target_sum:\n        return False  # Not a magic square\n    \n    return True  # Passed all checks, it is a magic square"}
{"task_id": 130, "completion": "def max_occurrences(nums):\n    # Check if the list is empty\n    if not nums:\n        return None, 0\n    \n    # Creating a dictionary to store the frequency of each element\n    freq_dict = {}\n    for num in nums:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    \n    # Finding the maximum frequency\n    max_freq = max(freq_dict.values())\n    \n    # Finding the item(s) with the maximum frequency\n    max_freq_items = [item for item, freq in freq_dict.items() if freq == max_freq]\n    \n    # If there's only one item with the maximum frequency, return it directly,\n    # otherwise return the list of items and the frequency.\n    if len(max_freq_items) == 1:\n        return max_freq_items[0], max_freq\n    else:\n        return max_freq_items, max_freq"}
{"task_id": 131, "completion": "def reverse_vowels(str1):\n    vowels = 'aeiouAEIOU'\n    # Find all vowels in the string\n    list_vowels = [c for c in str1 if c in vowels]\n    # Reverse the list of vowels\n    list_vowels.reverse()\n    \n    # Create a list to hold the new string characters\n    new_str = []\n    \n    # Counter for vowels list\n    vowel_index = 0\n    \n    # Loop through the original string\n    for c in str1:\n        # If the character is a vowel, use the next vowel from the reversed list\n        if c in vowels:\n            new_str.append(list_vowels[vowel_index])\n            vowel_index += 1\n        # If not a vowel, just keep the character as it is\n        else:\n            new_str.append(c)\n    \n    # Convert the list of characters back into a string\n    return ''.join(new_str)\n`"}
{"task_id": 132, "completion": "def tup_string(tup1):\n    \"\"\"\n    Converts a tuple into a string by concatenating all of the tuple's elements.\n    \n    Args:\n    tup1 (tuple): The tuple to be converted into a string.\n    \n    Returns:\n    str: A string representation of the tuple's elements concatenated together.\n    \"\"\"\n    # Use a generator expression to convert each tuple element to a string, then join them with no separator.\n    return ''.join(str(item) for item in tup1)"}
{"task_id": 133, "completion": "def sum_negativenum(nums):\n    # Use the filter function to filter out negative numbers and then sum them up\n    sum_negative = sum(filter(lambda x: x < 0, nums))\n    return sum_negative"}
{"task_id": 134, "completion": "def check_last(arr, n, p):\n    \"\"\"\n    Check if the last element of the array is even or odd after incrementing it p times.\n\n    Parameters:\n    arr (list): The array of integers.\n    n (int): The size of the array.\n    p (int): The number of times the last element is to be incremented.\n\n    Returns:\n    str: 'even' if the last element is even after p increments, 'odd' otherwise.\n    \"\"\"\n    if n == 0:\n        return \"The array is empty.\"\n    \n    last_element = arr[-1]  # Access the last element of the array.\n    final_value = last_element + p  # Increment the last element p times.\n    \n    if final_value % 2 == 0:\n        return \"even\"\n    else:\n        return \"odd\"\n"}
{"task_id": 135, "completion": "def hexagonal_num(n):\n    return n * (2 * n - 1)"}
{"task_id": 136, "completion": "def cal_electbill(units):\n    \"\"\"\n    Calculate the electricity bill based on the number of units used.\n\n    Args:\n    units (float): The number of units of electricity consumed.\n\n    Returns:\n    float: The total bill amount.\n    \"\"\"\n    rate_per_unit = 0.12  # The cost of one unit (kWh). This is just an example rate; you should replace it with your actual rate.\n    \n    # Calculate the bill amount by multiplying the units consumed with the rate per unit\n    bill_amount = units * rate_per_unit\n    \n    return bill_amount"}
{"task_id": 137, "completion": "def zero_count(nums):\n    if not nums:  # Check if the list is empty\n        return 0  # Return 0 since there are no zeros in an empty list\n    \n    zero_count = 0  # Initialize counter for zeros\n    \n    # Loop through each number in the list\n    for num in nums:\n        # Increment count if a zero is found\n        if num == 0:\n            zero_count += 1\n    \n    # Calculate the ratio of zeros in the list\n    zero_ratio = zero_count / len(nums)\n    \n    # Return the ratio\n    return zero_ratio\n`"}
{"task_id": 138, "completion": "def is_Sum_Of_Powers_Of_Two(n):\n    # A number less than 1 cannot be expressed as sum of non-zero powers of 2\n    if n < 1:\n        return False\n    # Check if 'n' is a power of 2 or can be represented as sum of powers of 2.\n    # This condition checks if there is only one '1' in the binary representation\n    # or more. If there is at least one '1', the number can be represented as the \n    # sum of powers of 2, by the nature of binary numbers.\n    # This operation is checking if 'n' AND ('n-1') is 0, which is true for powers of 2\n    # But since we want all numbers that can be represented as sum of non-zero powers of 2,\n    # and every positive integer complies, we directly return True for all n > 0.\n    return True"}
{"task_id": 139, "completion": "def circle_circumference(r):\n    # Import the math module to access pi\n    import math\n    \n    # Calculate the circumference using the formula\n    circumference = 2 * math.pi * r\n    \n    # Return the result\n    return circumference"}
{"task_id": 140, "completion": "def extract_singly(test_list):\n    # First, we flatten the list of tuples to make our search easier.\n    flat_list = [item for sublist in test_list for item in sublist]\n    \n    # We then use a dictionary to count the occurrences of each element in the flattened list.\n    count_dict = {}\n    for item in flat_list:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    \n    # Now, we extract the elements that occur exactly once.\n    singly_occurring_elements = [item for item, count in count_dict.items() if count == 1]\n    \n    return singly_occurring_elements\n`"}
{"task_id": 141, "completion": "def pancake_sort(nums):\n    \"\"\"Sorts the list using pancake sort algorithm\"\"\"\n    curr_size = len(nums)\n    while curr_size > 1:\n        # Find the index of the maximum element in nums[0..curr_size-1]\n        max_idx = find_max_index(nums, curr_size)\n\n        # Move the maximum number to the beginning if it's not already at the beginning\n        if max_idx != curr_size - 1:\n            # Flip the list from 0 to max_idx\n            flip(nums, max_idx + 1)\n            # Flip the list again to move the maximum number to its place\n            flip(nums, curr_size)\n\n        # Reduce the current size by 1\n        curr_size -= 1\n    return nums"}
{"task_id": 142, "completion": "def count_samepair(list1, list2, list3):\n    # Initialize a counter for matching pairs\n    same_pair_count = 0\n    \n    # Iterate through the lists by their indexes\n    for i in range(min(len(list1), len(list2), len(list3))):\n        # Check if any two elements in the three positions match\n        if list1[i] == list2[i] and list1[i] != list3[i]:\n            same_pair_count += 1\n        elif list1[i] == list3[i] and list1[i] != list2[i]:\n            same_pair_count += 1\n        elif list2[i] == list3[i] and list2[i] != list1[i]:\n            same_pair_count += 1\n    \n    # Return the total count of matching pairs\n    return same_pair_count"}
{"task_id": 143, "completion": "def find_lists(input_tuple):\n    \"\"\"\n    Finds the number of lists present in the given tuple.\n\n    Parameters:\n    input_tuple (tuple): The tuple to search for lists.\n\n    Returns:\n    int: The number of lists found in the tuple.\n    \"\"\"\n    # Initialize a counter for the number of lists\n    list_count = 0\n\n    # Iterate through each item in the tuple\n    for item in input_tuple:\n        # Check if the current item is a list\n        if isinstance(item, list):\n            # Increment the counter if a list is found\n            list_count += 1\n\n    # Return the total count of lists found\n    return list_count"}
{"task_id": 144, "completion": "def sum_pairs(arr):\n    \"\"\"\n    Calculates the sum of absolute differences in all pairs of the given array.\n    \n    Parameters:\n    arr (list): The array for which the sum of absolute differences is calculated.\n    \n    Returns:\n    int: The sum of absolute differences of all pairs.\n    \"\"\"\n    # First, sort the array to make it easier to calculate absolute differences in a linear way\n    arr.sort()\n    \n    # Initialize variables to store the total sum and the length of the array\n    total_sum = 0\n    n = len(arr)\n    \n    # Loop through each element in the array\n    for i in range(n):\n        # Since the array is sorted, the difference of the current element with all the \n        # elements before it will be added, and with all the elements after it will be subtracted.\n        total_sum += (arr[i] * i) - (arr[i] * (n - i - 1))\n    \n    return total_sum\n`"}
{"task_id": 145, "completion": "def max_Abs_Diff(arr, n):\n    # If the array is empty or contains only one element, the max difference is 0.\n    if n < 2:\n        return 0\n\n    # Initialize min and max elements\n    min_element = arr[0]\n    max_element = arr[0]\n    \n    # Iterate through the array to find the minimum and maximum elements\n    for i in range(1, n):\n        if arr[i] < min_element:\n            min_element = arr[i]\n        elif arr[i] > max_element:\n            max_element = arr[i]\n\n    # The maximum difference will be the difference between max_element and min_element\n    return max_element - min_element"}
{"task_id": 146, "completion": "def ascii_value_string(str1):\n    total_ascii_value = 0  # Initialize total value\n    for char in str1:\n        total_ascii_value += ord(char)  # Add ASCII value of each character to total\n    return total_ascii_value"}
{"task_id": 147, "completion": "def max_path_sum(tri, m):\n    \"\"\"\n    Calculate the maximum path sum in triangle `tri` with `m` rows.\n    Arguments:\n    tri -- 2D list representing the triangle\n    m -- Integer, the number of rows in the triangle\n    \"\"\"\n    \n    # Create a copy of the last row in the triangle; this will hold the maximum path sums at each step\n    max_sum = list(tri[-1])\n    \n    # Iterate from the second-last row to the first row\n    for i in range(m-2, -1, -1):\n        # For each element in the current row\n        for j in range(len(tri[i])):\n            # Update the max_sum value for this cell being the maximum path sum of the two possible paths below it\n            # tri[i][j] is the current cell, max_sum[j] and max_sum[j+1] are the two possible paths from the current cell\n            max_sum[j] = tri[i][j] + max(max_sum[j], max_sum[j+1])\n    \n    # The first element of the max_sum now contains the maximum path sum from the top to the bottom of the triangle\n    return max_sum[0]"}
{"task_id": 148, "completion": "def sum_digits_single(x):\n    # Convert the number into a list of digits\n    digits = [int(digit) for digit in str(x)]\n    \n    # Sort the digits in descending order\n    sorted_digits = sorted(digits, reverse=True)\n    \n    # Use string manipulation to form the two parts\n    part1_digits = sorted_digits[::2]  # Take every other digit starting from the first\n    part2_digits = sorted_digits[1::2]  # Take every other digit starting from the second\n    \n    # Convert the list of digits back into integer form\n    part1 = int(''.join(map(str, part1_digits)))\n    part2 = int(''.join(map(str, part2_digits)))\n    \n    return part1, part2"}
{"task_id": 149, "completion": "def longest_subseq_with_diff_one(arr, n):\n    # Initialize a list to keep track of the longest subsequence length ending at each index\n    dp = [1]*n\n    \n    # Fill the dp array\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n                \n    # The maximum value in dp is the length of the longest subsequence\n    return max(dp)"}
{"task_id": 150, "completion": "def does_Contain_B(a, b, c):\n    \"\"\"\n    Check if 'c' is in the sequence that starts with 'a' and increments by 'b'.\n    \n    Parameters:\n    a (int): The start of the sequence.\n    b (int): The step/increment of the sequence. Must not be 0.\n    c (int): The number to check for in the sequence.\n    \n    Returns:\n    bool: True if 'c' is in the sequence, False otherwise.\n    \"\"\"\n    if b == 0:\n        # If increment 'b' is zero, the sequence does not progress and only contains 'a'.\n        return c == a\n\n    # Check if 'c' fits into the arithmetic progression formula to be part of the sequence.\n    # A value 'c' is in the sequence if (c - a) is exactly divisible by 'b' (the step),\n    # meaning 'c' lands perfectly in the progression.\n    #\n    # Also, it is assumed that 'b' can be positive or negative, but not zero, to avoid division by zero.\n    # This check ensures that 'c' is following the sequence pattern starting at 'a' with increments of 'b'.\n    #\n    # Additionally, (c - a) % b == 0 ensures 'c' aligns with the sequence\n    # at a step that can be zero or more steps away from 'a', but not in between steps.\n    # This effectively checks if 'c' can be reached by starting at 'a' and moving in steps of 'b' without leftovers.\n    return (c - a) % b == 0\n`"}
{"task_id": 151, "completion": "def gcd(a, b):\n    \"\"\"Calculate the Greatest Common Divisor of a and b.\n    \n    Unless b==0, the result will have the same sign as b (so that when\n    b is divided by it, the result comes out positive).\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\ndef check_coprime(p, q):\n    \"\"\"Check if two numbers, p and q, are co-prime.\"\"\"\n    return gcd(p, q) == 1"}
{"task_id": 152, "completion": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2  # Find the mid of the array\n        L = arr[:mid]  # Dividing the array elements into 2 halves\n        R = arr[mid:]\n  \n        merge_sort(L)  # Sorting the first half\n        merge_sort(R)  # Sorting the second half\n  \n        i = j = k = 0\n  \n        # Copy data to temp arrays L[] and R[]\n        while i < len(L) and j < len(R):\n            if L[i] < R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n  \n        # Checking if any element was left\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n  \n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1"}
{"task_id": 153, "completion": "def parabola_vertex(a, b, c):\n    h = -b / (2 * a)\n    k = c - (b**2) / (4 * a)\n    return (h, k)"}
{"task_id": 154, "completion": "def specified_element(nums, N):\n    # Initialize an empty list to store the results\n    result = []\n    # Iterate through each inner list in nums\n    for inner_list in nums:\n        # Check if the length of the inner list is greater than N (to avoid index errors)\n        if len(inner_list) > N:\n            # Append the Nth element of the inner list to the result list\n            result.append(inner_list[N])\n    # Return the result list\n    return result"}
{"task_id": 155, "completion": "def even_bit_toggle_number(n):\n    # Define mask with even bits set (for a 32-bit number)\n    mask = 0x55555555  \n    # XOR the number with the mask to toggle the even bits\n    return n ^ mask"}
{"task_id": 156, "completion": "def tuple_int_str(tuple_str):\n    # Convert each string in the tuple to an integer\n    tuple_int = tuple(map(int, tuple_str))\n    return tuple_int"}
{"task_id": 157, "completion": "def encode_list(input_list):\n    # Check if the input list is empty\n    if not input_list:\n        return []\n    \n    encoded_list = []  # Initialize the encoded list\n    current_element = input_list[0]  # The current element to check for repeats\n    count = 1  # Count of the current element\n\n    # Loop through the list starting from the second element\n    for element in input_list[1:]:\n        if element == current_element:\n            count += 1  # Increment the count if the current element is repeated\n        else:\n            # If the current element changes, append the (element, count) to the encoded list\n            encoded_list.append((current_element, count))\n            current_element = element  # Update the current_element\n            count = 1  # Reset the count for the new element\n            \n    # Append the last element after the loop\n    encoded_list.append((current_element, count))\n    \n    return encoded_list"}
{"task_id": 158, "completion": "def min_operations_to_equal_elements(arr):\n    \"\"\"\n    Calculate minimum operations needed to make all array elements equal.\n    This function does not adhere to the \"exactly k operations\" constraint.\n    \"\"\"\n    # Sort the array to easily find the median\n    arr.sort()\n    n = len(arr)\n    \n    # Find the median\n    if n % 2 == 1:\n        target = arr[n // 2]\n    else:\n        # Optionally, choose a target value between the two middle elements\n        target = arr[n // 2]\n    \n    # Calculate the total number of operations required\n    operations = sum(abs(target - x) for x in arr)\n    \n    return operations\n`"}
{"task_id": 159, "completion": "def month_season(month, day):\n    month = str(month).lower()\n\n    month_to_number = {\n        \"january\": 1,\n        \"february\": 2,\n        \"march\": 3,\n        \"april\": 4,\n        \"may\": 5,\n        \"june\": 6,\n        \"july\": 7,\n        \"august\": 8,\n        \"september\": 9,\n        \"october\": 10,\n        \"november\": 11,\n        \"december\": 12\n    }\n\n    if month.isdigit():\n        month = int(month)\n    else:\n        month = month_to_number.get(month, 0)\n\n    if (month == 3 and day >= 20) or (month > 3 and month < 6) or (month == 6 and day <= 20):\n        season = \"Spring\"\n    elif (month == 6 and day >= 21) or (month > 6 and month < 9) or (month == 9 and day <= 22):\n        season = \"Summer\"\n    elif (month == 9 and day >= 23) or (month > 9 and month < 12) or (month == 12 and day <= 20):\n        season = \"Autumn\"\n    elif (month == 12 and day >= 21) or (month < 3) or (month == 3 and day <= 19):\n        season = \"Winter\"\n    else:\n        season = \"Invalid date\"\n\n    print(season)"}
{"task_id": 160, "completion": "def find_solution(a, b, n):\n    g, x, y = extended_gcd(a, b)\n    if n % g != 0:\n        print(\"No solution\")\n        return None, None\n    x0 = x * (n // g)\n    y0 = y * (n // g)\n    return x0, y0"}
{"task_id": 161, "completion": "def remove_elements(list1, list2):\n    # Using a list comprehension to filter out elements present in list2\n    return [element for element in list1 if element not in list2]"}
{"task_id": 162, "completion": "def sum_series(n):\n    \"\"\"\n    Calculates the sum of the series n + (n-2) + (n-4) + ... (until n-x <= 0).\n    \n    :param n: Starting point of the series, must be a positive integer.\n    :return: The sum of the series.\n    \"\"\"\n    # Initialize sum variable to keep track of the series total\n    sum = 0\n    \n    # Use a while loop to iterate until n is less than or equal to 0\n    while n > 0:\n        sum += n  # Add the current n value to the sum\n        n -= 2  # Decrease n by 2 for the next iteration\n        \n    return sum\n`"}
{"task_id": 163, "completion": "def area_polygon(s, l):\n    \"\"\"\n    Calculate the area of a regular polygon.\n\n    Parameters:\n    s (int): The number of sides of the polygon.\n    l (float): The length of each side of the polygon.\n\n    Returns:\n    float: The area of the polygon.\n    \"\"\"\n    # Check if the input values are valid\n    if s < 3 or l <= 0:\n        raise ValueError(\"The polygon must have at least 3 sides, and side length must be positive.\")\n    \n    # Calculate the area\n    area = (s * (l ** 2)) / (4 * math.tan(math.pi / s))\n    return area"}
{"task_id": 164, "completion": "def divSum(n):\n    \"\"\"\n    This function takes an integer n and returns the sum of all its divisors.\n    \"\"\"\n    if n == 1:\n        return 1  # The divisor of 1 is only itself\n    \n    # Initialize sum of divisors including 1\n    sum_divisors = 1  # Starting with 1 because it's a divisor of all numbers\n\n    # We iterate from 2 to square root of n. Adding both divisor and quotient\n    # to ensure we're covering all possible divisors.\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if i == (n / i): # If divisors are equal, add it once (perfect square case)\n                sum_divisors += i\n            else:\n                sum_divisors += i + (n // i) # Adding both divisor and its complement\n\n    # Adding the number itself if you consider it as a divisor, remove this if not\n    sum_divisors += n\n\n    # Returning the sum of divisors\n    return sum_divisors\n`"}
{"task_id": 165, "completion": "def count_char_position(str1):\n    # Initialize count\n    count = 0\n    \n    # Iterate over the string\n    for i, char in enumerate(str1, start=1):\n        # Check if the character is a letter and its position matches the alphabet position\n        if char.isalpha() and (ord(char.lower()) - 96) == i:\n            count += 1\n            \n    return count"}
{"task_id": 166, "completion": "def find_even_Pair(A, N):\n    # Count of even and odd elements\n    even_count = 0\n    odd_count = 0\n    \n    # Loop to count even and odd elements\n    for i in range(N):\n        if A[i] % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Any pair of two evens or two odds will have an even XOR.\n    # The number of ways to choose 2 out of 'even_count' is even_countC2 = even_count * (even_count - 1) / 2\n    # Similarly, the number of ways to choose 2 out of 'odd_count' is odd_countC2 = odd_count * (odd_count - 1) / 2\n    # The total even XOR pairs are the sum of the above two.\n    even_xor_pairs = (even_count * (even_count - 1) // 2) + (odd_count * (odd_count - 1) // 2)\n    \n    return even_xor_pairs\n`"}
{"task_id": 167, "completion": "def next_Power_Of_2(n):\n    if n <= 1:\n        return 1\n        \n    # Decrement n to handle cases where n itself is a power of 2\n    n -= 1\n    \n    # Or `n` with its half until `n` contains only 1s.\n    # This works for 32-bit integers. Extend shifts for larger integers.\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    \n    # Add 1 to get the next power of 2\n    return n + 1"}
{"task_id": 168, "completion": "def frequency(a, x):\n    # Counting the occurrences of x in a using the count method\n    return a.count(x)"}
{"task_id": 169, "completion": "def get_pell(n):\n    if n == 0: \n        return 0\n    elif n == 1: \n        return 1\n    else:\n        pell = [0, 1]  # Starting values for Pell series\n        for i in range(2, n + 1):\n            pell.append(2 * pell[i - 1] + pell[i - 2])\n        return pell[n]"}
{"task_id": 170, "completion": "def sum_range_list(list1, m, n):\n    # Ensure m and n are within the correct bounds\n    if m < 0 or n >= len(list1) or m > n:\n        return \"Invalid range. Please ensure m <= n and both indices are within the list bounds.\"\n\n    # Sum the numbers in the specified range\n    total = sum(list1[m:n+1])\n    return total\n`"}
{"task_id": 171, "completion": "def perimeter_pentagon(a):\n    \"\"\"\n    This function calculates the perimeter of a regular pentagon.\n\n    Parameters:\n    a (float or int): The length of one side of the pentagon.\n\n    Returns:\n    float: The perimeter of the pentagon.\n    \"\"\"\n    return 5 * a"}
{"task_id": 172, "completion": "def count_occurrence(s):\n    # Initialize a dictionary to count occurrences of 's', 't', and 'd'\n    char_count = {'s': 0, 't': 0, 'd': 0}\n    \n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is one of 's', 't', or 'd' and increment its count\n        if char in char_count:\n            char_count[char] += 1\n    \n    return char_count"}
{"task_id": 173, "completion": "def remove_splchar(text):\n    # This regex pattern matches anything that is NOT a letter or number.\n    pattern = re.compile('[^a-zA-Z0-9]')\n    \n    # re.sub() finds all substrings where the regex pattern matches and replaces them with an empty string.\n    cleaned_text = pattern.sub('', text)\n    \n    return cleaned_text\n`"}
{"task_id": 174, "completion": "def group_keyvalue(kv_pairs):\n    grouped_dict = {}\n    for key, value in kv_pairs:\n        if key not in grouped_dict:\n            grouped_dict[key] = []\n        grouped_dict[key].append(value)\n    return grouped_dict\n`"}
{"task_id": 175, "completion": "def is_valid_parentheses(s: str) -> bool:\n    # Stack to keep track of opening parentheses\n    stack = []\n\n    # Dictionary to hold corresponding pairs\n    parentheses_map = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        # If the character is an closing parenthesis\n        if char in parentheses_map:\n            # Pop from the stack if it's not empty otherwise use a dummy value\n            top_element = stack.pop() if stack else '#'\n            \n            # Check if the popped element is the mapping counterpart of char\n            if parentheses_map[char] != top_element:\n                return False\n        else:\n            # Push the opening parenthesis onto the stack\n            stack.append(char)\n\n    # If stack is empty, all parentheses were valid\n    return not stack"}
{"task_id": 176, "completion": "def perimeter_triangle(a, b, c):\n    return a + b + c"}
{"task_id": 177, "completion": "def find_lcm_pair(L, R):\n    # Simple case: directly return if the range is itself a possible LCM\n    if L == R:\n        return (L, 1)\n    \n    for i in range(L, R + 1):\n        for j in range(i + 1, R + 1):\n            if np.gcd(i, j) == 1 or i*j <= R: # Check if they are co-prime or their product is within range\n                if i*j >= L and i*j <= R:\n                    return (i, j)\n    return None"}
{"task_id": 178, "completion": "def string_literals(patterns, text):\n    \"\"\"\n    Searches for the occurrence of each literal string pattern in the given text.\n\n    Parameters:\n    patterns (list of str): A list of string literals to search for.\n    text (str): The text in which to search for the literals.\n\n    Returns:\n    dict: A dictionary with the literal strings as keys and boolean values indicating whether\n          each literal string was found in the text.\n    \"\"\"\n    # Initialize an empty dictionary to store the search results\n    results = {}\n\n    # Iterate through each pattern in the patterns list\n    for pattern in patterns:\n        # Check if the current pattern exists in the text\n        # and update the result dictionary accordingly\n        results[pattern] = pattern in text\n\n    return results"}
{"task_id": 179, "completion": "def is_num_keith(n):\n    # Convert the number to a list of digits\n    digits = [int(d) for d in str(n)]\n    sequence = digits.copy() # Initial sequence with the digits of the number\n    \n    next_term = sum(sequence) # First computation outside the loop\n    \n    # Since a Keith number must be reached before it becomes greater than itself\n    while next_term < n:\n        sequence.append(next_term) # Add the next term to the sequence\n        sequence.pop(0) # Remove the first term to maintain the length\n        next_term = sum(sequence) # Sum up the new sequence for the next term\n    \n    # If the sequence grows to match the number, it's a Keith number\n    return next_term == n\n`"}
{"task_id": 180, "completion": "import math\n\ndef distance_lat_long(slat, slon, elat, elon):\n    # Radius of the Earth in kilometers\n    R = 6371.0\n    \n    # Convert latitude and longitude from degrees to radians\n    slat_rad = math.radians(slat)\n    slon_rad = math.radians(slon)\n    elat_rad = math.radians(elat)\n    elon_rad = math.radians(elon)\n    \n    # Difference in coordinates\n    dlat = elat_rad - slat_rad\n    dlon = elon_rad - slon_rad\n    \n    # Haversine formula\n    a = math.sin(dlat / 2)**2 + math.cos(slat_rad) * math.cos(elat_rad) * math.sin(dlon / 2)**2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    \n    # Total distance in kilometers\n    distance = R * c\n    \n    return distance"}
{"task_id": 181, "completion": "def common_prefix_util(str1, str2):\n    \"\"\"\n    Finds the longest common prefix between two strings.\n\n    Parameters:\n    str1 (str): The first string.\n    str2 (str): The second string.\n\n    Returns:\n    str: The longest common prefix of str1 and str2.\n    \"\"\"\n    # Initialize the result as an empty string\n    common_prefix = \"\"\n    \n    # Find the smaller length between str1 and str2 to avoid index out of range\n    shorter_length = min(len(str1), len(str2))\n    \n    # Iterate through both strings up to the length of the shorter string\n    for i in range(shorter_length):\n        if str1[i] == str2[i]:\n            # If characters match, append to the result\n            common_prefix += str1[i]\n        else:\n            # Break the loop if there is a mismatch\n            break\n\n    return common_prefix\n`"}
{"task_id": 182, "completion": "import re\n\ndef find_character(string):\n    uppercase = re.findall(r'[A-Z]', string)\n    lowercase = re.findall(r'[a-z]', string)\n    numerics = re.findall(r'\\d', string)\n    special_chars = re.findall(r'[^A-Za-z0-9]', string)"}
{"task_id": 183, "completion": "def count_pairs(arr, n, k):\n    \"\"\"\n    Counts distinct pairs with difference k in the given array.\n    \n    Parameters:\n    - arr: List[int] -- input array\n    - n: int -- length of the array\n    - k: int -- the difference condition for pairs\n    \n    Returns:\n    int -- count of distinct pairs with difference k\n    \"\"\"\n    count = 0\n    # Convert array to set for faster searches and uniqueness\n    elements = set(arr)\n    \n    for num in elements:\n        if num + k in elements:\n            count += 1\n        if num - k in elements:\n            count += 1\n            \n    # Divide by 2 because each pair is counted twice\n    return count // 2"}
{"task_id": 184, "completion": "def greater_specificnum(lst, num):\n    \"\"\"\n    Function to find all the values in a list that are greater than a specified number.\n    \n    Parameters:\n    lst (list): The list of numbers to check.\n    num (int/float): The specified number to compare the list elements against.\n    \n    Returns:\n    list: A list of numbers from the original list that are greater than the specified number.\n    \"\"\"\n    # Use a list comprehension to find all elements greater than 'num'\n    return [x for x in lst if x > num]\n`"}
{"task_id": 185, "completion": "def parabola_focus(a, b, c):\n    # Convert to vertex form: y = a(x - h)^2 + k\n    # h = -b / (2 * a)\n    h = -b / (2 * a)\n    \n    # k = c - (b^2 / (4 * a))\n    k = c - (b**2 / (4 * a))\n    \n    # The focal length (p) = 1 / (4 * a) because the equation of a parabola is 4p(y - k) = (x - h)^2 for vertical orientation\n    p = 1 / (4 * a)\n    \n    # The focus is at (h, k + p)\n    focus = (h, k + p)\n    \n    return focus"}
{"task_id": 186, "completion": "import re\n\ndef check_literals(text, patterns):\n    occurrences = {}\n    for pattern in patterns:\n        # Escape the string to be searched to treat it as a literal in the regex\n        escaped_pattern = re.escape(pattern)\n        \n        # Find all occurrences of the literal pattern\n        matches = [(m.start(), m.group()) for m in re.finditer(escaped_pattern, text)]\n        \n        # Store results in the dictionary\n        occurrences[pattern] = matches\n    \n    return occurrences\n`"}
{"task_id": 187, "completion": "def longest_common_subsequence(X, Y):\n    \"\"\"\n    Function to find the longest common subsequence of X and Y.\n    :param X: First sequence\n    :param Y: Second sequence\n    :return: The length of the longest common subsequence and the subsequence itself.\n    \"\"\"\n    m = len(X)\n    n = len(Y)\n    \n    # Create a DP table to memoize the results of subproblems\n    L = [[None]*(n+1) for i in range(m+1)]\n    \n    # Building the L[m][n] in bottom up fashion\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i-1] == Y[j-1]:\n                L[i][j] = L[i-1][j-1] + 1\n            else:\n                L[i][j] = max(L[i-1][j], L[i][j-1])\n    \n    # Following the steps to reconstruct the subsequence\n    # Starting from L[m][n]\n    index = L[m][n]\n    \n    # Create a character array to store the lcs string\n    lcs = [\"\"] * (index+1)\n    lcs[index] = \"\"\n    \n    # Start from the right-most-bottom-most corner and move diagonally up\n    i, j = m, n\n    while i > 0 and j > 0:\n        \n        # If the current character in X and Y are same, then current character is part of LCS\n        if X[i-1] == Y[j-1]:\n            lcs[index-1] = X[i-1]\n            i -= 1\n            j -= 1\n            index -= 1\n        \n        # If not same, then find the larger of two and go in the direction of larger value\n        elif L[i-1][j] > L[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n    \n    # Joining the characters\n    lcs_str = \"\".join(lcs).strip()\n    \n    return L[m][n], lcs_str\n`"}
{"task_id": 188, "completion": "def prod_Square(n):\n    # To handle the case when n is 0 or 1\n    if n == 0 or n == 1:\n        return True\n    \n    # Prime factorization of n and checking the power of each prime factor\n    for i in range(2, int(n**0.5) + 1):\n        # Count power of prime factor\n        count = 0\n        while n % i == 0:\n            n //= i\n            count += 1\n        \n        # If the power is odd, return False\n        if count % 2 != 0:\n            return False\n    \n    # If n becomes a prime number greater than 1\n    if n > 1:\n        return False\n\n    return True"}
{"task_id": 189, "completion": "def first_Missing_Positive(arr, n):\n    # Place each positive integer in its correct position\n    for i in range(n):\n        while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]:\n            # Swap arr[i] with arr[arr[i]-1]\n            arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]\n    \n    # Find the first missing positive\n    for i in range(n):\n        if arr[i] != i + 1:\n            return i + 1\n    \n    # If all positive integers up to n are present, then answer is n+1\n    return n + 1\n`"}
{"task_id": 190, "completion": "def count_integral_points(x1, y1, x2, y2):\n    # Calculating the lengths of the sides considering the square can be oriented in any way\n    side_x = abs(x2 - x1) - 1\n    side_y = abs(y2 - y1) - 1\n    \n    # If either side_x or side_y is less than 0, it means that the points are either\n    # on the same line or too close, preventing any integral points to lie strictly inside.\n    if side_x < 0 or side_y < 0:\n        return 0\n    \n    # Multiplying the sides gives us the number of integral points inside the square, excluding the boundary.\n    return side_x * side_y"}
{"task_id": 191, "completion": "def check_monthnumber(monthname3):\n    # List of months with 30 days\n    months_with_30_days = [\"April\", \"June\", \"September\", \"November\"]\n    \n    # Normalize the month name to ensure case-insensitive matching\n    monthname3_normalized = monthname3.strip().capitalize()\n    \n    # Check if the given month is in the list of months with 30 days\n    if monthname3_normalized in months_with_30_days:\n        return True\n    else:\n        return False"}
{"task_id": 192, "completion": "def check_String(str):\n    has_letter = False\n    has_number = False\n\n    for char in str:\n        if char.isalpha():\n            has_letter = True\n        elif char.isdigit():\n            has_number = True\n        \n        # If both conditions are met, no need to continue checking\n        if has_letter and has_number:\n            break\n\n    return has_letter and has_number"}
{"task_id": 193, "completion": "def remove_tuple_duplicates(test_tup):\n    # Using a set to keep track of seen elements\n    seen = set()\n    result = []\n    for item in test_tuple:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    # Convert the result list back to a tuple\n    return tuple(result)"}
{"task_id": 194, "completion": "def octal_to_Decimal(n):\n    # The second argument of int() is the base of the provided number, \n    # so 8 is used for octal.\n    return int(n, 8)"}
{"task_id": 195, "completion": "def first(arr, x, n):\n    \"\"\"\n    A function to find the first occurrence of an element x in a sorted array.\n\n    Parameters:\n    arr: List[int] - the sorted array.\n    x: int - the element to search for.\n    n: int - the number of elements in the array.\n    \n    Returns:\n    int: The index of the first occurrence of x if present, otherwise -1.\n    \"\"\"\n    low = 0\n    high = n - 1\n    result = -1  # Initialize result as -1 assuming x is not present in arr.\n\n    while low <= high:\n        mid = (low + high) // 2  # Find the mid index\n        \n        # If x is at mid\n        if arr[mid] == x:\n            result = mid  # Update result to mid\n            high = mid - 1  # Move to the left part to check for earlier occurrence\n        elif arr[mid] < x:  # If x greater, ignore left half\n            low = mid + 1\n        else:  # If x is smaller, ignore right half\n            high = mid - 1\n\n    return result"}
{"task_id": 196, "completion": "def remove_tuples(test_list, K):\n    \"\"\"\n    Removes tuples from the list that have a length of K.\n    \n    Parameters:\n    - test_list: List containing various tuples\n    - K: An integer representing the length of tuples to be removed\n    \n    Returns:\n    - A new list with tuples of length K removed.\n    \"\"\"\n    \n    # Use list comprehension to filter out tuples of length K\n    return [item for item in test_list if not isinstance(item, tuple) or len(item) != K]"}
{"task_id": 197, "completion": "def find_exponentiation(test_tup1, test_tup2):\n    # Using a generator expression to perform element-wise exponentiation\n    result = tuple(a ** b for a, b in zip(test_tup1, test_tup2))\n    return result\n`"}
{"task_id": 198, "completion": "def largest_triangle(a, b):\n    # Function to convert polar coordinates to Cartesian, given semi-major (a) and semi-minor (b) axes\n    def polar_to_cartesian(r, theta):\n        return a * r * np.cos(theta), b * r * np.sin(theta)\n\n    # Approximating: Triangles vertices are placed at 0, 2\u03c0/3, and 4\u03c0/3 radians to ensure even spacing\n    theta_values = [0, 2*np.pi/3, 4*np.pi/3]\n    vertices = [polar_to_cartesian(1, theta) for theta in theta_values]\n`"}
{"task_id": 199, "completion": "def highest_Power_of_2(n):\n    if n < 1:\n        return 0\n    # Keep shifting n to the right until it becomes 0\n    # This essentially finds the highest power of 2\n    power = 1\n    while n > 1:\n        n >>= 1\n        power <<= 1\n    return power"}
{"task_id": 200, "completion": "def position_max(list1):\n    # Check if the list is empty\n    if not list1:\n        return \"The list is empty.\"\n    \n    # Find the maximum value in the list\n    max_value = max(list1)\n    \n    # Use a list comprehension to find all indexes of the maximum value\n    max_indexes = [index for index, value in enumerate(list1) if value == max_value]\n    \n    return max_indexes"}
{"task_id": 201, "completion": "def chkList(lst):\n    return all(item == lst[0] for item in lst) if lst else True\n`"}
{"task_id": 202, "completion": "def remove_even(str1):\n    # Create a new string that includes characters from odd indices only\n    new_str = ''\n    for i in range(len(str1)):\n        # Check if the index is odd\n        if i % 2 != 0:\n            new_str += str1[i]\n    return new_str"}
{"task_id": 203, "completion": "def hamming_distance(n1, n2):\n    # Step 1: Find the XOR of the two numbers\n    xor_result = n1 ^ n2\n    \n    # Step 2: Count the set bits in the XOR result\n    count = 0\n    while xor_result > 0:\n        # Increment count if the least significant bit is 1\n        count += xor_result & 1\n        \n        # Right shift 'xor_result' by 1 to check the next bit\n        xor_result >>= 1\n    \n    return count"}
{"task_id": 204, "completion": "def count(s, c):\n    # Use the count method of the string to find the occurrences of character c in string s\n    return s.count(c)"}
{"task_id": 205, "completion": "def inversion_elements(test_tup):\n    \"\"\"\n    Takes a list of tuples, and returns a new list where each element is the\n    number of inversions in the corresponding tuple from the input list.\n    \"\"\"\n    inversion_counts = []\n    for tup in test_tup:\n        inv_count = count_inversions_in_tuple(tup)\n        inversion_counts.append(inv_count)\n    return inversion_counts\n`"}
{"task_id": 206, "completion": "def concatenate_elements(test_tup):\n    # This list will hold the concatenated results\n    result = []\n    \n    # Loop through the tuple elements by their index\n    for i in range(len(test_tup) - 1):\n        # Concatenate the current and next elements and add to the result list\n        # Note: This assumes the elements in the tuple are strings.\n        # If the elements are of a different type (e.g., integers), you might need to convert them to strings first.\n        result.append(str(test_tup[i]) + str(test_tup[i + 1]))\n        \n    return result"}
{"task_id": 207, "completion": "def find_longest_repeating_subseq(s):\n    \"\"\"\n    This function finds the length of the longest repeating subsequence\n    in the string `s` such that the two subsequences do not have the \n    same character at the same position.\n    \"\"\"\n    n = len(s)\n    \n    # Create and initialize the DP table\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Fill dp table\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            # If characters match and are not at the same position in the original string\n            if s[i - 1] == s[j - 1] and i != j:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    # The last cell will have the length of the longest repeating subsequence\n    return dp[n][n - 1]"}
{"task_id": 208, "completion": "import re\n\ndef is_decimal(num):\n    # Define the regex pattern for a decimal with a precision of 2\n    pattern = r\"^\\d+\\.\\d{2}$\"\n    \n    # Check if the input matches the pattern\n    if re.match(pattern, num):\n        return True\n    else:\n        return False"}
{"task_id": 209, "completion": "import heapq\n\ndef heap_replace(heap, a):\n    \"\"\"\n    Replace the smallest element in the heap with a new value.\n    \n    Parameters:\n    - heap: List[int], a heap where heap properties are maintained.\n    - a: int, the new value to be added to the heap.\n    \n    Returns:\n    - The smallest element that was removed from the heap.\n    \"\"\"\n    # Replace the smallest element with the new item `a` and return the smallest element.\n    return heapq.heapreplace(heap, a)"}
{"task_id": 210, "completion": "import re\n\ndef is_allowed_specific_char(string):\n    \"\"\"\n    Check if the string contains only certain characters (a-z, A-Z, and 0-9).\n\n    :param string: The string to check.\n    :return: True if the string only contains the specified characters, False otherwise.\n    \"\"\"\n\n    # Regular expression pattern to match only a-z, A-Z, and 0-9.\n    pattern = re.compile(r'^[a-zA-Z0-9]+$')\n    \n    # re.match() checks for a match only at the beginning of the string,\n    # whereas re.search() checks for a match anywhere in the string.\n    # Using re.fullmatch() to ensure the entire string matches the pattern.\n    if pattern.fullmatch(string):\n        return True\n    else:\n        return False\n`"}
{"task_id": 211, "completion": "def count_Num(n):\n    \"\"\"\n    Counts the numbers where the 0th and nth bits are set.\n    \n    Parameters:\n    n (int): The n value representing the bit (other than the 0th) that must be set.\n    \n    Returns:\n    int: The count of numbers where both the 0th and nth bits are set.\n    \"\"\"\n    \n    # Check if n is valid (n >= 1 since 0th bit is least significant and we need at least 1 more bit)\n    if n < 1:\n        return \"Error: n should be 1 or higher.\"\n        \n    # Calculate count\n    # The formula to calculate the total numbers is 2^(n-1), as for n bits the total possibilities are 2^n,\n    # but since we need the 0th and nth bits specifically set, and the rest can be anything,\n    # for each bit from 1 to (n-1), they can either be 0 or 1, leading to 2^(n-1) possibilities.\n    \n    count = 2 ** (n - 1)\n    \n    return count\n`"}
{"task_id": 212, "completion": "def fourth_Power_Sum(n):\n    return (n * (n + 1) * (2 * n + 1) * (3 * n**2 + 3 * n - 1)) // 30"}
{"task_id": 213, "completion": "def concatenate_strings(test_tup1, test_tup2):\n    \"\"\"\n    Concatenate two string tuples.\n\n    Parameters:\n    test_tup1 (tuple): First tuple of strings.\n    test_tup2 (tuple): Second tuple of strings.\n\n    Returns:\n    tuple: A tuple containing all the strings from test_tup1 followed by all the strings from test_tup2.\n    \"\"\"\n    # Concatenating the tuples\n    result = test_tup1 + test_tup2\n    return result"}
{"task_id": 214, "completion": "def degree_radian(radian):\n    \"\"\"\n    Converts radians to degrees.\n\n    Args:\n    radian (float): The value in radians.\n\n    Returns:\n    float: The value in degrees.\n    \"\"\"\n    # Convert radian to degree\n    degrees = radian * (180 / math.pi)\n    return degrees"}
{"task_id": 215, "completion": "def decode_list(alist):\n    # The decoded list to return\n    decoded_list = []\n    \n    # Iterate over the given list. Assuming the list \n    # structure is correct, we can step by 2.\n    for i in range(0, len(alist), 2):\n        count = alist[i]    # The number of times the element should repeat\n        value = alist[i+1]  # The value to repeat\n        \n        # Extend the decoded_list by repeating the value 'count' times\n        decoded_list.extend([value] * count)\n    \n    return decoded_list"}
{"task_id": 216, "completion": "def check_subset_list(list1, list2):\n    \"\"\"Function to check if list1 is a subset of list2 considering nested lists.\"\"\"\n    return is_subset(list1, list2)"}
{"task_id": 217, "completion": "def first_Repeated_Char(s):\n    seen = set()  # Initialize an empty set to keep track of seen characters.\n    \n    for char in s:\n        if char in seen:\n            return char  # This is the first repeated character.\n        seen.add(char)  # Add the character to the set if it's not already there.\n    \n    return None  # Return None or a suitable message if no repeated character is found.\n`"}
{"task_id": 218, "completion": "def min_operations(a, b):\n    \"\"\"\n    Find the minimum operations required to make two numbers equal.\n    Assumes that allowed operations are increments or decrements by 1.\n    \n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    \n    Returns:\n    int: The minimum number of operations required to make a and b equal.\n    \"\"\"\n    # Calculate the absolute difference between the two numbers\n    difference = abs(a - b)\n    \n    # The difference directly represents the minimum operations required\n    return difference"}
{"task_id": 219, "completion": "def extract_min_max(test_tup, K):\n    # Ensure the tuple is sorted\n    sorted_tup = sorted(test_tup)\n    \n    # Extract min K elements\n    min_elements = sorted_tup[:K]\n    \n    # Extract max K elements\n    # Note: Since it's sorted in ascending order, we take the last K elements for max\n    max_elements = sorted_tup[-K:]\n    \n    return min_elements, max_elements"}
{"task_id": 220, "completion": "def replace_max_specialchar(text, n):\n    # Define the special characters to be replaced\n    special_chars = [' ', ',', '.']\n    # The number of replacements made so far\n    replacements = 0\n    \n    # Convert the text into a list of characters for easy manipulation\n    char_list = list(text)\n    \n    # Iterate over the list of characters\n    for i in range(len(char_list)):\n        # If the current character is special and we haven't reached the max replacements\n        if char_list[i] in special_chars and replacements < n:\n            # Replace with a colon\n            char_list[i] = ':'\n            replacements += 1\n\n    # Join the list back into a string\n    return ''.join(char_list)\n`"}
{"task_id": 221, "completion": "def first_even(nums):\n    for num in nums:\n        if num % 2 == 0:  # Checks if the number is even\n            return num  # Returns the first even number found\n    return None  # Return None if no even number is found in the list"}
{"task_id": 222, "completion": "def check_type(test_tuple):\n    # First, we check if the tuple is empty. If it's empty, we can say that, in a way, all \"elements\" have the same type\n    if not test_tuple:\n        return True\n    \n    # Getting the type of the first element\n    first_type = type(test_tuple[0])\n    \n    # Comparing each element's type with the first's\n    for element in test_tuple:\n        if type(element) != first_type:\n            return False\n            \n    return True"}
{"task_id": 223, "completion": "def is_majority(arr, n, x):\n    \"\"\"\n    Check if x is a majority element in a sorted array arr of size n. \n    \n    Parameters:\n    arr (list): The sorted array to check for the majority element.\n    n (int): The size of the array.\n    x (int): The element to check if it's a majority in the array.\n    \n    Returns:\n    bool: True if x is a majority element, False otherwise.\n    \"\"\"\n    \n    # Find the index of the first occurrence of x in arr\n    first_occurrence = find_first_occurrence(arr, 0, n-1, x)\n    \n    # If x is not in the array or if the position where x could\n    # achieve majority is beyond the array bounds, x cannot be a\n    # majority element.\n    if first_occurrence == -1 or first_occurrence + n // 2 >= n:\n        return False\n    \n    # If the element at the index where x should achieve majority is x,\n    # then x is a majority element.\n    if arr[first_occurrence + n // 2] == x:\n        return True\n    \n    return False"}
{"task_id": 224, "completion": "def count_Set_Bits(n):\n    # Initialize count to 0\n    count = 0\n    # Loop until n becomes 0\n    while n:\n        # Remove the rightmost set bit from n\n        n &= (n - 1)\n        # Increment count for each set bit removed\n        count += 1\n    # Return the total count of set bits\n    return count"}
{"task_id": 225, "completion": "def find_Min(arr, low, high):\n    # Base case: if the sub-array is not rotated or has only one element\n    if high < low:\n        return arr[0]\n    if high == low:\n        return arr[low]\n\n    # Find the mid index\n    mid = low + (high - low) // 2\n\n    # Check if element (mid+1) is the minimum element\n    if mid < high and arr[mid+1] < arr[mid]:\n        return arr[mid+1]\n\n    # Check if mid itself is the minimum element\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return arr[mid]\n\n    # Decide whether we need to go to left half or right half\n    if arr[high] > arr[mid]:\n        # If the last element is greater than the mid element, then the minimum\n        # element lies in the left half of the array\n        return find_Min(arr, low, mid-1)\n    else:\n        # Else the minimum element is in the right half of the array\n        return find_Min(arr, mid+1, high)"}
{"task_id": 226, "completion": "def odd_values_string(str):\n    # Use slicing to get characters at even indices (which are odd index values in human terms)\n    result = str[::2]\n    return result"}
{"task_id": 227, "completion": "def min_of_three(a, b, c):\n    # Check if a is smaller than both b and c\n    if a <= b and a <= c:\n        return a\n    # If not, check if b is smaller than c\n    elif b <= a and b <= c:\n        return b\n    # If a and b are not smaller, c must be the smallest\n    else:\n        return c"}
{"task_id": 228, "completion": "def all_Bits_Unset_In_The_Given_Range(n, l, r):\n    # Generate a mask that has all bits set in the range [l, r]\n    # To generate such a mask, we first create a mask with bits set from position 1 to r.\n    # Then, we create another mask with bits set from position 1 to l-1 and XOR them\n    # to get bits set only in the range [l, r].\n    mask = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1)\n    \n    # Invert the mask to target unset bits in the range\n    # This step is optional for this question because we're already checking for all bits being unset below\n    \n    # Use the mask to isolate bits in the given range of n and check if all those bits are unset\n    if n & mask == 0:\n        # If 'n' AND 'mask' equals 0, it means all bits in the given range are unset\n        return True\n    else:\n        # Otherwise, not all bits in the given range are unset\n        return False"}
{"task_id": 229, "completion": "def re_arrange_array(arr, n):\n    # Initialize left and right pointers\n    left = 0\n    right = n - 1\n\n    # Loop to traverse the array from both ends\n    while left < right:\n        # Move the left pointer forward while the elements are negative\n        while left < n and arr[left] < 0:\n            left += 1\n        # Move the right pointer backward while the elements are positive\n        while right >= 0 and arr[right] >= 0:\n            right -= 1\n        # Check if left is still less than right, then swap the elements\n        if left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n    \n    return arr"}
{"task_id": 230, "completion": "def replace_blank(str1, char):\n    # Replace blank spaces with the specified character\n    return str1.replace(' ', char)"}
{"task_id": 231, "completion": "def max_sum(tri, n):\n    \"\"\"\n    Finds the maximum sum from top to bottom in a right triangle\n    \n    :param tri: List of lists representing the triangle of numbers\n    :param n: Number of rows in the triangle\n    :return: Maximum sum from top to bottom\n    \"\"\"\n    # Start from the second last row and move upwards\n    for i in range(n-2, -1, -1):\n        for j in range(i+1):\n            # For each element, find the maximum of the two adjacent numbers in the row below and add it to the current element\n            tri[i][j] += max(tri[i+1][j], tri[i+1][j+1])\n\n    # The top element now contains the maximum sum\n    return tri[0][0]\n`"}
{"task_id": 232, "completion": "import heapq\n\ndef larg_nnum(list1, n):\n    # Using heapq.nlargest to get n largest numbers from list1\n    return heapq.nlargest(n, list1)"}
{"task_id": 233, "completion": "def lateral_surface_cylinder(r, h):\n    '''\n    Calculate the lateral surface area of a cylinder.\n    \n    Parameters:\n    r (float): The radius of the cylinder.\n    h (float): The height of the cylinder.\n    \n    Returns:\n    float: The lateral surface area of the cylinder.\n    '''\n    pi = 3.14159\n    lateral_surface_area = 2 * pi * r * h\n    return lateral_surface_area"}
{"task_id": 234, "completion": "def volume_cube(l):\n    \"\"\"\n    Calculate the volume of a cube.\n\n    Parameters:\n    l (float): The length of one side of the cube.\n\n    Returns:\n    float: The volume of the cube.\n    \"\"\"\n    # Calculate the volume of the cube\n    volume = l ** 3\n    return volume"}
{"task_id": 235, "completion": "def even_bit_set_number(n):\n    # Calculate the mask required by finding the most significant bit (MSB) of n\n    if n == 0:\n        return 1  # If n is 0, setting even bits would result in 1.\n    \n    # Initializing variables\n    mask = 0\n    i = 0\n    \n    # Loop to set all even bits in the mask up to the size of n\n    while (1 << i) <= n:\n        mask |= (1 << i)\n        i += 2  # Increment by 2 to ensure only even bits are included\n    \n    # Use the bitwise OR operator to set all even bits of `n`\n    result = n | mask\n    \n    return result\n"}
{"task_id": 236, "completion": "def No_of_Triangle(N, K):\n    # Calculate the total number of levels (or rows of smaller triangles)\n    # that fit in the larger triangle\n    total_levels = N - K + 1\n    \n    # Calculate the sum of squares of the total levels to get the total number of triangles\n    total_triangles = (total_levels * (total_levels + 1) * (2 * total_levels + 1)) // 6\n    \n    return total_triangles"}
{"task_id": 237, "completion": "def check_occurrences(test_list):\n    # Initialize a dictionary to count occurrences of each element\n    occurrences = {}\n    for tup in test_list:\n        for item in tup:\n            if item in occurrences:\n                occurrences[item] += 1\n            else:\n                occurrences[item] = 1\n    \n    # Initialize a dictionary to count how many elements have the same occurrences\n    similar_counts = {}\n    for count in occurrences.values():\n        if count in similar_counts:\n            similar_counts[count] += 1\n        else:\n            similar_counts[count] = 1\n            \n    # Create a list to store the counts of occurrences that appear more than once\n    result = [count for count, num_elements in similar_counts.items() if num_elements > 1]\n    \n    # Return the list of counts\n    return result\n`"}
{"task_id": 238, "completion": "def number_of_substrings(str):\n    n = len(str)\n    return n * (n + 1) // 2"}
{"task_id": 239, "completion": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    The main function to find the number of sequences.\n    m: the maximum allowed value for elements in the sequence.\n    n: the length of the sequence.\n    Returns the total count of valid sequences of length n.\n    \"\"\"\n    # Memoization storage\n    memo = {}\n    total_count = 0\n    for start in range(1, m + 1):\n        # For each starting number, calculate sequences of length `n`\n        total_count += get_total_number_of_sequences_rec(start, n, m, memo)\n    return total_count\n\ndef get_total_number_of_sequences_rec(start, n, m, memo):\n    \"\"\"\n    A helper recursive function to count the number of sequences.\n    start: the current starting number for sequences.\n    n: the remaining length of the sequence to be found.\n    m: the maximum allowed value for elements in the sequence.\n    memo: a dictionary for memoization to store intermediate results.\n    Returns the count of valid sequences from the given starting point.\n    \"\"\"\n    # Base case: If the sequence is of length 1, return 1 if the start is within limits, else 0\n    if n == 1:\n        return 1 if start <= m else 0\n    \n    # If the result is already computed, return it.\n    if (start, n) in memo:\n        return memo[(start, n)]\n    \n    count = 0\n    # Loop to pick the next element in the sequence\n    for next_start in range(start * 2, m + 1):\n        # Recurse for the next element in the sequence with one less element to find\n        count += get_total_number_of_sequences_rec(next_start, n - 1, m, memo)\n    \n    memo[(start, n)] = count\n    return count"}
{"task_id": 240, "completion": "def replace_list(list1, list2):\n    # Check if list1 is not empty\n    if list1:\n        # Remove the last element of list1\n        list1.pop()\n        # Extend list1 with all elements of list2\n        list1.extend(list2)\n    else:\n        # If list1 is empty, simply copy list2 into list1\n        list1.extend(list2)\n    return list1"}
{"task_id": 241, "completion": "def array_3d(m, n, o):\n    return [[['*' for _ in range(o)] for _ in range(n)] for _ in range(m)]"}
{"task_id": 242, "completion": "def count_charac(str1):\n    return len(str1)"}
{"task_id": 243, "completion": "def sort_on_occurrence(lst):\n    \"\"\"\n    Sorts a given list based on the occurrence of the first element of tuples within the list.\n    \n    Parameters:\n    lst (list): A list of tuples to be sorted.\n    \n    Returns:\n    list: Sorted list based on the occurrence of the first element of tuples.\n    \"\"\"\n    # Count occurrences of the first element of each tuple\n    occurrence_count = {}\n    for item in lst:\n        if item[0] in occurrence_count:\n            occurrence_count[item[0]] += 1\n        else:\n            occurrence_count[item[0]] = 1\n            \n    # Sort the list based on the occurrence, using the occurrence count\n    sorted_list = sorted(lst, key=lambda x: occurrence_count[x[0]])\n    \n    return sorted_list\n`"}
{"task_id": 244, "completion": "import math\n\ndef next_Perfect_Square(N):\n    # First, find the square root of N\n    sqrt_N = math.sqrt(N)\n    \n    # Then, take the ceiling of sqrt_N to get the next integer\n    next_int = math.ceil(sqrt_N)\n    \n    # The next perfect square is the square of this integer\n    next_perfect_square = next_int ** 2\n    \n    return next_perfect_square"}
{"task_id": 245, "completion": "def max_sum(arr, n):\n    # Step 1: Calculate increasing sum up to each element.\n    inc = [0]*n\n    for i in range(n):\n        inc[i] = arr[i]  # Initialize with the element itself.\n        for j in range(i):\n            if arr[i] > arr[j] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n    \n    # Step 2: Calculate decreasing sum from each element to the end.\n    dec = [0]*n\n    for i in reversed(range(n)):\n        dec[i] = arr[i]  # Initialize with the element itself.\n        for j in range(i+1, n):\n            if arr[i] > arr[j] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n    \n    # Step 3: Calculate maximum sum of bitonic subsequence.\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])  # Subtract arr[i] to avoid double counting.\n    \n    return max_sum"}
{"task_id": 246, "completion": "def babylonian_sqrt(number, tolerance=1e-10):\n    \"\"\"\n    Compute the square root of a number using the Babylonian (Heron's) method.\n\n    Parameters:\n    - number: The number to compute the square root of.\n    - tolerance: The tolerance for the difference in successive guess values.\n                  Default is set to 1e-10.\n\n    Returns:\n    The approximate square root of 'number'.\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Cannot compute the square root of a negative number.\")\n    \n    # Starting guess\n    x = number / 2\n    \n    while True:\n        # New guess\n        new_x = 0.5 * (x + number / x)\n        \n        # Check if the difference between the old and new guess is within the tolerance\n        if abs(new_x - x) < tolerance:\n            break\n        \n        # Update the guess for the next iteration\n        x = new_x\n    \n    return x"}
{"task_id": 247, "completion": "def lps(str):\n    n = len(str)\n\n    # Create a table to store results of subproblems\n    dp = [[0 for x in range(n)] for y in range(n)]\n\n    # Strings of length 1 are palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n\n    # Build the table. Note that the lower diagonal values of table are\n    # useless and not filled in the process. The table is filled in a\n    # bottom-up manner such that table[i][j] contains length of LPS\n    # of substring str[i..j].\n\n    for cl in range(2, n + 1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if str[i] == str[j] and cl == 2:\n                dp[i][j] = 2\n            elif str[i] == str[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n\n    # length of longest palindromic subseq\n    return dp[0][n - 1]"}
{"task_id": 248, "completion": "def harmonic_sum(n):\n    # Initialize sum to 0\n    harmonic_sum = 0\n\n    # Loop through from 1 to n-1\n    for i in range(1, n):\n        harmonic_sum += 1 / i\n    \n    return harmonic_sum"}
{"task_id": 249, "completion": "def intersection_array(array_nums1, array_nums2):\n    # Using filter() to apply a lambda function that checks for common elements\n    result = list(filter(lambda x: x in array_nums2, array_nums1))\n    return result"}
{"task_id": 250, "completion": "def count_X(tup, x):\n    # Count and return the occurrences of x in tup\n    count = tup.count(x)\n    return count"}
{"task_id": 251, "completion": "def insert_element(input_list, element):\n    \"\"\"\n    Insert an element before each element of a list.\n    \n    Parameters:\n    - input_list: A list of elements where the new element will be inserted before each.\n    - element: The element to insert before each element in the input list.\n    \n    Returns:\n    - A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in input_list:\n        result.append(element)\n        result.append(item)\n    return result"}
{"task_id": 252, "completion": "import cmath\n\ndef convert_to_polar(complex_num):\n    # Converting complex number to polar coordinates\n    polar_coordinates = cmath.polar(complex_num)\n    return polar_coordinates"}
{"task_id": 253, "completion": "def count_integer(list1):\n    count = 0  # Initialize a counter to keep track of integers\n    for element in list1:\n        if isinstance(element, int):  # Check if the element is an integer\n            count += 1  # Increment the counter\n    return count  # Return the final count"}
{"task_id": 254, "completion": "def words_ae(text):\n    # Split the text into words\n    words = text.split()\n    \n    # Initialize an empty list to hold words starting with 'a' or 'e'\n    selected_words = []\n    \n    # Loop through each word in the list\n    for word in words:\n        # Check if the word starts with 'a' or 'e'\n        if word.lower().startswith(('a', 'e')):\n            # If it does, add it to the list of selected words\n            selected_words.append(word)\n    \n    # Return the list of selected words\n    return selected_words"}
{"task_id": 255, "completion": "import itertools\n\ndef combinations_colors(l, n):\n    # Check if the length of l is indeed 3 to ensure it contains three different colors.\n    if len(l) != 3:\n        raise ValueError(\"The color list must contain exactly three different colors\")\n    \n    # Use itertools.product to get all combinations with repetitions.\n    # itertools.product(*iterables, repeat=n) will give the desired result.\n    combinations = list(itertools.product(l, repeat=n))\n    \n    # Each element in combinations is a tuple, so you might want to format the output.\n    # For example, converting each tuple into a list (if desired) or just outputting as is.\n    formatted_combinations = [list(comb) for comb in combinations]\n    \n    return formatted_combinations"}
{"task_id": 256, "completion": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0  # There are no prime numbers less than 2\n\n    # Initialize a list to identify prime numbers\n    is_prime = [True] * n  \n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as non-prime\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n\n    # Count and return the number of prime numbers\n    return sum(is_prime)"}
{"task_id": 257, "completion": "def swap_numbers(a, b):\n    # Swap the numbers using a temporary variable\n    temp = a\n    a = b\n    b = temp\n    return a, b"}
{"task_id": 258, "completion": "def count_odd(array_nums):\n    # Using filter to apply a lambda function that checks for odd numbers.\n    # The lambda function returns True for odd numbers.\n    # Then, convert the filter object to a list and find its length.\n    count = len(list(filter(lambda x: (x % 2 != 0), array_nums)))\n    return count"}
{"task_id": 259, "completion": "def maximize_elements(test_tup1, test_tup2):\n    \"\"\"\n    Function to maximize elements between two tuples, element-wise.\n    \n    Parameters:\n    - test_tup1: First input tuple.\n    - test_tup2: Second input tuple.\n    \n    Returns:\n    - A new tuple with each element being the maximum of the elements at the corresponding position\n      in the input tuples.\n    \"\"\"\n    \n    # Using the zip function to iterate over both tuples simultaneously\n    # and the max function to select the maximum between each pair of elements.\n    # The result is a generator of maximum elements, which is then converted into a tuple.\n    max_tup = tuple(max(a, b) for a, b in zip(test_tup1, test_tup2))\n    \n    return max_tup\n`"}
{"task_id": 260, "completion": "def newman_prime(n):\n    count = 0\n    i = 0\n    while True:\n        nsw_number = generate_nsw_number(i)\n        if is_prime(nsw_number):\n            count += 1\n            if count == n:\n                return nsw_number\n        i += 1\n"}
{"task_id": 261, "completion": "def division_elements(test_tup1, test_tup2):\n    \"\"\"\n    Performs element-wise division between two tuples.\n\n    Parameters:\n    - test_tup1 (tuple of int/float): The numerator tuple.\n    - test_tup2 (tuple of int/float): The denominator tuple.\n\n    Returns:\n    Tuple: A tuple resulting from element-wise division of test_tup1 by test_tup2.\n    \"\"\"\n    result = ()\n    for num1, num2 in zip(test_tup1, test_tup2):\n        # Check if the denominator is 0 to avoid division by zero error\n        if num2 == 0:\n            print(\"Error: Division by 0 encountered.\")\n            result += (None,)  # You could also choose to add 0 or some other placeholder value\n        else:\n            result += (num1 / num2,)\n    return result"}
{"task_id": 262, "completion": "def split_two_parts(list1, L):\n    # Splitting the list into two parts\n    # The first part consists of the first L elements\n    # The second part consists of the remaining elements\n    first_part = list1[:L]\n    second_part = list1[L:]\n    \n    return first_part, second_part"}
{"task_id": 263, "completion": "def merge_dict(d1, d2):\n    # This method works in both Python 2 and Python 3\n    merged = d1.copy()  # Create a copy of the first dictionary\n    merged.update(d2)   # Update the copy with the second dictionary\n    return merged"}
{"task_id": 264, "completion": "def dog_age(h_age):\n    # Assuming 1 human year equals 7 dog years\n    dog_years = h_age * 7\n    return dog_years"}
{"task_id": 265, "completion": "def list_split(S, step):\n    # Check if the step is valid\n    if step <= 0:\n        raise ValueError(\"Step must be greater than 0\")\n        \n    # Split the list\n    return [S[i:i + step] for i in range(0, len(S), step)]"}
{"task_id": 266, "completion": "def lateral_surface_area_cube(l):\n    # Calculate lateral surface area for a cube\n    lateral_surface_area = 4 * l**2\n    return lateral_surface_area"}
{"task_id": 267, "completion": "def square_sum(n):\n    # Initialize sum\n    sum_of_squares = 0\n    \n    # Generate and sum squares of first n odd natural numbers\n    for i in range(1, 2 * n, 2):  # Starting from 1, getting every odd number\n        sum_of_squares += i**2\n\n    return sum_of_squares"}
{"task_id": 268, "completion": "def find_star_num(n):\n    # Calculate the nth star number using the formula\n    return 6 * n * (n - 1) + 1"}
{"task_id": 269, "completion": "def ascii_value(k):\n    # Ensure k is a single character\n    if len(k) != 1:\n        return \"Please provide a single character.\"\n    # Return ASCII value using ord()\n    return ord(k)"}
{"task_id": 270, "completion": "def sum_even_and_even_index(arr, n):\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Loop through the elements with even indices\n    for i in range(0, n, 2): # Start from 0, go till n, in steps of 2\n        # Check if the element at the even index is even\n        if arr[i] % 2 == 0:\n            # Add even elements found at even index to total sum\n            total_sum += arr[i]\n    \n    # Return the total sum\n    return total_sum"}
{"task_id": 271, "completion": "def even_Power_Sum(n):\n    return sum([(2 * i) ** 5 for i in range(1, n+1)])"}
{"task_id": 272, "completion": "def rear_extract(test_list):\n    \"\"\"\n    Function to extract the rear element from each tuple in the list.\n    \n    Parameters:\n    - test_list: List of tuples\n    \n    Return:\n    - List containing the last element from each tuple in the original list.\n    \"\"\"\n    # Using list comprehension to iterate and extract the last element of each tuple\n    return [item[-1] for item in test_list]"}
{"task_id": 273, "completion": "def subtract_elements(test_tup1, test_tup2):\n    \"\"\"\n    Subtracts the elements of one tuple from the corresponding elements of another tuple.\n\n    Parameters:\n    test_tup1 (tuple): The first tuple.\n    test_tup2 (tuple): The second tuple, from which values will be subtracted.\n\n    Returns:\n    tuple: A new tuple with the results of the subtraction.\n    \"\"\"\n    if len(test_tup1) != len(test_tup2):\n        raise ValueError(\"Both tuples must have the same number of elements\")\n    \n    # Creating a new tuple by subtracting corresponding elements of test_tup2 from test_tup1\n    result = tuple(a - b for a, b in zip(test_tup1, test_tup2))\n    \n    return result"}
{"task_id": 274, "completion": "def even_binomial_coeff_sum(n):\n    \"\"\"Sum of even index binomial coefficients.\"\"\"\n    result = sum(binomial_coeff(n, k) for k in range(0, n + 1, 2))\n    return result"}
{"task_id": 275, "completion": "def get_Position(a, n, m):\n    \"\"\"\n    Finds the position of the mth removed element.\n    \n    :param a: List from which elements are being removed.\n    :param n: The initial number of elements in the list.\n    :param m: The 1-based index of the removal step to find the last element's initial position for.\n\n    :return: The original position (1-based index) of the mth removed element.\n    \"\"\"\n    # Check if the removal count is within the range of the list\n    if m > n or m < 1:\n        return \"Invalid removal step\"\n    \n    # In this simple example, elements are removed from the start,\n    # so the position of the mth removed element is just m.\n    \n    # For other removal patterns, the logic here will need to be adjusted.\n    return m"}
{"task_id": 276, "completion": "import math\n\ndef volume_cylinder(r, h):\n    \"\"\"\n    Calculate the volume of a cylinder.\n\n    Parameters:\n    r (float): Radius of the cylinder's base.\n    h (float): Height of the cylinder.\n\n    Returns:\n    float: Volume of the cylinder.\n    \"\"\"\n    volume = math.pi * (r ** 2) * h\n    return volume"}
{"task_id": 277, "completion": "def dict_filter(input_dict, n):\n    \"\"\"\n    Filters a dictionary based on its values.\n\n    Args:\n    - input_dict (dict): The dictionary to filter.\n    - n (int or float): The threshold used to filter the dictionary values.\n\n    Returns:\n    - dict: A dictionary containing key-value pairs where the values meet the specified condition.\n    \"\"\"\n    # Using a dictionary comprehension to filter out items based on the condition\n    filtered_dict = {key: value for key, value in input_dict.items() if value > n}\n    \n    return filtered_dict\n`"}
{"task_id": 278, "completion": "def count_first_elements(test_tup, record):\n    \"\"\"\n    Counts the elements occurring before a given 'record' in the tuple.\n\n    Parameters:\n    - test_tup: The tuple to search through.\n    - record: The record value to find in the tuple.\n\n    Returns:\n    - The count of elements before the record. If the record is not found,\n      returns the length of the tuple. If the tuple is empty or the record\n      is at the first position, returns 0.\n    \"\"\"\n    try:\n        # Find the index of the record value\n        record_index = test_tup.index(record)\n        # Count elements before the record\n        return record_index\n    except ValueError:\n        # If record is not in the tuple\n        return len(test_tup)\n`"}
{"task_id": 279, "completion": "def is_num_decagonal(n):\n    # Calculate the nth decagonal number\n    decagonal_number = 4 * n**2 - 3 * n\n    return decagonal_number"}
{"task_id": 280, "completion": "def sequential_search(dlist, item):\n    \"\"\"\n    Searches for an item in dlist using sequential search.\n    \n    Parameters:\n    - dlist : List where to search the item.\n    - item : The item to search for.\n    \n    Returns:\n    True if item is found, False otherwise.\n    \"\"\"\n    # Go through each element in dlist\n    for i in range(len(dlist)):\n        # If the current element matches the item, return True\n        if dlist[i] == item:\n            return True\n    # If we reach here, the item was not found\n    return False\n`"}
{"task_id": 281, "completion": "def all_unique(test_list):\n    return len(test_list) == len(set(test_list))\n`"}
{"task_id": 282, "completion": "def sub_list(nums1, nums2):\n    # Use map with a lambda function to subtract corresponding elements from the two lists\n    result = list(map(lambda x, y: x - y, nums1, nums2))\n    return result\n`"}
{"task_id": 283, "completion": "def validate(n):\n    # Convert the integer to a string for easy iteration\n    n_str = str(n)\n    \n    # Create a dictionary to count the occurrence of each digit\n    digit_count = {}\n    \n    for digit in n_str:\n        # Increase the count of the digit in the dictionary\n        if digit in digit_count:\n            digit_count[digit] += 1\n        else:\n            digit_count[digit] = 1\n    \n    # Check if the frequency of each digit is less than or equal to the digit itself\n    for digit, count in digit_count.items():\n        if count > int(digit):\n            # If the condition fails for any digit, return False\n            return False\n    \n    # If condition holds for all digits, return True\n    return True\n`"}
{"task_id": 284, "completion": "def check_element(list, element):\n    # Iterate through each item in the list\n    for item in list:\n        # If any item is not equal to the element, return False\n        if item != element:\n            return False\n    # If the loop completes without returning False, it means all items are equal to the element\n    return True"}
{"task_id": 285, "completion": "def text_match_two_three(text):\n    \"\"\"\n    Matches a string that contains an 'a' followed by two to three 'b's\n    \n    Parameters:\n    - text (str): The string to be searched.\n    \n    Returns:\n    - bool: True if the pattern is found in the string, False otherwise.\n    \"\"\"\n    pattern = r'ab{2,3}'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False"}
{"task_id": 286, "completion": "def max_sub_array_sum_repeated(a, n, k):\n    def kadane_algorithm(arr):\n        max_so_far = arr[0]\n        max_ending_here = arr[0]\n\n        for i in range(1, len(arr)):\n            max_ending_here = max(arr[i], max_ending_here + arr[i])\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n    \n    array_sum = sum(a)\n    max_sub_array_sum = kadane_algorithm(a)\n    \n    if k == 1:\n        return max_sub_array_sum\n    \n    extended_array = a * 2\n    max_sub_array_sum_extended = kadane_algorithm(extended_array)\n    \n    if array_sum > 0:\n        return max(max_sub_array_sum_extended, max_sub_array_sum + (array_sum * (k - 2)))\n    else:\n        return max_sub_array_sum_extended\n`"}
{"task_id": 287, "completion": "def square_sum(n):\n    sum = 0\n    even_num = 2\n    for _ in range(n):\n        sum += even_num ** 2\n        even_num += 2\n    return sum"}
{"task_id": 288, "completion": "def modular_inverse(arr, N, P):\n    # Count occurrences of 1 and P-1 in arr\n    count_self_inverse = sum(1 for x in arr if x == 1 or x == (P - 1))\n    \n    return count_self_inverse"}
{"task_id": 289, "completion": "def odd_days(N):\n    \"\"\"Calculate the number of odd days in given year N.\"\"\"\n    # Check if the year is leap year\n    if is_leap(N):\n        return 2  # 2 odd days in a leap year\n    else:\n        return 1  # 1 odd day in a common year"}
{"task_id": 290, "completion": "def max_length(lists):\n    \"\"\"\n    Find the list of lists with the maximum length.\n\n    :param lists: List of lists\n    :return: List containing all lists of the maximum length\n    \"\"\"\n    # Find the maximum length of the sublists\n    max_len = max(len(sublist) for sublist in lists)\n    \n    # Find all sublists that have this maximum length\n    max_lists = [sublist for sublist in lists if len(sublist) == max_len]\n    \n    return max_lists"}
{"task_id": 291, "completion": "def count_no_of_ways(n, k):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return k\n    elif n == 2:\n        return k * k\n\n    diff = [0] * n\n    same = [0] * n\n    total = [0] * n\n\n    # Base cases\n    diff[0] = k\n    same[0] = 0\n    total[0] = k\n\n    diff[1] = k * (k - 1)\n    same[1] = k\n    total[1] = k * k\n\n    # Fill in the arrays based on recurrence relations\n    for i in range(2, n):\n        diff[i] = total[i-1] * (k-1)\n        same[i] = diff[i-1] * 1\n        total[i] = diff[i] + same[i]\n\n    return total[-1]"}
{"task_id": 292, "completion": "def find(n, m):\n    # Check if the divisor is 0, to avoid division by zero error\n    if m == 0:\n        print(\"Error: Division by zero is not allowed.\")\n        return None\n    else:\n        return n / m"}
{"task_id": 293, "completion": "import math\n\ndef otherside_rightangle(w, h, is_hypotenuse=False):\n    \"\"\"\n    Finds the length of the third side of a right-angled triangle.\n\n    :param w: Length of one side.\n    :param h: Length of the other side.\n    :param is_hypotenuse: Flag indicating whether the hypotenuse (True) or a leg (False) is sought.\n                          Default is False, assuming w and h are the lengths of the legs.\n    :return: Length of the third side.\n    \"\"\"\n    if is_hypotenuse:\n        # If one of w or h is the hypotenuse, find the leg.\n        if w > h:\n            # w is the hypotenuse.\n            return math.sqrt(w**2 - h**2)\n        else:\n            # h is the hypotenuse.\n            return math.sqrt(h**2 - w**2)\n    else:\n        # If w and h are the legs, find the hypotenuse.\n        return math.sqrt(w**2 + h**2)"}
{"task_id": 294, "completion": "def max_val(listval):\n    # Initialize a variable to store the maximum numeric value found\n    # Initially set to None to handle cases where no numeric values are present\n    max_numeric_val = None\n\n    for val in listval:\n        # Check if the current item is of a numeric type (integer or float)\n        if isinstance(val, (int, float)):\n            # If it's the first numeric value found or greater than the current max, update max_numeric_val\n            if max_numeric_val is None or val > max_numeric_val:\n                max_numeric_val = val\n\n    return max_numeric_val"}
{"task_id": 295, "completion": "def sum_div(number):\n    # Initialize the sum of divisors\n    sum_of_divisors = 0\n    \n    # Iterate from 1 to number (inclusive)\n    for i in range(1, number + 1):\n        # If i is a divisor of number\n        if number % i == 0:\n            # Add it to the sum\n            sum_of_divisors += i\n            \n    # Return the sum of all divisors\n    return sum_of_divisors"}
{"task_id": 296, "completion": "def mergeSort(arr, temp_arr, left, right):\n    \"\"\"Utilizes merge sort algorithm to sort the array and count inversions.\"\"\"\n    inv_count = 0\n    if left < right:\n        # Find the middle point to divide the array into two halves\n        mid = (left + right) // 2\n\n        # Count inversions in the left half and sort it\n        inv_count += mergeSort(arr, temp_arr, left, mid)\n\n        # Count inversions in the right half and sort it\n        inv_count += mergeSort(arr, temp_arr, mid + 1, right)\n\n        # Merge the two halves and count inversions during merge\n        inv_count += merge(arr, temp_arr, left, mid, right)\n    \n    return inv_count\n\ndef merge(arr, temp_arr, left, mid, right):\n    \"\"\"Merge two subarrays of arr[] and count inversions.\"\"\"\n    i = left       # Initial index of first subarray\n    j = mid + 1    # Initial index of second subarray\n    k = left       # Initial index of merged subarray\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            # Inversion will occur\n            temp_arr[k] = arr[j]\n            inv_count += (mid-i + 1)\n            k += 1\n            j += 1\n\n    # Copy the remaining elements of left subarray into temp_arr, if there are any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n\n    # Copy the remaining elements of right subarray into temp_arr, if there are any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n        \n    return inv_count\n\ndef get_Inv_Count(arr):\n    \"\"\"Count the number of inversions to sort the array.\"\"\"\n    n = len(arr)  # Length of the array\n    temp_arr = [0]*n\n    return mergeSort(arr, temp_arr, 0, n-1)"}
{"task_id": 297, "completion": "def flatten_list(nested_list):\n    \"\"\"\n    Flattens a given nested list structure.\n\n    Parameters:\n    nested_list (list): The list to flatten.\n\n    Returns:\n    list: A new flattened list.\n    \"\"\"\n    flattened_list = []\n    \n    # Define a helper function that will be called recursively\n    def _flatten(item):\n        # If the item is a list, we need to flatten it\n        if isinstance(item, list):\n            for sub_item in item:\n                _flatten(sub_item)  # Recursion for items within the list\n        else:\n            # If it's not a list, simply append it to the result\n            flattened_list.append(item)\n    \n    # Kick-off the flattening process\n    _flatten(nested_list)\n    return flattened_list"}
{"task_id": 298, "completion": "def intersection_nested_lists(l1, l2):\n    def is_list(value):\n        \"\"\"Check if the value is a list.\"\"\"\n        return isinstance(value, list)\n    \n    def check_intersection(n1, n2):\n        \"\"\"Check for intersection between two nested elements.\"\"\"\n        if is_list(n1) and is_list(n2):\n            # Recursive case: both elements are lists.\n            return any(check_intersection(inner_n1, inner_n2) for inner_n1 in n1 for inner_n2 in n2)\n        else:\n            # Base case: at least one of the elements is not a list.\n            return n1 == n2\n    \n    # Initialize an empty list to store the intersection result.\n    intersection_results = []\n    \n    # Iterate through the first and second list to find intersections.\n    for element1 in l1:\n        for element2 in l2:\n            if check_intersection(element1, element2):\n                # If there's an intersection, add it to the results.\n                # This avoids duplicates in the result.\n                if element1 not in intersection_results:\n                    intersection_results.append(element1)\n    \n    return intersection_results"}
{"task_id": 299, "completion": "def max_aggregate(stdata):\n    # Initialize a variable to store the maximum aggregate\n    max_agg = 0\n\n    # Iterate through each tuple in the list\n    for data in stdata:\n        # Calculate the aggregate (sum) of the current tuple\n        agg = sum(data)\n\n        # Check if the current aggregate is greater than the current maximum aggregate\n        if agg > max_agg:\n            # Update the maximum aggregate\n            max_agg = agg\n\n    # Return the maximum aggregate after iterating through all tuples    \n    return max_agg"}
{"task_id": 300, "completion": "def count_binary_seq(n):\n    \"\"\"\n    Return the count of all binary sequences of length 2n such that sum of \n    first n bits is same as sum of last n bits.\n    \"\"\"\n    if n % 2 != 0:\n        return 0  # Assuming n needs to be even as explained.\n    half_n = n // 2\n    return binomial_coefficient(n, half_n)**2  # Square the count for the first half to match with second half.\n`"}
{"task_id": 301, "completion": "def dict_depth(d, level=1):\n    \"\"\"\n    Function to find the depth of a dictionary.\n    \n    Parameters:\n    d (dict): The dictionary for which we are finding the depth.\n    level (int): The current depth level, defaults to 1 since a non-nested dictionary has a depth of 1.\n    \n    Returns:\n    int: The depth of the dictionary.\n    \"\"\"\n    if not isinstance(d, dict) or not d:\n        return level\n    return max(dict_depth(v, level + 1) for k, v in d.items())"}
{"task_id": 302, "completion": "def set_Bit_Number(n):\n    # Edge case: if n is 0, return 0 as there are no set bits\n    if n == 0:\n        return 0\n\n    # Initialize msb (most significant bit) to 0\n    msb = 0\n\n    # Loop until n becomes 0\n    while n > 0:\n        # Right shift n by 1; effectively dividing n by 2\n        n = n // 2\n\n        # Increment msb position for each shift\n        msb += 1\n\n    # Once we find the position, we calculate the value of that bit\n    # Note that msb starts from 1 for the rightmost bit, hence we subtract 1 to get the 0-based index\n    return 1 << (msb - 1)\n`"}
{"task_id": 303, "completion": "def count_inversions_of_two_types(a):\n    n = len(a)\n    type1_inversions = 0\n    type2_inversions = 0\n    \n    # Count Type 1 Inversions\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                type1_inversions += 1\n    \n    # Count Type 2 Inversions\n    for i in range(n - 2):  \n        if a[i] > a[i + 2]:\n            type2_inversions += 1\n            \n    return type1_inversions == type2_inversions\n`"}
{"task_id": 304, "completion": "def find_Element(arr, ranges, rotations, index):\n    \"\"\"\n    Finds the element at a given index after performing a number of rotations on an array.\n\n    Parameters:\n    arr (list): The list of elements.\n    ranges (list of tuples): Rotation ranges, where each tuple (L, R) represents the start and end indices for the rotation.\n    rotations (int): The number of rotations to apply.\n    index (int): The index of the element to find after rotations.\n\n    Returns:\n    int: The element at the given index after the rotations.\n    \"\"\"\n\n    # Reverse iterate over the rotation ranges to trace the original position of the index\n    for _ in range(rotations):\n        for start, end in reversed(ranges):\n            # Check if the index is within the current rotation range\n            if start <= index <= end:\n                # If index is the start of the range, it moves to the end, else it moves one position to the left\n                if index == start:\n                    index = end\n                else:\n                    index -= 1\n\n    # Return the element at the calculated index position\n    return arr[index]\n`"}
{"task_id": 305, "completion": "def start_withp(words):\n    # List to hold words starting with 'p'\n    p_words = []\n\n    # Loop through each word in the list\n    for word in words:\n        # Check if the word starts with 'p'\n        if word.lower().startswith('p'):\n            p_words.append(word)\n            # If we have found 2 words, we can stop the search\n            if len(p_words) == 2:\n                break\n    \n    # Check if we have found at least 2 words starting with 'p'\n    if len(p_words) < 2:\n        return \"Less than two words start with 'p'.\"\n    else:\n        return p_words\n`"}
{"task_id": 306, "completion": "def preprocess(a, n):\n    # Initialize dp array where dp[i] represents the maximum\n    # sum of the increasing subsequence ending with a[i]\n    dp = [0] * n\n    dp[0] = a[0]\n    \n    for i in range(1, n):\n        dp[i] = a[i]  # Initial case, subsequence contains only itself\n        for j in range(0, i):\n            if a[i] > a[j]:  # If a[i] can be appended to the subsequence ending with a[j]\n                dp[i] = max(dp[i], dp[j] + a[i])  # Choose the max sum possibility\n    \n    return dp\n\ndef max_sum_increasing_subseq(a, n, index, k):\n    # Preprocess to get max sum increasing subsequences ending at all indexes\n    dp = preprocess(a, n)\n    \n    # The maximum sum for increasing subsequence up to 'index' that can include a[k] afterwards\n    max_sum = 0\n    for i in range(index + 1):\n        if a[i] < a[k]:\n            max_sum = max(max_sum, dp[i])\n    \n    return max_sum + a[k]  # Add a[k] to the max sum found"}
{"task_id": 307, "completion": "def colon_tuplex(tuplex, m, n):\n    \"\"\"\n    Extracts a portion of a tuple from index m to n (including m, excluding n).\n\n    Parameters:\n    tuplex (tuple): The original tuple.\n    m (int): The start index of the portion to extract.\n    n (int): The end index (exclusive) of the portion to extract.\n\n    Returns:\n    tuple: The extracted portion of the tuple.\n    \"\"\"\n    # Slicing the tuple from index m to n (n is exclusive).\n    result = tuplex[m:n]\n    return result"}
{"task_id": 308, "completion": "def large_product(nums1, nums2, N):\n    # Generate all possible products\n    products = [x*y for x in nums1 for y in nums2]\n    \n    # Sort the list of products in descending order to get the largest products first\n    sorted_products = sorted(products, reverse=True)\n    \n    # Select the top N products. If N is larger than the length of the product list,\n    # it will return all products sorted in descending order\n    return sorted_products[:N]"}
{"task_id": 309, "completion": "def maximum(a, b):\n    if a > b:\n        return a\n    else:\n        return b"}
{"task_id": 310, "completion": "def string_to_tuple(str1):\n    # Convert string to tuple by using tuple() constructor\n    return tuple(str1)"}
{"task_id": 311, "completion": "def set_left_most_unset_bit(n):\n    # Special case for n=0, directly return 1 since the left-most unset bit is the first bit.\n    if n == 0:\n        return 1\n    \n    # Initialize the mask as 1, which will be used to check each bit starting from the least significant bit.\n    mask = 1\n    temp = n\n    \n    # Move through each bit of the number.\n    while temp & mask:\n        mask = mask << 1\n\n    # Set the left-most unset bit to 1.\n    return n | mask"}
{"task_id": 312, "completion": "import math\n\ndef volume_cone(r, h):\n    # Calculate the volume of the cone and return it\n    volume = (1/3) * math.pi * r**2 * h\n    return volume\n`"}
{"task_id": 313, "completion": "def pos_nos(list1):\n    # Loop through each number in the list\n    for num in list1:\n        # Check if the current number is positive\n        if num > 0:\n            print(num)"}
{"task_id": 314, "completion": "def max_sum_rectangular_grid(grid, n):\n    \"\"\"\n    Find out the maximum sum in a 2 x n grid such that no two chosen\n    numbers are adjacent.\n    \"\"\"\n    # dp array to store the maximum sum till the ith column\n    dp = [0] * (n + 1)\n    \n    # Base cases for the first column\n    if n > 0:\n        dp[1] = max(grid[0][0], grid[1][0])\n    \n    for i in range(2, n + 1):\n        # For the ith column, we have three choices:\n        # 1. Pick the top cell; add it to the max sum till (i-2)th column (dp[i-2])\n        # 2. Pick the bottom cell; add it to the max sum till (i-2)th column (dp[i-2])\n        # 3. Don't pick any cell; just take the max sum till the (i-1)th column (dp[i-1])\n        \n        # Max sum if we pick the top cell\n        top_pick = grid[0][i-1] + dp[i-2]\n        \n        # Max sum if we pick the bottom cell\n        bottom_pick = grid[1][i-1] + dp[i-2]\n\n        # Choose the best option among the three choices\n        dp[i] = max(dp[i-1], top_pick, bottom_pick)\n        \n    return dp[n]\n`"}
{"task_id": 315, "completion": "def find_Max_Len_Even(str):\n    # Splitting the input string into words\n    words = str.split()\n    \n    # Initialize variables to store the maximum length found and the word\n    max_length = 0\n    max_word = None\n    \n    for word in words:\n        # Check if the current word's length is even and greater than the max_length found so far\n        if len(word) % 2 == 0 and len(word) > max_length:\n            max_length = len(word)\n            max_word = word\n    \n    return max_word"}
{"task_id": 316, "completion": "def find_last_occurrence(A, x):\n    \"\"\"\n    Finds the last occurrence of a given number x in a sorted array A\n    and returns its index. If x is not found in A, returns -1.\n    \"\"\"\n    low, high = 0, len(A) - 1\n    result = -1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        \n        if x < A[mid]:\n            high = mid - 1\n        elif x > A[mid]:\n            low = mid + 1\n        else:\n            result = mid\n            low = mid + 1  # Keep searching to the right\n    \n    return result"}
{"task_id": 317, "completion": "def modified_encode(alist):\n    if not alist:  # If the list is empty\n        return []\n\n    encoded_list = []\n    current_element = alist[0]\n    count = 1\n\n    for i in range(1, len(alist)):\n        if alist[i] == current_element:\n            count += 1\n        else:\n            # Once you encounter a different element, check the count\n            # If count is more than 1, append it as a tuple\n            if count > 1:\n                encoded_list.append((count, current_element))\n            else:  # If count is 1, append the element itself\n                encoded_list.append(current_element)\n\n            current_element = alist[i]\n            count = 1\n\n    # After exiting the loop, need to add the last element or tuple\n    if count > 1:\n        encoded_list.append((count, current_element))\n    else:\n        encoded_list.append(current_element)\n\n    return encoded_list\n`"}
{"task_id": 318, "completion": "def max_volume(s):\n    # Calculate the length of one side since they are all equal for maximum volume\n    side_length = s / 12\n    \n    # Calculate the volume of the cuboid\n    volume = side_length ** 3\n    \n    return volume"}
{"task_id": 319, "completion": "import re\n\ndef find_long_word(text):\n    # This regex looks for word boundaries (\\b),\n    # followed by exactly 5 word characters (\\w{5}),\n    # followed by another word boundary.\n    pattern = r'\\b\\w{5}\\b'\n    # Find all matches of the pattern in the text and return them\n    return re.findall(pattern, text)"}
{"task_id": 320, "completion": "def sum_difference(n):\n    # Calculate squared sum of first n natural numbers\n    squared_sum = (n * (n + 1) // 2) ** 2\n    \n    # Calculate sum of squared first n natural numbers\n    sum_of_squares = (n * (n + 1) * (2 * n + 1)) // 6\n    \n    # Calculate the difference\n    difference = squared_sum - sum_of_squares\n    \n    return difference\n`"}
{"task_id": 321, "completion": "def find_demlo(n):\n    \"\"\"\n    Finds the Demlo number for the given number n.\n    \n    :param n: Integer value representing the length of the series of 1s\n    :return: The Demlo number as an integer\n    \"\"\"\n    # Generating the number consisting of n 1's\n    number_of_ones = int('1' * n)\n    \n    # Calculating the Demlo number by squaring the number of 1's\n    demlo_number = number_of_ones ** 2\n    \n    return demlo_number"}
{"task_id": 322, "completion": "def position_min(list1):\n    # Step 1: Find the minimum value in the list\n    if not list1:  # Check if the list is empty\n        return []  # Return an empty list if the input list is empty\n    min_value = min(list1)\n  \n    # Step 2: Find all indices where this minimum value occurs\n    min_indices = []\n    for index, value in enumerate(list1):\n        if value == min_value:\n            min_indices.append(index)\n  \n    # Step 3: Return the list of indices\n    return min_indices"}
{"task_id": 323, "completion": "def right_rotate(arr, n, out_of_place, cur):\n    temp = arr[cur]\n    for i in range(cur, out_of_place, -1):\n        arr[i] = arr[i - 1]\n    arr[out_of_place] = temp\n    return arr"}
{"task_id": 324, "completion": "def sum_of_alternates(input_tuple):\n    # Initialize sums of even and odd index elements\n    sum_even_indices = 0\n    sum_odd_indices = 0\n    \n    # Loop through the tuple\n    for index in range(len(input_tuple)):\n        if index % 2 == 0:\n            # Element is at an even index\n            sum_even_indices += input_tuple[index]\n        else:\n            # Element is at an odd index\n            sum_odd_indices += input_tuple[index]\n    \n    # Return the sums as a tuple (even_index_sum, odd_index_sum)\n    return sum_even_indices, sum_odd_indices\n`"}
{"task_id": 325, "completion": "def get_Min_Squares(n):\n    # Initialize an array dp where dp[i] represents the minimum number of squares\n    # whose sum equals i. We'll fill this array with a maximum value initially.\n    dp = [float('inf')] * (n + 1)\n    \n    # Base case: 0 can be represented by sum of 0 squares\n    dp[0] = 0\n    \n    # Populate the dp array\n    for i in range(1, n + 1):\n        # For each i, we try subtracting squares of numbers from 1 to sqrt(i) and\n        # find the minimum dp value\n        j = 1\n        while j*j <= i:\n            dp[i] = min(dp[i], dp[i - j*j] + 1)\n            j += 1\n  \n    # The answer for n is stored in dp[n]\n    return dp[n]\n`"}
{"task_id": 326, "completion": "def most_occurrences(test_list):\n    # Creating an empty dictionary to keep track of word occurrences\n    word_count = {}\n    \n    # Iterating through each string in the list\n    for string in test_list:\n        # Splitting each string into words and iterating through them\n        for word in string.split():\n            # If the word is already in the dictionary, increment its count\n            if word in word_count:\n                word_count[word] += 1\n            # Otherwise, add the word to the dictionary with a count of 1\n            else:\n                word_count[word] = 1\n    \n    # Finding the word with the maximum occurrence\n    # max() function is used with key parameter to get the key with the highest value\n    most_frequent_word = max(word_count, key=word_count.get)\n    \n    # Returning the word with the most occurrences\n    return most_frequent_word"}
{"task_id": 327, "completion": "def check_isosceles(x, y, z):\n    # Check if the triangle is isosceles\n    if x == y or y == z or z == x:\n        print(\"The triangle is isosceles.\")\n    else:\n        print(\"The triangle is not isosceles.\")\n`"}
{"task_id": 328, "completion": "def rotate_left(list1, n):\n    \"\"\"\n    Rotates the given list to the left by n positions.\n\n    Parameters:\n    - list1: List to be rotated.\n    - n: Number of positions to rotate the list.\n\n    Returns:\n    - Rotated list.\n    \"\"\"\n    # Ensure n is within the bounds of the list's length to avoid redundant rotations\n    n = n % len(list1)\n\n    # Perform rotation\n    rotated_list = list1[n:] + list1[:n]\n\n    return rotated_list"}
{"task_id": 329, "completion": "def neg_count(lst):\n    # Initialize a counter for negative numbers\n    count = 0\n    # Iterate through each element in the list\n    for num in lst:\n        # If the element is a negative number, increment the counter\n        if num < 0:\n            count += 1\n    # Return the total count of negative numbers\n    return count"}
{"task_id": 330, "completion": "def find_char(text):\n    pattern = r'\\b\\w{3,5}\\b'\n    matches = re.findall(pattern, text)\n    return matches"}
{"task_id": 331, "completion": "def count_unset_bits(n):\n    # Convert the number into binary and remove the \"0b\" prefix.\n    binary_representation = bin(n)[2:]\n    \n    # Count the number of unset (0) bits\n    unset_bits_count = binary_representation.count('0')\n    \n    return unset_bits_count"}
{"task_id": 332, "completion": "def char_frequency(str1):\n    # Initialize an empty dictionary to store character frequencies\n    frequency = {}\n    # Loop through each character in the string\n    for char in str1:\n        # If the character is already in the dictionary, increase its count\n        if char in frequency:\n            frequency[char] += 1\n        # If the character is not in the dictionary, add it with count 1\n        else:\n            frequency[char] = 1\n    # Return the dictionary of character frequencies\n    return frequency"}
{"task_id": 333, "completion": "def sort_sublist(lst):\n    # Sorting the list by the second element of each sublist\n    return sorted(lst, key=lambda x: x[1])\n`"}
{"task_id": 334, "completion": "def check_validity(a, b, c):\n    # Check if the sum of any two sides is greater than the third side\n    if (a + b > c) and (a + c > b) and (b + c > a):\n        return True\n    else:\n        return False"}
{"task_id": 335, "completion": "def ap_sum(a, n, d):\n    return n / 2 * (2 * a + (n - 1) * d)"}
{"task_id": 336, "completion": "def check_monthnum(monthname):\n    \"\"\"\n    Checks if the given month name has 28 days in a non-leap year.\n    \n    Parameters:\n    - monthname (str): The name of the month.\n    \n    Returns:\n    - True if the month has 28 days, False otherwise.\n    \"\"\"\n    # Normalize the month name to ensure case-insensitivity\n    monthname_normalized = monthname.lower()\n    \n    # Define a dictionary to map month names to the number of days\n    months_days = {\n        'january': 31,\n        'february': 28, # 29 in a leap year\n        'march': 31,\n        'april': 30,\n        'may': 31,\n        'june': 30,\n        'july': 31,\n        'august': 31,\n        'september': 30,\n        'october': 31,\n        'november': 30,\n        'december': 31\n    }\n    \n    # Check if the month name given is in the dictionary\n    if monthname_normalized in months_days:\n        # Return True if the month has 28 days, False otherwise\n        return months_days[monthname_normalized] == 28\n    else:\n        print(\"Error: Invalid month name.\")\n        return False"}
{"task_id": 337, "completion": "import re\n\ndef text_match_word(text, word):\n    \"\"\"\n    Matches a word at the end of a string, considering optional punctuation.\n    \n    Args:\n    text (str): The text to search within.\n    word (str): The word to match at the end of the text.\n    \n    Returns:\n    bool: True or False\n    \"\"\"\n    \n    pattern = r'\\b' + re.escape(word) + r'[.,!?:;]?$'\n    \n    if re.search(pattern, text):\n        return True\n    else:\n        return False"}
{"task_id": 338, "completion": "def check_Equality(s):\n    # Initialize a counter to keep track of the substrings\n    count = 0\n\n    # Get the length of the string\n    n = len(s)\n\n    # Iterate over all possible substrings\n    for i in range(n):\n        for j in range(i, n):\n            # Check if the first and last characters of the substring are the same\n            if s[i] == s[j]:\n                # Increment the counter\n                count += 1\n\n    # Return the total count\n    return count"}
{"task_id": 339, "completion": "def find_Divisor(x, y):\n    # Dictionary to keep track of divisor counts\n    divisor_count = {}\n    \n    # Iterate through the range from x to y inclusive\n    for number in range(x, y + 1):\n        # Generate divisors for the number\n        for divisor in range(1, number + 1):\n            if number % divisor == 0:\n                # Update count in the dictionary\n                if divisor in divisor_count:\n                    divisor_count[divisor] += 1\n                else:\n                    divisor_count[divisor] = 1\n\n    # Find the divisor with maximum occurrence\n    max_occurrence = 0\n    max_divisor = None\n    for divisor, count in divisor_count.items():\n        if count > max_occurrence:\n            max_occurrence = count\n            max_divisor = divisor\n            \n    # Return the divisor with the maximum occurrence\n    # In case of a tie, it returns the first found with the max occurrence\n    return max_divisor"}
{"task_id": 340, "completion": "def sum_three_smallest_nums(lst):\n    # Filter out negative numbers and sort the remaining positive numbers\n    positive_nums = sorted([num for num in lst if num > 0])\n    \n    # Sum the first three elements from the sorted positive numbers list\n    return sum(positive_nums[:3])"}
{"task_id": 341, "completion": "def set_to_tuple(s):\n    # Step 1: Sort the set and convert it into a list\n    sorted_list = sorted(s)\n    # Step 2: Convert the sorted list into a tuple\n    sorted_tuple = tuple(sorted_list)\n    # Return the ordered tuple\n    return sorted_tuple"}
{"task_id": 342, "completion": "def find_smallest_range(arrays):\n    # Initialize the heap.\n    min_heap = []\n    \n    # The max_value variable keeps track of the maximum element seen so far across all the first elements of the arrays.\n    max_value = float('-inf')\n    \n    # Populate the heap with the first element of each array along with its array index and element index within its array.\n    for index, arr in enumerate(arrays):\n        heapq.heappush(min_heap, (arr[0], index, 0))\n        max_value = max(max_value, arr[0])\n\n    # Initialize the smallest range as infinity initially.\n    min_range = float('inf')\n    start, end = -1, -1\n    \n    while min_heap:\n        # Extract the smallest element from the heap.\n        min_value, arr_index, elem_index = heapq.heappop(min_heap)\n        \n        # Update the smallest range if the current range is smaller.\n        if max_value - min_value < min_range:\n            min_range = max_value - min_value\n            start, end = min_value, max_value\n        \n        # Move to the next element of the current array, if there is any.\n        if elem_index + 1 < len(arrays[arr_index]):\n            next_value = arrays[arr_index][elem_index + 1]\n            heapq.heappush(min_heap, (next_value, arr_index, elem_index + 1))\n            max_value = max(max_value, next_value)\n        else:\n            # If any of the arrays has been fully traversed, break out of the loop.\n            break\n\n    return (start, end)"}
{"task_id": 343, "completion": "def dig_let(s):\n    # Initialize counters for digits and letters\n    num_digits = 0\n    num_letters = 0\n    \n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            num_digits += 1\n        # Check if the character is a letter\n        elif char.isalpha():\n            num_letters += 1\n    \n    # Return the counts\n    return num_digits, num_letters"}
{"task_id": 344, "completion": "import math\n\ndef count_Odd_Squares(n, m):\n    # Finding the smallest perfect square greater than or equal to n\n    start = math.ceil(math.sqrt(n))\n    # Finding the largest perfect square less than or equal to m\n    end = math.floor(math.sqrt(m))\n    \n    # The count of perfect squares in the range is end - start + 1\n    count = end - start + 1\n    \n    return count"}
{"task_id": 345, "completion": "def diff_consecutive_nums(nums):\n    # Initialize an empty list to hold the differences\n    differences = []\n    # Iterate over the input list, except for the last element\n    for i in range(len(nums) - 1):\n        # Calculate the difference between consecutive elements and append to the list\n        differences.append(nums[i+1] - nums[i])\n    return differences"}
{"task_id": 346, "completion": "def zigzag(n, k):\n    # Base cases\n    if k > n:\n        return 0\n    if k == 0:\n        return 1\n    \n    # Recursive calculation\n    # Initialize a 2D array for memoization\n    E = [[0]*(k+1) for _ in range(n+1)]\n    \n    # Fill the base case values\n    for i in range(n+1):\n        E[i][0] = 1\n    \n    # Fill up the Entringer number matrix\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            E[i][j] = E[i][j-1] + E[i-1][i-j]\n            \n    # Return the required Entringer number\n    return E[n][k]"}
{"task_id": 347, "completion": "def count_squares(m, n):\n    # Initialize the count variable to 0.\n    count = 0\n    \n    # Loop through each square size.\n    for i in range(1, min(m, n) + 1):\n        # Calculate the number of squares of size i x i.\n        count += (m - i + 1) * (n - i + 1)\n    \n    return count"}
{"task_id": 348, "completion": "def bin_coff(n):\n    # Assuming r corresponds to steps of -1 and +1.\n    # We are working with a fixed \"coin\" set, hence no need to pass it as an argument.\n    \n    # Create a DP table to store counts of sequences of length i with prefix sum j.\n    # To accommodate prefix sums from 0 to n (inclusive), we need a table of size (n+1) x (n+2)\n    # n+1 for sequence lengths, and n+2 for prefix sums ranging from 0 to n (inclusive)\n    dp = [[0 for _ in range(n+2)] for _ in range(n+1)]\n    \n    # Base condition: one way to have a sequence of length 0 with prefix sum 0.\n    dp[0][0] = 1\n\n    # Fill DP table\n    for i in range(1, n+1):  # For each sequence length\n        for j in range(n+1):  # For each possible prefix sum\n            # Adding +1 step\n            if j+1 <= n:\n                dp[i][j] += dp[i-1][j+1]\n            # Adding -1 step, ensure non-negative prefix sum\n            if j-1 >= 0:\n                dp[i][j] += dp[i-1][j-1]\n                \n    result = sum(dp[n])  # Sum of all sequences with length n and non-negative prefix sums\n    \n    return result"}
{"task_id": 349, "completion": "def check(string):\n    # Set of binary characters\n    binary_chars = {'0', '1'}\n    \n    # Check if each character in the string is in binary_chars\n    for char in string:\n        if char not in binary_chars:\n            return False  # The string is not binary\n    \n    # If the loop completes without returning False, the string is binary\n    return True"}
{"task_id": 350, "completion": "def minimum_Length(s):\n    # Step 1: Count occurrences of each character\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Step 2: Find the character with the maximum occurrences\n    max_occurrences = max(char_count.values())\n    \n    # Step 3: Calculate the length after removing characters with maximum occurrences\n    minimized_length = len(s) - max_occurrences\n    \n    # Return the minimized length\n    return minimized_length"}
{"task_id": 351, "completion": "def first_Element(arr, n, k):\n    # Dictionary to store frequency of elements\n    frequency = {}\n    \n    # Populate the frequency dictionary\n    for element in arr:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    \n    # Check for the first element that occurs k times\n    for element in arr:\n        if frequency[element] == k:\n            return element\n    \n    # If no element occurs k times\n    return -1"}
{"task_id": 352, "completion": "def unique_Characters(str):\n    # Use a set to store encountered characters, leveraging the fact that sets can't have duplicates\n    char_set = set()\n\n    # Iterate through each character in the string\n    for char in str:\n        # Check if the character is already in the set\n        if char in char_set:\n            # If yes, characters are not unique; return False\n            return False\n        else:\n            # If not, add the character to the set\n            char_set.add(char)\n    \n    # If the loop completes without returning False, all characters are unique; return True\n    return True"}
{"task_id": 353, "completion": "def remove_column(list1, n):\n    \"\"\"\n    Removes column n from the nested list list1.\n    \n    Parameters:\n    - list1: A list of lists\n    - n: The index of the column to be removed\n    \n    Returns:\n    A new list of lists with the specified column removed.\n    \"\"\"\n    # Using list comprehension to rebuild each row without the nth element\n    return [[element for index, element in enumerate(row) if index != n] for row in list1]\n"}
{"task_id": 354, "completion": "def tn_ap(a, n, d):\n    \"\"\"\n    Calculate the nth term of an arithmetic progression.\n\n    Parameters:\n    a (int/float): The first term of the arithmetic progression.\n    n (int): The position (term number) of the desired term in the progression.\n    d (int/float): The constant difference between terms of the arithmetic progression.\n\n    Returns:\n    int/float: The nth term of the arithmetic progression.\n    \"\"\"\n    tn = a + (n - 1) * d\n    return tn"}
{"task_id": 355, "completion": "def count_squares_in_circle(radius):\n    # Maximum side length of a square inside the circle is \n    # the diameter of the circle = 2*radius\n    diameter = 2 * radius\n    \n    # Initialize count of squares\n    count = 0\n    \n    # Loop over all possible side lengths\n    for side in range(1, int(diameter / 1.414) + 1): # Dividing by 1.414 (approx sqrt(2)) \n                                                     # ensures the diagonal fits inside the circle\n        if (side * 1.414) <= diameter: # Check if the diagonal of the square fits in the diameter\n            count += 1\n    \n    return count"}
{"task_id": 356, "completion": "def find_angle(a, b):\n    \"\"\"\n    Finds the third angle of a triangle given two angles.\n\n    Parameters:\n    a (float): The first angle in degrees.\n    b (float): The second angle in degrees.\n\n    Returns:\n    float: The third angle in degrees.\n    \"\"\"\n    # Sum of angles in a triangle is 180 degrees\n    # So, the third angle = 180 - (a + b)\n    third_angle = 180 - (a + b)\n\n    return third_angle"}
{"task_id": 357, "completion": "def find_max(test_list):\n    # Initialize max_element to a very small number\n    max_element = float('-inf')\n    \n    # Iterate through each tuple in the list\n    for record in test_list:\n        # Find the max in the current tuple and update max_element if it's larger than the current max_element\n        max_element = max(max_element, max(record))\n    \n    return max_element"}
{"task_id": 358, "completion": "def moddiv_list(nums1, nums2):\n    \"\"\"\n    Performs modulo division between elements of two lists.\n    Args:\n    - nums1: List[int]. The first list of integers.\n    - nums2: List[int]. The second list of integers (divisors).\n    \n    Returns:\n    - List[int]: The result of modulo division of nums1 by nums2.\n    \"\"\"\n    return list(map(lambda x, y: x % y if y != 0 else None, nums1, nums2))"}
{"task_id": 359, "completion": "def check_solution(a, b, c):\n    # Calculate the determinant (D = b^2 - 4ac)\n    D = b**2 - 4*a*c\n    \n    # If the determinant is negative, the roots are complex and not real numbers.\n    # For simplicity, we'll not consider complex roots in this solution\n    if D < 0:\n        return False\n\n    # Calculate the roots of the quadratic equation\n    x1 = (-b + D**0.5) / (2*a)\n    x2 = (-b - D**0.5) / (2*a)\n    \n    # Check if one root is twice the other\n    if x1 == 2*x2 or x2 == 2*x1:\n        return True\n    else:\n        return False\n`"}
{"task_id": 360, "completion": "def get_carol(n):\n    # Calculate the n-th Carol number using the formula\n    carol_number = ((2**n - 1)**2) - 2\n    return carol_number"}
{"task_id": 361, "completion": "def remove_empty(list1):\n    # Creating a new list that will only include non-empty lists\n    result = [item for item in list1 if item != []]\n    return result"}
{"task_id": 362, "completion": "def max_occurrences(nums):\n    # Creating a Counter object to count occurrences of each item\n    count = Counter(nums)\n    \n    # Finding the item(s) with maximum occurrences\n    max_occurs = count.most_common(1)\n    \n    if max_occurs:\n        # most_common returns a list of tuples (element, count),\n        # so we extract the first tuple and then the first element of that tuple.\n        return max_occurs[0][0]\n    else:\n        # If the list is empty, return None\n        return None"}
{"task_id": 363, "completion": "def add_K_element(test_list, K):\n    result = [(x+K for x in tup) for tup in test_list]\n    result = [tuple(tup) for tup in result]\n    return result"}
{"task_id": 364, "completion": "def make_flip(ch):\n    # Initialize counts for the two alternating patterns\n    flips_for_01 = 0  # For pattern starting with 0 and then alternates (0,1,0,1,...)\n    flips_for_10 = 0  # For pattern starting with 1 and then alternates (1,0,1,0,...)\n    \n    # Traverse the string to count flips for each pattern\n    for i in range(len(ch)):\n        # If it's an even position but doesn't match the expected pattern, increment flip count\n        if i % 2 == 0:\n            if ch[i] != '0':  # Expecting '0' in even positions for the 01 pattern\n                flips_for_01 += 1\n            if ch[i] != '1':  # Expecting '1' in even positions for the 10 pattern\n                flips_for_10 += 1\n        else:  # Odd position\n            if ch[i] != '1':  # Expecting '1' in odd positions for the 01 pattern\n                flips_for_01 += 1\n            if ch[i] != '0':  # Expecting '0' in odd positions for the 10 pattern\n                flips_for_10 += 1\n    \n    # The minimum of the two flip counts is our answer\n    return min(flips_for_01, flips_for_10)"}
{"task_id": 365, "completion": "def count_Digit(n):\n    # Convert the number into its absolute value\n    # to ensure correct digit counting for negative numbers\n    n = abs(n)\n\n    # Convert the number to a string to easily count the digits\n    number_str = str(n)\n    \n    # Return the length of the string representation,\n    # which corresponds to the number of digits\n    return len(number_str)\n`"}
{"task_id": 366, "completion": "def adjacent_num_product(list_nums):\n    # Ensure the list has at least two elements to have adjacent pairs\n    if len(list_nums) < 2:\n        return \"List must contain at least two elements.\"\n    \n    # Initialize max_product with the product of the first pair\n    max_product = list_nums[0] * list_nums[1]\n    \n    # Loop through the list starting from the second element to the second last\n    for i in range(1, len(list_nums) - 1):\n        # Calculate the product of the current and next element\n        current_product = list_nums[i] * list_nums[i + 1]\n        \n        # Update max_product if the current product is greater than max_product\n        if current_product > max_product:\n            max_product = current_product\n    \n    # Return the largest product found\n    return max_product"}
{"task_id": 367, "completion": "def isBalanced(root):\n    def checkHeight(node):\n        if not node:\n            return 0\n        leftHeight = checkHeight(node.left)\n        if leftHeight == -1:\n            return -1\n        rightHeight = checkHeight(node.right)\n        if rightHeight == -1:\n            return -1\n        if abs(leftHeight - rightHeight) > 1:\n            return -1\n        return 1 + max(leftHeight, rightHeight)\n\n    return checkHeight(root) != -1"}
{"task_id": 368, "completion": "def repeat_tuples(test_tup, N):\n    # Using a loop and tuple multiplication to repeat each element N times\n    result = tuple(ele for ele in test_tup for _ in range(N))\n    return result"}
{"task_id": 369, "completion": "def lateral_surface_cuboid(length, width, height):\n    \"\"\"\n    Calculate the lateral surface area of a cuboid.\n\n    Parameters:\n    - length: The length of the cuboid.\n    - width: The width of the cuboid.\n    - height: The height of the cuboid.\n\n    Returns:\n    The lateral surface area of the cuboid.\n    \"\"\"\n    lateral_surface_area = 2 * height * (length + width)\n    return lateral_surface_area"}
{"task_id": 370, "completion": "def float_sort(tuples):\n    # Using the sorted function with a key parameter to sort based on the float element at index 1\n    return tuple(sorted(tuples, key=lambda x: x[1]))"}
{"task_id": 371, "completion": "def smallest_missing(A, left_element, right_element):\n    # Ensure the indices are within the bounds of the array\n    left_index = 0\n    right_index = len(A) - 1\n    \n    # If the missing element is less than the left_element or beyond right_element,\n    # adjust the search space accordingly\n    if left_element > A[right_index] or right_element < A[left_index]:\n        return left_element\n    \n    # Adjust indices based on the left_element\n    for i in range(len(A)):\n        if A[i] >= left_element:\n            left_index = i\n            break\n    \n    # Adjust indices based on the right_element\n    for i in range(len(A)-1, -1, -1):\n        if A[i] <= right_element:\n            right_index = i\n            break\n    \n    # If the array is empty or the leftmost element is not left_element, return left_element\n    if right_index < left_index:\n        return left_element\n    \n    # Binary search to find the smallest missing element\n    while left_index <= right_index:\n        mid_index = left_index + (right_index - left_index) // 2\n        \n        # If the current element is exactly where it should be (i.e., no gap up to this point)\n        if A[mid_index] == left_element + mid_index:\n            left_index = mid_index + 1\n        else:\n            # There's a gap, so the missing number must be on the left side\n            right_index = mid_index - 1\n    \n    # The index of the smallest missing element would be left_index\n    return left_element + left_index\n`"}
{"task_id": 372, "completion": "def heap_assending(nums):\n    # Create an empty heap\n    heap = []\n    heapq.heapify(heap)\n    \n    # Add all elements from nums into heap. Each element is pushed into the heap,\n    # ensuring that the heap property is maintained.\n    for num in nums:\n        heapq.heappush(heap, num)\n    \n    # Pop all elements from the heap and collect them into a list. Since heapq is a min-heap,\n    # elements are popped in ascending order.\n    sorted_nums = [heapq.heappop(heap) for _ in range(len(heap))]\n    \n    return sorted_nums\n`"}
{"task_id": 373, "completion": "def volume_cuboid(l, w, h):\n    return l * w * h"}
{"task_id": 374, "completion": "def permute_string(s):\n    def backtrack(start=0):\n        # When the current permutation is complete,\n        if start == len(s) - 1:\n            print(\"\".join(s))\n        for i in range(start, len(s)):\n            # Swap the current element with the start element\n            s[start], s[i] = s[i], s[start]\n            # Recursively call backtrack for the next element in the string\n            backtrack(start + 1)\n            # Swap the elements back to undo the changes for the next iteration\n            s[start], s[i] = s[i], s[start]\n\n    s = list(s)  # Convert string to a list of characters to allow swapping\n    backtrack()\n`"}
{"task_id": 375, "completion": "def round_num(n, m):\n    \"\"\"\n    Rounds the given number n to the nearest multiple of m.\n\n    Parameters:\n    - n: The number to be rounded.\n    - m: The number to whose multiple n is to be rounded.\n\n    Returns:\n    - The nearest multiple of m to n.\n    \"\"\"\n    # Calculate the remainder of n divided by m\n    remainder = n % m\n    \n    # If the remainder is less than half of m, round down\n    if remainder < m / 2:\n        return n - remainder\n    # Otherwise, round up\n    else:\n        return n + m - remainder\n`"}
{"task_id": 376, "completion": "def remove_replica(test_tup, custom_value):\n    result = list(test_tup)\n    seen = set()\n    duplicates = set()\n\n    for item in test_tup:\n        if item in seen:\n            duplicates.add(item)\n        else:\n            seen.add(item)\n\n    for i, value in enumerate(result):\n        if value in duplicates:\n            result[i] = custom_value\n\n    return tuple(result)"}
{"task_id": 377, "completion": "def remove_Char(s, c):\n    # Create an empty string to hold the result\n    result = \"\"\n    # Loop through each character in the string\n    for char in s:\n        # If the character is not the one to remove, add it to the result\n        if char != c:\n            result += char\n    # Return the result string\n    return result"}
{"task_id": 378, "completion": "def move_first(test_list):\n    # Check if the list is empty or contains only one element\n    if len(test_list) < 2:\n        return test_list\n\n    # Move the last element to the first position\n    test_list.insert(0, test_list.pop())\n\n    return test_list"}
{"task_id": 379, "completion": "def surfacearea_cuboid(l, w, h):\n    \"\"\"\n    Calculates the surface area of a cuboid.\n    \n    Parameters:\n    l (float): Length of the cuboid.\n    w (float): Width of the cuboid.\n    h (float): Height of the cuboid.\n    \n    Returns:\n    float: The surface area of the cuboid.\n    \"\"\"\n    return 2 * (l*w + l*h + w*h)"}
{"task_id": 380, "completion": "def multi_list(rownum, colnum, initial_value=0):\n    \"\"\"Generate a two-dimensional array (list of lists) with specified dimensions.\n    \n    Args:\n    - rownum (int): Number of rows in the array.\n    - colnum (int): Number of columns in each row.\n    - initial_value (optional): Initial value for each element in the array. Default is 0.\n    \n    Returns:\n    - List[List[Any]]: A two-dimensional array with the specified dimensions and initial value.\n    \"\"\"\n    return [[initial_value for _ in range(colnum)] for _ in range(rownum)]\n`"}
{"task_id": 381, "completion": "def index_on_inner_list(list_data, index_no):\n    \"\"\"\n    Sorts a list of lists based on a given index of the inner lists.\n\n    Parameters:\n    - list_data: A list of lists to be sorted.\n    - index_no: The index within each inner list to sort by.\n\n    Returns:\n    - The sorted list of lists.\n    \"\"\"\n    # Sort the list with the sorted() function, using a lambda function as the key\n    # that specifies which element of each inner list to sort by.\n    sorted_list = sorted(list_data, key=lambda x: x[index_no])\n    return sorted_list\n`"}
{"task_id": 382, "completion": "def find_rotation_count(A):\n    low = 0\n    high = len(A) - 1\n\n    # Handle cases when the array is not rotated.\n    if A[low] <= A[high]:\n        return 0\n\n    while low <= high:\n        mid = (low + high) // 2\n        next_element = (mid + 1) % len(A)\n        prev_element = (mid - 1 + len(A)) % len(A)\n\n        # Check if the mid element is the minimum\n        if A[mid] <= A[next_element] and A[mid] <= A[prev_element]:\n            return mid\n        \n        # If the elements at mid and high are in correct order, move towards unsorted part\n        elif A[mid] <= A[high]:\n            high = mid - 1\n        \n        # Move towards unsorted part\n        else:\n            low = mid + 1\n    \n    return 0"}
{"task_id": 383, "completion": "def even_bit_toggle_number(n):\n    # Assuming a 32-bit integer for the operation\n    # Create a mask for odd bits. In a 32-bit number odd bits will be in positions 1, 3, 5, ..., 31.\n    # This corresponds to a binary pattern where all odd bits are set to 1, and all even bits are 0.\n    # The binary representation of this mask is: 01010101 01010101 01010101 01010101 (in hex: 0x55555555)\n    odd_bits_mask = 0x55555555\n    \n    # Toggle the odd bits of n by using the XOR (^) operator with the mask\n    # This will flip all bits that are set in the mask. Since the mask has all odd bits set,\n    # it will effectively toggle the odd bits of `n`.\n    toggled_number = n ^ odd_bits_mask\n    \n    return toggled_number"}
{"task_id": 384, "completion": "def frequency_Of_Smallest(n, arr):\n    # First, we find the smallest value in the array\n    smallest = min(arr)\n    # Next, we count how many times this smallest value appears in the array\n    frequency = arr.count(smallest)\n    # Finally, return the frequency of the smallest value\n    return frequency"}
{"task_id": 385, "completion": "def get_perrin(n):\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n-2) + get_perrin(n-3)"}
{"task_id": 386, "completion": "def swap_count(s):\n    imbalance = 0  # Count of unbalanced bracket\n    swap = 0  # Count of swaps\n    open_brackets = 0  # Count of open brackets\n    \n    for char in s:\n        if char == '[':\n            open_brackets += 1\n            if imbalance > 0:  # If there were imbalances, one swap can fix one\n                swap += imbalance\n                imbalance -= 1  # Fixing one imbalance by swapping\n        else:  # It's a closing bracket\n            if open_brackets > 0:\n                open_brackets -= 1\n            else:  # It's an imbalance, need an opening bracket\n                imbalance += 1\n\n    return swap\n`"}
{"task_id": 387, "completion": "def even_or_odd(N):\n    # Ensure the hexadecimal is in uppercase to simplify checking\n    N = N.upper()\n    # Check if the last digit is in one of the even hexadecimal digits\n    if N[-1] in '02468ACE':\n        return 'Even'\n    else:\n        return 'Odd'"}
{"task_id": 388, "completion": "def highest_power_of_2(n):\n    n |= n >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n    n |= n >> 32\n    return n - (n >> 1)\n`"}
{"task_id": 389, "completion": "def find_lucas_recursive(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return find_lucas_recursive(n - 1) + find_lucas_recursive(n - 2)\n\ndef find_lucas_iterative(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = 2, 1\n    for _ in range(2, n+1):\n        a, b = b, a + b\n    return b"}
{"task_id": 390, "completion": "def add_string(lst, string):\n    \"\"\"\n    Inserts the given string at the beginning of all items in the list.\n    \n    Parameters:\n    lst (list): The list to operate on.\n    string (str): The string to add to the beginning of each item in the list.\n    \n    Returns:\n    list: A new list with the string added to the beginning of each item.\n    \"\"\"\n    # Convert all items in the list to strings (if not already) and add the string at the beginning\n    return [string + str(item) for item in lst]"}
{"task_id": 391, "completion": "def convert_list_dictionary(l1, l2, l3):\n    \"\"\"\n    Converts lists l1, l2, and l3 into a nested dictionary.\n    Assumes l1, l2 are lists of keys and l3 is a list of values with corresponding positions.\n    \"\"\"\n    nested_dict = {}\n    for i, l1_key in enumerate(l1):\n        if l1_key not in nested_dict:\n            nested_dict[l1_key] = {}\n        \n        l2_key = l2[i]\n        value = l3[i]\n        nested_dict[l1_key][l2_key] = value\n    \n    return nested_dict"}
{"task_id": 392, "completion": "def get_max_sum(n, memo={}):\n    # Base case: if the value of n is 0 or 1, return n itself.\n    if n < 2:\n        return n\n\n    # If the result for this value of n is already computed, return it.\n    if n in memo:\n        return memo[n]\n\n    # Compute the sum of the function applied to n/2, n/3, n/4, and n/5, recursively.\n    # Compare this sum with n, and return the maximum of the two.\n    # Store the result in the memo dictionary to avoid recomputation.\n    memo[n] = max(get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo), n)\n    \n    return memo[n]"}
{"task_id": 393, "completion": "def max_length_list(input_list):\n    # Use the max function with a lambda function as the key to compare the lengths of the lists\n    return max(input_list, key=lambda x: len(x))"}
{"task_id": 394, "completion": "def check_distinct(test_tup):\n    \"\"\"\n    This function checks if the given tuple has all distinct elements.\n    \n    Parameters:\n    test_tup (tuple): The tuple to check for distinct elements.\n    \n    Returns:\n    bool: True if all elements are distinct, False otherwise.\n    \"\"\"\n    return len(test_tup) == len(set(test_tup))"}
{"task_id": 395, "completion": "def first_non_repeating_character(str1):\n    char_order = []\n    counts = {}\n    for c in str1:\n        if c in counts:\n            counts[c] += 1\n        else:\n            counts[c] = 1\n            char_order.append(c)\n    for c in char_order:\n        if counts[c] == 1:\n            return c\n    return None"}
{"task_id": 396, "completion": "import re\n\ndef check_char(string):\n    # Regular expression pattern to match a string that starts and ends with the same character.\n    # ^ and $ are anchors to match the start and end of the string, respectively.\n    # (.) captures any character except newline at the beginning.\n    # .* allows any characters (except newline) to appear in the middle.\n    # \\1 refers to the first captured group, ensuring the last character is the same as the first.\n    pattern = r\"^(.).*\\1$\"\n    \n    # Using re.match() to check if the string matches the pattern.\n    # If there's a match, it means the string starts and ends with the same character.\n    if re.match(pattern, string):\n        return True\n    else:\n        return False\n`"}
{"task_id": 397, "completion": "def median_numbers(a, b, c):\n    # Sort the numbers and take the one in the middle\n    sorted_numbers = sorted([a, b, c])\n    return sorted_numbers[1]"}
{"task_id": 398, "completion": "def sum_of_digits(nums):\n    # Function to calculate the sum of digits of a single number\n    def digit_sum(n):\n        return sum(int(digit) for digit in str(abs(n))) # Ensure n is positive with abs()\n    \n    # Apply the digit_sum function to each number in the list nums\n    return [digit_sum(num) for num in nums]"}
{"task_id": 399, "completion": "def bitwise_xor(test_tup1, test_tup2):\n    \"\"\"\n    Perform bitwise XOR operation between corresponding elements of two tuples.\n    Assumes tuples contain integers and operations are done up to the length of the shorter tuple.\n\n    Parameters:\n    test_tup1 (tuple): The first tuple for the XOR operation.\n    test_tup2 (tuple): The second tuple for the XOR operation.\n\n    Returns:\n    tuple: A tuple containing the results of the bitwise XOR for each pair of elements.\n    \"\"\"\n\n    # Get the length of the shorter tuple to avoid index errors\n    min_length = min(len(test_tup1), len(test_tup2))\n\n    # Perform bitwise XOR on elements from both tuples up to the length of the shorter tuple\n    result = tuple(test_tup1[i] ^ test_tup2[i] for i in range(min_length))\n\n    return result"}
{"task_id": 400, "completion": "def extract_freq(test_list):\n    # Using a dictionary to maintain the order and count the frequency\n    freq_dict = {}\n    for item in test_list:\n        # Check if the item is already in dictionary, increase count if found\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    \n    # Convert the dictionary back to a list of tuples to maintain order\n    result = [(key, val) for key, val in freq_dict.items()]\n    \n    return result"}
{"task_id": 401, "completion": "def add_nested_tuples(test_tup1, test_tup2):\n    \"\"\"\n    Perform index wise addition of tuple elements in the given two nested tuples.\n    \"\"\"\n    result = []\n    \n    for elm1, elm2 in zip(test_tup1, test_tup2):\n        if isinstance(elm1, tuple) and isinstance(elm2, tuple):\n            result.append(add_nested_tuples(elm1, elm2))\n        else:\n            result.append(elm1 + elm2)\n    \n    return tuple(result)"}
{"task_id": 402, "completion": "def ncr_modp(n, r, p):\n    # Base cases\n    if r == 0 or r == n:\n        return 1\n    if r > n:\n        return 0\n    \n    # Compute factorials modulo p\n    num = 1\n    for i in range(1, n+1):\n        num = (num * i) % p\n    \n    denom = 1\n    for i in range(1, r+1):\n        denom = (denom * i) % p\n    \n    for i in range(1, n-r+1):\n        denom = (denom * i) % p\n    \n    # Compute and return result using modular inverse\n    inv_denom = pow(denom, p-2, p)\n    result = (num * inv_denom) % p\n\n    return result\n`"}
{"task_id": 403, "completion": "def is_valid_URL(str):\n    # Regex to check valid URL\n    regex = r'^(https?://)?[a-zA-Z0-9-]+(\\.[a-zA-Z]{2,})+(/.*)?$'\n    \n    # Compile the ReGex\n    p = re.compile(regex)\n    \n    # If the string is empty return false\n    if str == None:\n        return False\n    \n    # Return if the string matched the ReGex\n    if re.search(p, str):\n        return True\n    else:\n        return False"}
{"task_id": 404, "completion": "def minimum(a, b):\n    if a < b:\n        return a\n    else:\n        return b"}
{"task_id": 405, "completion": "def check_tuplex(tuplex, tuple1):\n    \"\"\"\n    Check if any element in tuple1 exists in tuplex.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    tuple1 (tuple): The tuple containing elements to search for in tuplex.\n\n    Returns:\n    bool: True if any element of tuple1 is found in tuplex, False otherwise.\n    \"\"\"\n    # Iterate through elements in tuple1\n    for element in tuple1:\n        # Check if the current element is in tuplex\n        if element in tuplex:\n            return True\n    # If no element in tuple1 is found in tuplex, return False\n    return False"}
{"task_id": 406, "completion": "def find_Parity(x):\n    # Check if the number is even\n    if x % 2 == 0:\n        return 0  # Return 0 for even parity\n    else:\n        return 1  # Return 1 for odd parity"}
{"task_id": 407, "completion": "def rearrange_bigger(n):\n    # Convert the number to a list of digits\n    digits = [int(x) for x in str(n)]\n\n    # 1. Find the pivot\n    pivot = -1\n    for i in range(len(digits) - 2, -1, -1):\n        if digits[i] < digits[i + 1]:\n            pivot = i\n            break\n    if pivot == -1: # This means digits are in descending order\n        return -1 # or any indication that no bigger configuration is possible\n\n    # 2. Find the successor\n    for i in range(len(digits) - 1, pivot, -1):\n        if digits[i] > digits[pivot]:\n            # 3. Swap the pivot with the successor\n            digits[i], digits[pivot] = digits[pivot], digits[i]\n            break\n\n    # 4. Reverse the digits after pivot\n    digits[pivot+1:] = reversed(digits[pivot+1:])\n    \n    # Convert back to a single number and return\n    return int(\"\".join(map(str, digits)))\n`"}
{"task_id": 408, "completion": "import heapq\n\ndef k_smallest_pairs(nums1, nums2, k):\n    if not nums1 or not nums2:\n        return []\n\n    # Create a min heap to store the potential pairs along with their sums\n    min_heap = []\n    for i in range(min(k, len(nums1))):  # Only need to check up to k pairs for the first list\n        for j in range(min(k, len(nums2))):  # Same logic applies for the second list\n            # Push the sum, and pair onto the heap\n            heapq.heappush(min_heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    \n    # Extract the k smallest elements from the heap\n    k_smallest = []\n    while k > 0 and min_heap:\n        _, pair = heapq.heappop(min_heap)\n        k_smallest.append(pair)\n        k -= 1\n\n    return k_smallest"}
{"task_id": 409, "completion": "def min_product_tuple(list1):\n    # Check if the list is empty or contains less than one tuple\n    if not list1 or len(list1) < 1:\n        return None\n    \n    # Initialize the minimum product variable with the product of the first tuple\n    min_product = float('inf')\n    \n    # Loop through each tuple in the list\n    for tup in list1:\n        # Calculate the product of the current tuple elements\n        product = 1\n        for num in tup:\n            product *= num\n        \n        # Update the minimum product if the current product is smaller\n        if product < min_product:\n            min_product = product\n    \n    # Return the smallest product found\n    return min_product"}
{"task_id": 410, "completion": "def min_val(listval):\n    \"\"\"\n    Find the minimum numerical value in a given heterogeneous list, ignoring non-numeric elements.\n    \n    Args:\n    - listval (list): A heterogeneous list potentially containing elements of different data types.\n    \n    Returns:\n    - The minimum numerical value found in the list, or None if no such value exists.\n    \"\"\"\n    # Initialize a variable to store the minimum value found. Set it to None as a starting point.\n    min_numeric = None\n\n    # Iterate through each item in the list.\n    for item in listval:\n        # Check if the current item is of a numeric type (int or float).\n        if isinstance(item, (int, float)):\n            # If min_numeric is still None, it means this is the first numeric value encountered.\n            # So, set min_numeric to this item.\n            if min_numeric is None:\n                min_numeric = item\n            # Otherwise, update min_numeric if the current item is less than the current min_numeric.\n            else:\n                min_numeric = min(min_numeric, item)\n\n    # Return the minimum numeric value found, or None if no numeric value was found.\n    return min_numeric\n`"}
{"task_id": 411, "completion": "import re\n\ndef snake_to_camel(word):\n    pattern = r'_([a-z])'\n    result = re.sub(pattern, lambda match: match.group(1).upper(), word)\n    return result"}
{"task_id": 412, "completion": "def remove_odd(l):\n    # Using list comprehension to filter out odd numbers\n    return [x for x in l if x % 2 == 0]\n`"}
{"task_id": 413, "completion": "def extract_nth_element(list1, n):\n    # Check if n is within the bounds of the tuples in the list\n    if not list1 or not list1[0] or n < 0 or n >= len(list1[0]):\n        print(\"n is out of bounds for the tuples in the list.\")\n        return None\n    \n    # Extract the nth element from each tuple in the list\n    result = [item[n] for item in list1]\n    \n    return result"}
{"task_id": 414, "completion": "def overlapping(list1, list2):\n    # Using a for loop to iterate over each value in list1\n    for value in list1:\n        # Checking if the current value exists in list2\n        if value in list2:\n            # If a common value is found, return True\n            return True\n    # If the loop completes without finding any common value, return False\n    return False"}
{"task_id": 415, "completion": "def max_Product(arr):\n    # If the array has fewer than 2 elements, we cannot find a pair\n    if len(arr) < 2:\n        return \"No pairs exist\"\n    \n    # Initialize the highest and second highest values to negative infinity\n    # And the lowest and second lowest values to positive infinity\n    highest = second_highest = float('-inf')\n    lowest = second_lowest = float('inf')\n    \n    # Traverse the array to find these values\n    for number in arr:\n        if number > highest:\n            second_highest, highest = highest, number\n        elif number > second_highest:\n            second_highest = number\n        \n        if number < lowest:\n            second_lowest, lowest = lowest, number\n        elif number < second_lowest:\n            second_lowest = number\n    \n    # Calculate the products of the highest and second highest, and the lowest and second lowest\n    product_positive = highest * second_highest\n    product_negative = lowest * second_lowest\n    \n    # The higher product of these two is the answer\n    max_product = max(product_positive, product_negative)\n    \n    return max_product"}
{"task_id": 416, "completion": "def breakSum(n):\n    # Base case\n    if n <= 1:\n        return n\n    else:\n        # Attempt to split the number into two parts in every possible way,\n        # choosing the maximum result among splitting and not splitting.\n        max_sum = max(n, breakSum(n//2) + breakSum(n//3) + breakSum(n//4))\n        return max_sum"}
{"task_id": 417, "completion": "def group_tuples(Input):\n    # Initialize a dictionary to hold the results\n    result = {}\n    for tup in Input:\n        # Check if the first element of the tuple is already a key in the dictionary\n        if tup[0] in result:\n            # If yes, append the tuple to the corresponding list\n            result[tup[0]].append(tup)\n        else:\n            # If not, create a new key with this first element, and start a new list with the tuple\n            result[tup[0]] = [tup]\n    return result"}
{"task_id": 418, "completion": "def find_max(lst):\n    # Initialize variables to store the maximum length found so far\n    # And the sublist that has this maximum length\n    max_length = 0\n    max_sublist = None\n    \n    # Loop through each sublist in the given list\n    for sublist in lst:\n        # Check if the current sublist is longer than the max length found so far\n        if len(sublist) > max_length:\n            # Update max length and the corresponding sublist\n            max_length = len(sublist)\n            max_sublist = sublist\n    \n    # Return the sublist with the maximum length\n    return max_sublist\n`"}
{"task_id": 419, "completion": "def round_and_sum(list1):\n    # Round every number in the list\n    rounded_list = [round(num) for num in list1]\n    # Calculate the total sum of the rounded list\n    total_sum = sum(rounded_list)\n    # Multiply the total sum by the length of the list\n    result = total_sum * len(list1)\n    # Print the result\n    print(result)"}
{"task_id": 420, "completion": "def cube_sum(n):\n    # Initialize sum to 0\n    sum = 0\n    # Initialize count to keep track of how many even numbers have been processed\n    count = 0\n    # Initialize a variable to iterate through natural numbers\n    num = 1\n    \n    # Loop until we've processed n even numbers\n    while count < n:\n        # If the number is even\n        if num % 2 == 0:\n            # Add its cube to the sum\n            sum += num ** 3\n            # Increment the count since we found an even number\n            count += 1\n        # Go to the next number\n        num += 1\n    \n    return sum\n`"}
{"task_id": 421, "completion": "def concatenate_tuple(test_tup, delimiter):\n    \"\"\"\n    Concatenates each element of the tuple using the specified delimiter.\n    \n    :param test_tup: The tuple to be concatenated.\n    :param delimiter: The string delimiter to separate the elements.\n    :return: A single string with all elements of the tuple concatenated with the delimiter.\n    \"\"\"\n    # Convert all tuple elements to string, in case they are not\n    str_elements = [str(element) for element in test_tup]\n    \n    # Use the join method with the delimiter to concatenate the elements\n    result = delimiter.join(str_elements)\n    \n    return result\n`"}
{"task_id": 422, "completion": "def find_Average_Of_Cube(n):\n    # Calculate the sum of cubes of first n natural numbers using the formula\n    sum_of_cubes = (n * (n + 1) // 2) ** 2\n    # Calculate the average by dividing the sum by n\n    average = sum_of_cubes / n\n    return average"}
{"task_id": 423, "completion": "def get_maxgold(gold, m, n):\n    # Create a table for storing intermediate results and initialize all cells to 0.\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n\n    for col in range(n-1, -1, -1):  # Start from the last column and move leftwards\n        for row in range(m):\n            # Gold collected on going to the cell on the right(->), right up (/), and right down(\\)\n            right = 0 if (col == n-1) else dp[row][col + 1]\n            right_up = 0 if (row == 0 or col == n-1) else dp[row - 1][col + 1]\n            right_down = 0 if (row == m-1 or col == n-1) else dp[row + 1][col + 1]\n\n            # Max gold collected from this cell\n            dp[row][col] = gold[row][col] + max(right, right_up, right_down)\n\n    # The maximum amount of gold collected will be the max value in the first column\n    max_gold = max(dp[i][0] for i in range(m))\n    return max_gold\n`"}
{"task_id": 424, "completion": "def extract_rear(test_tuple):\n    # Initialize an empty tuple to store the rear index elements\n    rear_elements = ()\n    \n    # Iterate through each string in the input tuple\n    for item in test_tuple:\n        if len(item) > 0:  # Ensure the string is not empty\n            # Extract the last character of the string and add it to the rear_elements tuple\n            rear_elements += (item[-1],)\n    \n    # Return the tuple containing all the rear index elements\n    return rear_elements\n`"}
{"task_id": 425, "completion": "def count_element_in_sublist(list1, x):\n    count = 0\n    # Iterate through each element in list1\n    for sublist in list1:\n        # Check if the current element is a list itself\n        if isinstance(sublist, list):\n            # If x is found in the sublist, increase the count\n            if x in sublist:\n                count += 1\n    return count\n`"}
{"task_id": 426, "completion": "def filter_oddnumbers(nums):\n    \"\"\"\n    Filters odd numbers from a list.\n\n    Parameters:\n    nums (list): List of numbers.\n\n    Returns:\n    list: Filtered list with only odd numbers.\n    \"\"\"\n    return list(filter(lambda x: x % 2 != 0, nums))"}
{"task_id": 427, "completion": "import re\n\ndef change_date_format(dt):\n    # Pattern to match the yyyy-mm-dd format\n    pattern = r'(\\d{4})-(\\d{2})-(\\d{2})'\n\n    # Attempt to match the pattern to the input date string\n    match = re.match(pattern, dt)\n    if match:\n        # Extracting year, month, and day from the matched groups\n        year, month, day = match.groups()\n        \n        # Rearranging the date format to dd-mm-yyyy\n        return f\"{day}-{month}-{year}\"\n    else:\n        # If the input does not match the yyyy-mm-dd format\n        return \"Input date is not in the correct format (yyyy-mm-dd).\""}
{"task_id": 428, "completion": "def shell_sort(arr):\n    n = len(arr)\n    # Start with a big gap, then reduce the gap\n    gap = n // 2\n    \n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements arr[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            # Add arr[i] to the elements that have been gap sorted\n            # Save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr"}
{"task_id": 429, "completion": "def and_tuples(test_tup1, test_tup2):\n    \"\"\"\n    Returns a new tuple with the elementwise AND result from two input tuples.\n    \n    :param test_tup1: First tuple of integers.\n    :param test_tup2: Second tuple of integers.\n    :return: A new tuple containing the elementwise bitwise AND of the input tuples.\n    \"\"\"\n    # The zip function here pairs each element of test_tup1 with the corresponding element in test_tup2.\n    # The bitwise AND operation '&' is then applied to each pair of elements.\n    # The result is wrapped in a tuple constructor to return a tuple.\n    result_tuple = tuple(a & b for a, b in zip(test_tup1, test_tup2))\n    return result_tuple"}
{"task_id": 430, "completion": "def parabola_directrix(a, b, c):\n    # Step 1: Find the axis of symmetry (h) and the vertex's y-coordinate (k)\n    h = -b / (2 * a)\n    k = a * h**2 + b * h + c\n    \n    # Step 2: The directrix is given for vertical parabolas by adjusting k.\n    # Since the focus is (h, k + 1/4a) for an upward opening parabola,\n    # the directrix, which is equidistant but opposite, will be at y = k - 1/4a.\n    \n    directrix_y = k - (1 / (4 * a))\n    \n    # Formatting the output as a line equation\n    directrix = f\"y = {directrix_y}\"\n    \n    return directrix"}
{"task_id": 431, "completion": "def common_element(list1, list2):\n    # Convert lists to sets to improve efficiency in finding common elements\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Use set intersection (&) to find common elements between the two sets\n    # If the intersection is not empty, it means there is at least one common element\n    if set1 & set2:\n        return True\n    return False"}
{"task_id": 432, "completion": "def median_trapezium(base1, base2):\n    \"\"\"\n    Calculate the median of a trapezium based on its two bases.\n\n    Parameters:\n    base1 (float): Length of the first base of the trapezium.\n    base2 (float): Length of the second base of the trapezium.\n\n    Returns:\n    float: Length of the median of the trapezium.\n    \"\"\"\n    return (base1 + base2) / 2"}
{"task_id": 433, "completion": "def check_greater(arr, number):\n    # Loop through array and check if number is less than or equal to any element\n    for elem in arr:\n        if number <= elem:\n            return False\n    # If we reach this point, number is greater than all elements in the array\n    return True"}
{"task_id": 434, "completion": "import re\n\ndef text_match_one(text):\n    \"\"\"\n    This function checks if the given string contains an 'a'\n    followed by one or more 'b's.\n    \n    Args:\n    text (str): The text to search in.\n    \n    Returns:\n    bool: True if the pattern is found, False otherwise.\n    \"\"\"\n    pattern = 'ab+'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False"}
{"task_id": 435, "completion": "def last_Digit(n):\n    # Get the last digit using the modulus operator and return it\n    return abs(n) % 10\n`"}
{"task_id": 436, "completion": "def neg_nos(list1):\n    # Loop through each number in the list\n    for num in list1:\n        # Check if the number is negative\n        if num < 0:\n            print(num)"}
{"task_id": 437, "completion": "def remove_odd(str1):\n    # Initialize an empty string to store the result\n    result = \"\"\n    # Iterate over the string using enumerate to get both index and character\n    for index, char in enumerate(str1):\n        # Check if the index is even (which corresponds to odd positions in 1-based indexing)\n        if index % 2 == 0:\n            # Append the character to the result string\n            result += char\n    # Return the result string\n    return result"}
{"task_id": 438, "completion": "def count_bidirectional(test_list):\n    # Initialize a counter for bidirectional tuples\n    bidirectional_count = 0\n    \n    # Use a set to keep track of tuples for which we have found a bidirectional match\n    counted_tuples = set()\n    \n    for item in test_list:\n        # Check if the reverse tuple exists in the list and it has not been counted yet\n        if (item[::-1] in test_list) and (item not in counted_tuples) and (item[::-1] not in counted_tuples):\n            # Increment the counter\n            bidirectional_count += 1\n            # Add both the tuple and its reverse to the set of counted tuples\n            counted_tuples.add(item)\n            counted_tuples.add(item[::-1])\n    \n    # Return the total count of bidirectional pairs\n    return bidirectional_count\n`"}
{"task_id": 439, "completion": "def multiple_to_single(L):\n    single_str = ''.join(str(i) for i in L)\n    single_int = int(single_str)\n    return single_int"}
{"task_id": 440, "completion": "def find_adverb_position(text):\n    \"\"\"\n    Finds adverbs in a given sentence and their positions.\n    This function assumes adverbs end in 'ly'.\n    \n    :param text: The sentence to search for adverbs.\n    :return: A list of tuples where each tuple contains an adverb and its position in the sentence.\n    \"\"\"\n    # Split the sentence into words\n    words = text.split()\n    \n    # Initialize an empty list to store adverbs and their positions\n    adverb_positions = []\n    \n    # Iterate through the words and their indices\n    for index, word in enumerate(words):\n        # Check if the word ends with 'ly'\n        if word.endswith('ly'):\n            # If it does, append the word and its index (position) to the list\n            adverb_positions.append((word, index))\n    \n    return adverb_positions"}
{"task_id": 441, "completion": "def surfacearea_cube(l):\n    # Calculate the surface area of a cube\n    surface_area = 6 * (l ** 2)\n    return surface_area"}
{"task_id": 442, "completion": "def positive_count(nums):\n    \"\"\"\n    Calculate the ratio of positive numbers in an array of integers.\n\n    Parameters:\n    nums (list of int): The array of integers to evaluate.\n\n    Returns:\n    float: The ratio of positive numbers in the array.\n    \"\"\"\n    if not nums:  # Check if the list is empty\n        return 0\n\n    positive_numbers = sum(1 for num in nums if num > 0)\n    ratio = positive_numbers / len(nums)\n    return ratio"}
{"task_id": 443, "completion": "def largest_neg(num_list):\n    # Initialize the variable to store the largest negative number.\n    # Set it to None initially as we haven't encountered any negative numbers yet.\n    largest_negative = None\n    \n    # Iterate through each number in the list.\n    for num in num_list:\n        # Check if the current number is negative and if it's the first negative number we've found\n        # or if it's larger than the current largest negative number we've found.\n        if num < 0 and (largest_negative is None or num > largest_negative):\n            # Update the largest negative number found so far.\n            largest_negative = num\n            \n    # After going through all numbers, return the largest negative number found,\n    # or None if no negative number was found.\n    return largest_negative"}
{"task_id": 444, "completion": "def trim_tuple(test_list, K):\n    # Trim each tuple in the list to the first K elements\n    trimmed_list = [tup[:K] for tup in test_list]\n    return trimmed_list"}
{"task_id": 445, "completion": "def index_multiplication(test_tup1, test_tup2):\n    # Using a generator expression to multiply corresponding elements of both tuples\n    result = tuple(a * b for a, b in zip(test_tup1, test_tup2))\n    return result"}
{"task_id": 446, "completion": "def count_Occurrence(tup, lst):\n    # Initialize an empty dictionary to store counts\n    count_dict = {}\n\n    # Loop through each element in the list\n    for elem in lst:\n        if elem in tup:  # Check if the element is in the tuple\n            # If the element is in the tuple, count its occurrences and update the dictionary\n            count_dict[elem] = tup.count(elem)\n        else:\n            # If the element is not in the tuple, its count is 0\n            count_dict[elem] = 0\n\n    return count_dict"}
{"task_id": 447, "completion": "def cube_nums(nums):\n    cubes = list(map(lambda x: x**3, nums))\n    return cubes"}
{"task_id": 448, "completion": "def cal_sum(n):\n    # Base cases\n    if n == 0:\n        return 3  # Since we only have the first number, P(0) = 3\n    if n == 1:\n        return 3  # The sum of the first two, P(0) = 3 and P(1) = 0, thus 3+0=3\n    if n == 2:\n        return 5  # The sum of the first three, P(0) = 3, P(1) = 0, and P(2) = 2\n\n    # Initialize the first three Perrin numbers\n    p0, p1, p2 = 3, 0, 2\n    # Initialize sum of the first three Perrin numbers\n    total_sum = p0 + p1 + p2\n\n    # Generate and sum the next n-3 Perrin numbers\n    for _ in range(3, n):\n        # Use the recurrence relation to find the next Perrin number\n        next_p = p0 + p1\n        # Update the total sum\n        total_sum += next_p\n        # Move to the next set of Perrin numbers in the sequence\n        p0, p1, p2 = p1, p2, next_p\n\n    return total_sum\n`"}
{"task_id": 449, "completion": "# Function to check whether the triangle is valid or not\ndef check_Triangle(x1, y1, x2, y2, x3, y3):\n    # Calculate the sides of the triangle\n    side1 = calculate_distance(x1, y1, x2, y2)\n    side2 = calculate_distance(x2, y2, x3, y3)\n    side3 = calculate_distance(x3, y3, x1, y1)\n    \n    # Check the triangle inequality theorem\n    if (side1 + side2 > side3) and (side1 + side3 > side2) and (side2 + side3 > side1):\n        return True  # The triangle is valid\n    else:\n        return False  # The triangle is not valid"}
{"task_id": 450, "completion": "def extract_string(str_list, l):\n    # This will store the result\n    result = []\n    # Loop through each string in the given list\n    for string in str_list:\n        # Check if the string has the desired length\n        if len(string) == l:\n            # If so, add it to the result list\n            result.append(string)\n    # Return the list of strings that match the desired length\n    return result"}
{"task_id": 451, "completion": "import re\n\ndef remove_whitespaces(text):\n    # Using a regex pattern to match all kinds of whitespaces (\\s) and replace them with an empty string\n    no_whitespaces = re.sub(r'\\s+', '', text)\n    return no_whitespaces\n"}
{"task_id": 452, "completion": "def loss_amount(actual_cost, sale_amount):\n    # Check if there is a loss\n    if actual_cost > sale_amount:\n        # Calculate the loss amount\n        loss = actual_cost - sale_amount\n        return loss\n    # If no loss, return None\n    return None"}
{"task_id": 453, "completion": "def sumOfEvenFactors(n):\n    # Initialize the sum_of_factors to 0\n    sum_of_even_factors = 0\n    \n    # Iterate through possible factors of n\n    for i in range(1, n + 1):\n        # Check if i is a factor of n and even\n        if n % i == 0 and i % 2 == 0:\n            sum_of_even_factors += i\n            \n    return sum_of_even_factors"}
{"task_id": 454, "completion": "def text_match_wordz(text):\n    # This pattern will match any word containing a 'z'\n    pattern = r'\\b\\w*z\\w*\\b'\n    # Finding all matches in the input text\n    matches = re.findall(pattern, text)\n    return matches"}
{"task_id": 455, "completion": "def check_monthnumb_number(monthnum2):\n    # A list of months with 31 days\n    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]\n\n    # Check if the month number is in the list\n    if monthnum2 in months_with_31_days:\n        print(f\"Month number {monthnum2} contains 31 days.\")\n    else:\n        print(f\"Month number {monthnum2} does not contain 31 days.\")"}
{"task_id": 456, "completion": "def reverse_string_list(stringlist):\n    return [s[::-1] for s in stringlist]"}
{"task_id": 457, "completion": "def Find_Min(lst):\n    # Check if the list is empty\n    if not lst:\n        return None  # Return None or you can return an empty list based on your requirement\n    \n    # Initialize min_list with the first sublist assuming it's the smallest\n    min_list = lst[0]\n    \n    # Loop through all sublists in lst to find the one with minimum length\n    for sublist in lst[1:]:  # Start from the second element\n        if len(sublist) < len(min_list):  # Compare lengths\n            min_list = sublist  # Update min_list if a smaller sublist is found\n    \n    return min_list"}
{"task_id": 458, "completion": "def rectangle_area(l, b):\n    \"\"\"\n    This function returns the area of a rectangle.\n    \n    Parameters:\n    l (float or int): The length of the rectangle.\n    b (float or int): The breadth of the rectangle.\n    \n    Returns:\n    float or int: The area of the rectangle.\n    \"\"\"\n    return l * b"}
{"task_id": 459, "completion": "import re\n\ndef remove_uppercase(str1):\n    # Pattern to match uppercase substrings: one or more uppercase letters\n    pattern = r'[A-Z]+'\n    \n    # Replace uppercase substrings with an empty string\n    result = re.sub(pattern, '', str1)\n    \n    return result"}
{"task_id": 460, "completion": "def Extract(lst):\n    # Using list comprehension to iterate and extract the first element\n    return [item[0] for item in lst]"}
{"task_id": 461, "completion": "def upper_ctr(str):\n    # Initialize a counter for uppercase characters\n    upper_count = 0\n    # Iterate over each character in the string\n    for char in str:\n        # Check if the character is uppercase\n        if char.isupper():\n            # Increment the counter if the condition is true\n            upper_count += 1\n    # Return the final count of uppercase characters\n    return upper_count"}
{"task_id": 462, "completion": "from itertools import combinations\n\ndef combinations_list(list1):\n    all_combinations = []\n    # Iterate through all possible lengths\n    for i in range(1, len(list1) + 1):\n        # combinations() generates all combinations for the current length i\n        for combo in combinations(list1, i):\n            all_combinations.append(combo)\n    return all_combinations"}
{"task_id": 463, "completion": "def max_subarray_product(arr):\n    # Edge case: If the array is empty\n    if not arr:\n        return 0\n    \n    # Initialize max and min products as the first element\n    max_end_here = min_end_here = max_so_far = arr[0]\n    \n    # Iterate through the array starting from the second element\n    for num in arr[1:]:\n        # Temporarily store the max value\n        temp_max = max(num, num * max_end_here, num * min_end_here)\n        # Update min_end_here using the previous max_end_here for comparing\n        min_end_here = min(num, num * max_end_here, num * min_end_here)\n        # Update max_end_here with the temp_max value calculated\n        max_end_here = temp_max\n        \n        # Update the result\n        max_so_far = max(max_so_far, max_end_here)\n    \n    return max_so_far\n`"}
{"task_id": 464, "completion": "def check_value(dict, n):\n    # If the dictionary is empty, we assume all values are \"the same\" as there are no values.\n    if not dict:\n        return True\n    \n    # Get the first value from the dictionary to compare with others.\n    first_value = next(iter(dict.values()))\n    \n    # Iterate through all values in the dictionary to check if they match the first value.\n    for value in dict.values():\n        if value != first_value:\n            # If a value does not match the first value, return False.\n            return False\n    \n    # If all values match, return True.\n    return True\n`"}
{"task_id": 465, "completion": "def drop_empty(dict1):\n    # Use a dictionary comprehension to filter out empty items\n    return {key: value for key, value in dict1.items() if value}\n`"}
{"task_id": 466, "completion": "def find_peak_util(arr, low, high, n):\n    \"\"\"\n    A utility function to find a peak element in the given array arr[].\n    \n    Parameters:\n    arr: List[int] - The input array.\n    low: int - The starting index of the portion of the array to be searched.\n    high: int - The ending index of the portion of the array to be searched.\n    n: int - The total number of elements in arr.\n    \n    Returns:\n    int - The index of a peak element.\n    \"\"\"\n    # Find middle index \n    mid = low + (high - low) // 2\n    \n    # Check if the middle element is a peak\n    if ((mid == 0 or arr[mid - 1] <= arr[mid]) and\n       (mid == n - 1 or arr[mid + 1] <= arr[mid])):\n        return mid\n    \n    # If the middle element is not a peak and its left neighbor is greater than it,\n    # then the left half must have a peak element\n    elif mid > 0 and arr[mid - 1] > arr[mid]:\n        return find_peak_util(arr, low, mid - 1, n)\n    \n    # If the middle element is not a peak and its right neighbor is greater than it,\n    # then the right half must have a peak element\n    else:\n        return find_peak_util(arr, mid + 1, high, n)\n`"}
{"task_id": 467, "completion": "def decimal_to_Octal(deciNum):\n    # Initialize the octal number as an empty string\n    octalNum = ''\n    \n    # Loop until decimal number is 0\n    while deciNum > 0:\n        # Find remainder when deciNum is divided by 8\n        remainder = deciNum % 8\n        \n        # Prepend remainder to the octal number\n        # Convert remainder to string and add to the front of octalNum\n        octalNum = str(remainder) + octalNum\n        \n        # Update deciNum by dividing it by 8 and taking floor value\n        deciNum = deciNum // 8\n    \n    # Return the octal number\n    return octalNum\n`"}
{"task_id": 468, "completion": "def max_product(arr, n):\n    # Initialize a dp array where dp[i] will store the maximum product ending with arr[i]\n    dp = [0]*n\n    \n    # The minimum product for the sequence ending with the first element is the element itself\n    dp[0] = arr[0]\n    \n    # Iterate over the array starting from the second element\n    for i in range(1, n):\n        max_val = None\n        # Look for all elements before the current one\n        for j in range(i):\n            # If the previous element is smaller than the current one, it can be part of the increasing sequence\n            if arr[j] < arr[i]:\n                # If this is the first time finding a previous smaller element OR\n                # the product of dp[j] and arr[i] is greater than the current max_val\n                if max_val is None or max_val < dp[j] * arr[i]:\n                    # Update max_val with the product\n                    max_val = dp[j] * arr[i]\n        # If max_val is updated, update dp[i] with max_val, else, dp[i] = arr[i]\n        dp[i] = arr[i] if max_val is None else max_val\n    \n    # The answer is the maximum value in the dp array\n    return max(dp)"}
{"task_id": 469, "completion": "def max_profit(prices, k):\n    if not prices or k == 0:\n        return 0\n\n    n = len(prices)\n    if k >= n // 2:\n        return sum(max(prices[i] - prices[i-1], 0) for i in range(1, n))\n\n    dp = [[0] * n for _ in range(k + 1)]\n\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i-1][j] - prices[j])\n\n    return dp[k][-1]"}
{"task_id": 470, "completion": "def add_pairwise(test_tup):\n    \"\"\"\n    This function returns a new tuple with the pairwise addition of the elements \n    of the input tuple.\n    \n    :param test_tup: A tuple of numbers (either integers or floats)\n    :return: A tuple of pairwise sums\n    \"\"\"\n    # Initialize an empty list to store the pairwise sums\n    sum_pairs_list = []\n    \n    # Iterate over the tuple in steps of 2\n    for i in range(0, len(test_tup) - 1, 2):\n        # Add the current and next element, and append the result to the list\n        sum_pairs_list.append(test_tup[i] + test_tup[i+1])\n    \n    # Convert the list back to a tuple before returning\n    return tuple(sum_pairs_list)\n`"}
{"task_id": 471, "completion": "def find_remainder(arr, lens, n):\n    \"\"\"\n    Function to find remainder of the array multiplication divided by n.\n    \n    Parameters:\n    arr (list): The list of numbers whose product's remainder is to be found.\n    lens (int): Size of the array (can be omitted if not used).\n    n (int): The divisor.\n    \n    Returns:\n    int: Remainder of the product of array elements divided by n.\n    \"\"\"\n    \n    # Initialize result\n    result = 1\n    \n    # Traverse through all elements\n    for element in arr:\n        # Update result\n        result = (result * (element % n)) % n\n       \n    # Return result\n    return result\n`"}
{"task_id": 472, "completion": "def check_Consecutive(l):\n    # Sort the list\n    sorted_list = sorted(l)\n    \n    # Iterate through the sorted list to check if numbers are consecutive\n    for i in range(1, len(sorted_list)):\n        if sorted_list[i] - sorted_list[i-1] != 1:\n            return False\n            \n    return True"}
{"task_id": 473, "completion": "def tuple_intersection(test_list1, test_list2):\n    # Step 1: Normalize the tuples by sorting their elements\n    normalized_list1 = {tuple(sorted(t)) for t in test_list1}\n    normalized_list2 = {tuple(sorted(t)) for t in test_list2}\n    \n    # Step 2: Find the intersection\n    intersection = normalized_list1.intersection(normalized_list2)\n    \n    # Convert the set back to a list of tuples to return it\n    return list(intersection)\n`"}
{"task_id": 474, "completion": "def replace_char(str1, ch, newch):\n    # Replace 'ch' with 'newch' in 'str1'\n    updated_str = str1.replace(ch, newch)\n    return updated_str"}
{"task_id": 475, "completion": "from collections import Counter\n\ndef sort_counter(dict1):\n    # Converting dict1 to a Counter (optional if dict1 is already a Counter)\n    counter = Counter(dict1)\n    \n    # Sorting the counter by value in descending order\n    # The .items() method returns a list of tuple pairs from the counter\n    # sorted(key=lambda pair: pair[1], reverse=True) sorts the list based on the values of the pairs\n    # and reverse=True makes the order descending\n    sorted_counter = sorted(counter.items(), key=lambda pair: pair[1], reverse=True)\n    \n    return sorted_counter\n`"}
{"task_id": 476, "completion": "def big_sum(nums):\n    # Check if the list is empty\n    if not nums:\n        return \"The list is empty\"\n    \n    # Find the smallest and largest values in the list\n    smallest = min(nums)\n    largest = max(nums)\n    \n    # Calculate the sum of the smallest and largest values\n    result = smallest + largest\n    \n    return result"}
{"task_id": 477, "completion": "def is_lower(string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    string (str): The string to convert to lower case.\n\n    Returns:\n    str: The converted lower case string.\n    \"\"\"\n    return string.lower()"}
{"task_id": 478, "completion": "def remove_lowercase(str1):\n    result = \"\"  # Initialize an empty string to store the result\n    for char in str1:\n        if not char.islower():  # If the character is not lowercase, add it to the result\n            result += char\n    return result"}
{"task_id": 479, "completion": "def first_digit(n):\n    # Convert the number to a string\n    n_str = str(n)\n    \n    # Get the first character of the string\n    first_digit_char = n_str[0]\n    \n    # Convert the first character back to an integer\n    first_digit_int = int(first_digit_char)\n    \n    # Return the first digit\n    return first_digit_int"}
{"task_id": 480, "completion": "def get_max_occuring_char(str1):\n    # Initialize a dictionary to keep track of character frequencies\n    char_frequency = {}\n    \n    # Iterate through each character in the string\n    for char in str1:\n        # If the character is already in the dictionary, increase its count\n        if char in char_frequency:\n            char_frequency[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            char_frequency[char] = 1\n    \n    # Find the character with the maximum frequency\n    max_occuring_char = max(char_frequency, key=char_frequency.get)\n    \n    return max_occuring_char\n`"}
{"task_id": 481, "completion": "def is_subset_sum(set, n, sum):\n    # Base Cases\n    if sum == 0:\n        return True\n    if n == 0:\n        return False\n    \n    # If the last element is greater than sum, ignore it\n    if set[n-1] > sum:\n        return is_subset_sum(set, n-1, sum)\n    \n    # Check if sum can be obtained by either including or excluding the last element\n    return is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])"}
{"task_id": 482, "completion": "def match(text):\n    # Compile a regex pattern for better performance if you call this function many times\n    pattern = re.compile(r'([A-Z][a-z]+)')\n    \n    # Find all non-overlapping matches of the pattern in the string\n    matches = pattern.findall(text)\n    \n    # Return the list of matches\n    return matches"}
{"task_id": 483, "completion": "def first_Factorial_Divisible_Number(x):\n    # Handles edge cases\n    if x <= 1:\n        return 1\n    \n    # Starts from 1 as factorial of 0 and 1 both are 1\n    n = 1\n    factorial = 1\n    while True:\n        # Calculate factorial of n\n        factorial *= n\n        \n        # Check if factorial is divisible by x\n        if factorial % x == 0:\n            return n\n        \n        n += 1"}
{"task_id": 484, "completion": "def remove_matching_tuple(test_list1, test_list2):\n    # Using list comprehension to remove matching tuples from both lists\n    result_list1 = [tup for tup in test_list1 if tup not in test_list2]\n    result_list2 = [tup for tup in test_list2 if tup not in test_list1]\n\n    return result_list1, result_list2\n`"}
{"task_id": 485, "completion": "def is_palindrome(number):\n    # Convert the number to a string for easy manipulation\n    num_str = str(number)\n    # Check if the string is equal to its reverse\n    return num_str == num_str[::-1]"}
{"task_id": 486, "completion": "def binomial_probability(n, r, p):\n    # Calculate the binomial probability\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n-1)\n\n    def nCr(n, r):\n        # Calculate the binomial coefficient\n        return factorial(n) / (factorial(r) * factorial(n-r))\n\n    return nCr(n, r) * (p ** r) * ((1 - p) ** (n - r))"}
{"task_id": 487, "completion": "def sort_tuple(tup):\n    # Using the sorted function with key\n    return sorted(tup, key=lambda x: x[-1])"}
{"task_id": 488, "completion": "import math\n\ndef area_pentagon(a):\n    \"\"\"\n    Calculate the area of a regular pentagon given the length of a side.\n\n    Parameters:\n    a: Length of a side of the pentagon.\n\n    Returns:\n    The area of the pentagon.\n    \"\"\"\n    return (5/4) * a**2 * (1/math.tan(math.pi/5))"}
{"task_id": 489, "completion": "def frequency_Of_Largest(n, arr):\n    # If the array is empty, return 0 as the frequency\n    if n == 0:\n        return 0\n\n    # Step 1: Find the largest value in the array\n    largest = max(arr)\n    \n    # Step 2: Count the frequency of the largest value\n    frequency = arr.count(largest)\n    \n    return frequency"}
{"task_id": 490, "completion": "def extract_symmetric(test_list):\n    # Container for the symmetric pairs\n    symmetric_pairs = []\n    \n    # Use a set to efficiently check for symmetric pairs\n    seen = set()\n    \n    for pair in test_list:\n        # Check if the reverse pair exists in seen, indicating it is a symmetric pair\n        if (pair[1], pair[0]) in seen:\n            symmetric_pairs.append(pair)\n        else:\n            # Add the current pair to the set for future reference\n            seen.add(pair)\n            \n    return symmetric_pairs"}
{"task_id": 491, "completion": "def sum_gp(a, n, r):\n    \"\"\"\n    Calculate the sum of the first n terms of a geometric progression series.\n    Arguments:\n    a -- the first term of the GP series.\n    n -- the number of terms to sum.\n    r -- the common ratio of the GP series.\n\n    Returns:\n    The sum of the first n terms of the GP series.\n    \"\"\"\n    # For a geometric series where the ratio is 1, each term is simply the first term\n    if r == 1:\n        return n * a\n    else:\n        # Calculate the sum using the formula for geometric series\n        return a * (1 - r ** n) / (1 - r)\n`"}
{"task_id": 492, "completion": "def binary_search(item_list, item):\n    low = 0\n    high = len(item_list) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        guess = item_list[mid]\n        if guess == item:\n            return mid\n        if guess > item:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1"}
{"task_id": 493, "completion": "import math\n\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    # Define a list to hold all the hexagon centers\n    hex_centers = []\n    \n    # Horizontal and vertical distances between hexagon centers\n    horizontal_distance = radius * 3/2\n    vertical_distance = math.sqrt(3) * radius\n    \n    # Initialize y-coordinate\n    y = starty\n    \n    # Generate hexagon centers\n    while y + radius < endy:\n        row = []\n        x_offset = 0\n        if (y / vertical_distance) % 2 == 1:\n            x_offset = radius * 3/4\n        x = startx + x_offset\n        while x + radius < endx:\n            row.append((x, y))\n            x += horizontal_distance\n        hex_centers.append(row)\n        y += vertical_distance / 2\n    \n    # Calculate vertex coordinates for each hexagon\n    hex_vertices = []\n    for row in hex_centers:\n        for center in row:\n            vertices = []\n            for i in range(6):\n                angle_deg = 60 * i + 30\n                angle_rad = math.pi / 180 * angle_deg\n                x = center[0] + radius * math.cos(angle_rad)\n                y = center[1] + radius * math.sin(angle_rad)\n                vertices.append((x, y))\n            hex_vertices.append(vertices)\n    \n    return hex_vertices"}
{"task_id": 494, "completion": "def binary_to_integer(test_tup):\n    binary_str = ''.join(str(bit) for bit in test_tup)\n    result = int(binary_str, 2)\n    return result"}
{"task_id": 495, "completion": "def remove_lowercase(str1):\n    # Define a pattern to match lowercase substrings\n    pattern = '[a-z]+'\n    \n    # Use re.sub() to replace all lowercase substrings with an empty string\n    result = re.sub(pattern, '', str1)\n    \n    return result"}
{"task_id": 496, "completion": "import heapq\n\ndef heap_queue_smallest(nums, n):\n    \"\"\"\n    Find the `n` smallest integers from a given list `nums` using heap queue algorithm.\n\n    Parameters:\n    - nums: List[int] - A list of integers from which to find the smallest numbers.\n    - n: int - The number of smallest integers to find.\n\n    Returns:\n    - List[int]: A list of the `n` smallest integers from the given list.\n    \"\"\"\n    # Using `heapq.nsmallest` to directly find the n smallest elements\n    return heapq.nsmallest(n, nums)"}
{"task_id": 497, "completion": "def surfacearea_cone(r, h):\n    \"\"\"\n    Calculate the surface area of a cone.\n    \n    Parameters:\n    r (float): The radius of the cone's base.\n    h (float): The height of the cone.\n    \n    Returns:\n    float: The surface area of the cone.\n    \"\"\"\n\n    surface_area = math.pi * r * (r + math.sqrt(h**2 + r**2))\n    return surface_area"}
{"task_id": 498, "completion": "# Function to calculate GCD of two numbers\ndef gcd(x, y):\n    # Make sure the function works even if y > x\n    while(y):\n        x, y = y, x % y\n    return x"}
{"task_id": 499, "completion": "def diameter_circle(r):\n    diameter = 2 * r\n    return diameter"}
{"task_id": 500, "completion": "def concatenate_elements(lst):\n    # Initialize an empty string\n    result = \"\"\n    # Loop through each element in the list\n    for element in lst:\n        # Convert each element to a string (in case it's not) and concatenate\n        result += str(element)\n    # Return the concatenated string\n    return result"}
{"task_id": 501, "completion": "def find_common_divisors(x, y):\n    \"\"\"\n    This function finds all common divisors between two numbers x and y.\n    Args:\n    x (int): The first number.\n    y (int): The second number.\n\n    Returns:\n    list: A list containing all common divisors of x and y.\n    \"\"\"\n    # Ensure that x and y are positive\n    x, y = abs(x), abs(y)\n    \n    # Find the smaller number to reduce the loop's iteration\n    smaller = min(x, y)\n    \n    common_divisors = []  # This will store all common divisors\n    \n    for i in range(1, smaller + 1):\n        if x % i == 0 and y % i == 0:\n            common_divisors.append(i)\n            \n    return common_divisors"}
{"task_id": 502, "completion": "def find(n, m):\n    \"\"\"\n    Returns the remainder of n divided by m.\n\n    Parameters:\n    n (int): Dividend.\n    m (int): Divisor.\n\n    Returns:\n    int: The remainder of n divided by m.\n    \"\"\"\n    return n % m"}
{"task_id": 503, "completion": "def add_consecutive_nums(nums):\n    # Initialize an empty list to store the sum of consecutive numbers\n    added_nums = []\n    # Loop over the list until the second last element\n    for i in range(len(nums)-1):\n        # Add the current element to the next one and append the result to `added_nums`\n        added_nums.append(nums[i] + nums[i+1])\n    # Return the list containing the sum of consecutive numbers\n    return added_nums"}
{"task_id": 504, "completion": "def sum_Of_Series(n):\n    # First, calculate the sum of the first n natural numbers\n    sum = (n * (n + 1)) // 2\n    # Then, square the sum to get the sum of cubes\n    sumOfCubes = sum * sum\n    return sumOfCubes"}
{"task_id": 505, "completion": "def re_order(A):\n    # Find the number of non-zero elements in the list\n    count = 0\n    \n    # Loop through the list, moving non-zero elements to the start of the list\n    for i in range(len(A)):\n        if A[i] != 0:\n            A[count] = A[i]\n            count += 1\n            \n    # All non-zero elements have been moved to the start\n    # Now fill the remaining positions with 0\n    while count < len(A):\n        A[count] = 0\n        count += 1"}
{"task_id": 506, "completion": "def permutation_coefficient(n, k):\n    \"\"\"\n    Calculate the permutation coefficient P(n, k).\n    \n    Parameters:\n    n (int): The total number of distinct elements.\n    k (int): The number of elements to choose.\n    \n    Returns:\n    int: The permutation coefficient P(n, k).\n    \"\"\"\n    return factorial(n) // factorial(n - k)\n`"}
{"task_id": 507, "completion": "def remove_words(list1, removewords):\n    # Create a new list to store the result\n    result = []\n    \n    # Iterate through each word in the original list\n    for word in list1:\n        # If the word is not in the list of words to remove, add it to the result list\n        if word not in removewords:\n            result.append(word)\n    \n    # Return the filtered list\n    return result\n`"}
{"task_id": 508, "completion": "def same_order(l1, l2):\n    # Extract common elements while preserving their order from the first list\n    common_elements_ordered = [element for element in l1 if element in l2]\n    \n    # Iterate over the second list and keep track of common elements in their order\n    common_elements_order_in_l2 = [element for element in l2 if element in common_elements_ordered]\n    \n    # Since we might have duplicates, we ensure to capture the sequence without regard to duplicate impact\n    # This is a filtering step to retain the first appearance sequence\n    filtered_sequence_l2 = []\n    [filtered_sequence_l2.append(element) for element in common_elements_order_in_l2 if element not in filtered_sequence_l2]\n    \n    # Compare the sequence of common elements in both lists\n    return common_elements_ordered == filtered_sequence_l2\n`"}
{"task_id": 509, "completion": "def average_Odd(n):\n    # Check if n is odd; if n is not odd, adjust to the nearest lesser odd or return None/error\n    if n % 2 == 0:\n        print(\"Warning: Input is not an odd number. Adjusting to the nearest lesser odd number.\")\n        n -= 1\n\n    # Initialize sum and count\n    sum_odds = 0\n    count_odds = 0\n\n    # Loop through the range of odd numbers\n    for i in range(1, n+1, 2):\n        sum_odds += i  # Add current odd number to sum\n        count_odds += 1  # Increment count\n\n    # Calculate and return average\n    return sum_odds / count_odds"}
{"task_id": 510, "completion": "def count_subsequences(arr, n, k):\n    if k == 1:\n        return 0\n    elif n == 0:\n        return 1 if arr[0] < k else 0\n    else:\n        include_count = 0\n        if arr[n] < k:\n            include_count = count_subsequences(arr, n-1, k//arr[n])\n        exclude_count = count_subsequences(arr, n-1, k)\n        return include_count + exclude_count + 1"}
